
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>domain: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/hryt430/Yotei&#43;/internal/modules/auth/domain/user.go (100.0%)</option>
				
				<option value="file1">github.com/hryt430/Yotei&#43;/internal/modules/auth/infrastructure/database/sqlhandler.go (0.0%)</option>
				
				<option value="file2">github.com/hryt430/Yotei&#43;/internal/modules/auth/infrastructure/middleware/auth_middleware.go (0.0%)</option>
				
				<option value="file3">github.com/hryt430/Yotei&#43;/internal/modules/auth/infrastructure/redis/token_cache.go (0.0%)</option>
				
				<option value="file4">github.com/hryt430/Yotei&#43;/internal/modules/auth/interface/controller/auth_controller.go (0.0%)</option>
				
				<option value="file5">github.com/hryt430/Yotei&#43;/internal/modules/auth/interface/controller/users_controller.go (0.0%)</option>
				
				<option value="file6">github.com/hryt430/Yotei&#43;/internal/modules/auth/interface/database/token_storage.go (0.0%)</option>
				
				<option value="file7">github.com/hryt430/Yotei&#43;/internal/modules/auth/interface/database/user_repository.go (0.0%)</option>
				
				<option value="file8">github.com/hryt430/Yotei&#43;/internal/modules/auth/interface/redis/repository.go (0.0%)</option>
				
				<option value="file9">github.com/hryt430/Yotei&#43;/internal/modules/auth/usecase/auth/application_service.go (87.8%)</option>
				
				<option value="file10">github.com/hryt430/Yotei&#43;/internal/modules/auth/usecase/mocks/mock_token_repository.go (0.0%)</option>
				
				<option value="file11">github.com/hryt430/Yotei&#43;/internal/modules/auth/usecase/mocks/mock_user_repository.go (0.0%)</option>
				
				<option value="file12">github.com/hryt430/Yotei&#43;/internal/modules/auth/usecase/token/application_service.go (95.0%)</option>
				
				<option value="file13">github.com/hryt430/Yotei&#43;/internal/modules/auth/usecase/token/mocks/mock_repository.go (0.0%)</option>
				
				<option value="file14">github.com/hryt430/Yotei&#43;/internal/modules/auth/usecase/user/application_service.go (92.1%)</option>
				
				<option value="file15">github.com/hryt430/Yotei&#43;/internal/modules/auth/usecase/user/mocks/mock_repository.go (0.0%)</option>
				
				<option value="file16">github.com/hryt430/Yotei&#43;/internal/modules/group/domain/group.go (100.0%)</option>
				
				<option value="file17">github.com/hryt430/Yotei&#43;/internal/modules/group/infrastructure/database/sqlhandler.go (0.0%)</option>
				
				<option value="file18">github.com/hryt430/Yotei&#43;/internal/modules/group/interface/controller/group_controller.go (0.0%)</option>
				
				<option value="file19">github.com/hryt430/Yotei&#43;/internal/modules/group/interface/database/group_repository.go (0.0%)</option>
				
				<option value="file20">github.com/hryt430/Yotei&#43;/internal/modules/group/interface/dto/group_dto.go (0.0%)</option>
				
				<option value="file21">github.com/hryt430/Yotei&#43;/internal/modules/group/usecase/mocks/mock_repositories.go (0.0%)</option>
				
				<option value="file22">github.com/hryt430/Yotei&#43;/internal/modules/group/usecase/mocks/mock_user_validator.go (0.0%)</option>
				
				<option value="file23">github.com/hryt430/Yotei&#43;/internal/modules/group/usecase/service.go (61.5%)</option>
				
				<option value="file24">github.com/hryt430/Yotei&#43;/internal/modules/notification/domain/channel.go (100.0%)</option>
				
				<option value="file25">github.com/hryt430/Yotei&#43;/internal/modules/notification/domain/notification.go (100.0%)</option>
				
				<option value="file26">github.com/hryt430/Yotei&#43;/internal/modules/notification/infrastructure/database/sqlhandler.go (0.0%)</option>
				
				<option value="file27">github.com/hryt430/Yotei&#43;/internal/modules/notification/infrastructure/gateway/app_gateway.go (0.0%)</option>
				
				<option value="file28">github.com/hryt430/Yotei&#43;/internal/modules/notification/infrastructure/gateway/line_gateway.go (0.0%)</option>
				
				<option value="file29">github.com/hryt430/Yotei&#43;/internal/modules/notification/infrastructure/messaging/messaging.go (0.0%)</option>
				
				<option value="file30">github.com/hryt430/Yotei&#43;/internal/modules/notification/infrastructure/messaging/notification_scheduler.go (0.0%)</option>
				
				<option value="file31">github.com/hryt430/Yotei&#43;/internal/modules/notification/interface/controller/handler.go (0.0%)</option>
				
				<option value="file32">github.com/hryt430/Yotei&#43;/internal/modules/notification/interface/database/notification_handler.go (0.0%)</option>
				
				<option value="file33">github.com/hryt430/Yotei&#43;/internal/modules/notification/interface/dto/notification_dto.go (0.0%)</option>
				
				<option value="file34">github.com/hryt430/Yotei&#43;/internal/modules/notification/interface/websocket/client.go (0.0%)</option>
				
				<option value="file35">github.com/hryt430/Yotei&#43;/internal/modules/notification/interface/websocket/hub.go (0.0%)</option>
				
				<option value="file36">github.com/hryt430/Yotei&#43;/internal/modules/notification/usecase/mocks/mock_gateway.go (0.0%)</option>
				
				<option value="file37">github.com/hryt430/Yotei&#43;/internal/modules/notification/usecase/mocks/mock_repository.go (0.0%)</option>
				
				<option value="file38">github.com/hryt430/Yotei&#43;/internal/modules/notification/usecase/mocks/mock_user_validator.go (0.0%)</option>
				
				<option value="file39">github.com/hryt430/Yotei&#43;/internal/modules/notification/usecase/notification_service.go (62.3%)</option>
				
				<option value="file40">github.com/hryt430/Yotei&#43;/internal/modules/social/domain/friendship.go (100.0%)</option>
				
				<option value="file41">github.com/hryt430/Yotei&#43;/internal/modules/social/infrastructure/database/sqlhandler.go (0.0%)</option>
				
				<option value="file42">github.com/hryt430/Yotei&#43;/internal/modules/social/infrastructure/messaging/notification_adapter.go (0.0%)</option>
				
				<option value="file43">github.com/hryt430/Yotei&#43;/internal/modules/social/infrastructure/messaging/social_event_publisher.go (0.0%)</option>
				
				<option value="file44">github.com/hryt430/Yotei&#43;/internal/modules/social/interface/controller/social_controller.go (0.0%)</option>
				
				<option value="file45">github.com/hryt430/Yotei&#43;/internal/modules/social/interface/database/friendship_repository.go (0.0%)</option>
				
				<option value="file46">github.com/hryt430/Yotei&#43;/internal/modules/social/interface/database/invitation_repository.go (0.0%)</option>
				
				<option value="file47">github.com/hryt430/Yotei&#43;/internal/modules/social/interface/dto/social_dto.go (0.0%)</option>
				
				<option value="file48">github.com/hryt430/Yotei&#43;/internal/modules/social/usecase/internal/modules/social/usecase/mocks/mock_user_validator.go (0.0%)</option>
				
				<option value="file49">github.com/hryt430/Yotei&#43;/internal/modules/social/usecase/mocks/mock_repositories.go (0.0%)</option>
				
				<option value="file50">github.com/hryt430/Yotei&#43;/internal/modules/social/usecase/mocks/mock_services.go (0.0%)</option>
				
				<option value="file51">github.com/hryt430/Yotei&#43;/internal/modules/social/usecase/mocks/mock_user_validator.go (0.0%)</option>
				
				<option value="file52">github.com/hryt430/Yotei&#43;/internal/modules/social/usecase/service.go (48.8%)</option>
				
				<option value="file53">github.com/hryt430/Yotei&#43;/internal/modules/task/domain/stats.go (100.0%)</option>
				
				<option value="file54">github.com/hryt430/Yotei&#43;/internal/modules/task/domain/task.go (91.8%)</option>
				
				<option value="file55">github.com/hryt430/Yotei&#43;/internal/modules/task/infrastructure/database/sqlhandler.go (0.0%)</option>
				
				<option value="file56">github.com/hryt430/Yotei&#43;/internal/modules/task/infrastructure/messaging/event_publisher.go (0.0%)</option>
				
				<option value="file57">github.com/hryt430/Yotei&#43;/internal/modules/task/infrastructure/messaging/notification_adapter.go (0.0%)</option>
				
				<option value="file58">github.com/hryt430/Yotei&#43;/internal/modules/task/infrastructure/messaging/notification_scheduler.go (0.0%)</option>
				
				<option value="file59">github.com/hryt430/Yotei&#43;/internal/modules/task/infrastructure/messaging/task_event_publisher.go (0.0%)</option>
				
				<option value="file60">github.com/hryt430/Yotei&#43;/internal/modules/task/interface/controller/stats_controller.go (0.0%)</option>
				
				<option value="file61">github.com/hryt430/Yotei&#43;/internal/modules/task/interface/controller/task_controller.go (0.0%)</option>
				
				<option value="file62">github.com/hryt430/Yotei&#43;/internal/modules/task/interface/database/stats_handler.go (0.0%)</option>
				
				<option value="file63">github.com/hryt430/Yotei&#43;/internal/modules/task/interface/database/task_handler.go (0.0%)</option>
				
				<option value="file64">github.com/hryt430/Yotei&#43;/internal/modules/task/interface/dto/dto.go (0.0%)</option>
				
				<option value="file65">github.com/hryt430/Yotei&#43;/internal/modules/task/usecase/mocks/mock_stats_repository.go (0.0%)</option>
				
				<option value="file66">github.com/hryt430/Yotei&#43;/internal/modules/task/usecase/mocks/mock_task_repository.go (0.0%)</option>
				
				<option value="file67">github.com/hryt430/Yotei&#43;/internal/modules/task/usecase/service.go (38.9%)</option>
				
				<option value="file68">github.com/hryt430/Yotei&#43;/internal/modules/task/usecase/stats_service.go (95.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package domain

import (
        "fmt"
        "time"

        "github.com/google/uuid"
)

// User roles
const (
        RoleUser  = "user"
        RoleAdmin = "admin"
)

type User struct {
        ID            uuid.UUID      `json:"id"`
        Email         string         `json:"email"`
        Username      string         `json:"username"`
        Password      string         `json:"-"` // パスワードはJSONに含めない
        Role          string         `json:"role"`
        EmailVerified bool           `json:"email_verified"`
        LastLogin     *time.Time     `json:"last_login"`
        RefreshTokens []RefreshToken `json:"-"`
        CreatedAt     time.Time      `json:"created_at"`
        UpdatedAt     time.Time      `json:"updated_at"`
}

// NewUser は新しいUserを作成する
func NewUser(email, username, password string) *User <span class="cov8" title="1">{
        now := time.Now()
        return &amp;User{
                ID:            uuid.New(),
                Email:         email,
                Username:      username,
                Password:      password,
                Role:          RoleUser,
                EmailVerified: false,
                LastLogin:     nil,
                CreatedAt:     now,
                UpdatedAt:     now,
        }
}</span>

// SetRole はユーザーの役割を設定する
func (u *User) SetRole(role string) error <span class="cov8" title="1">{
        if role != RoleUser &amp;&amp; role != RoleAdmin </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid role: %s", role)
        }</span>
        <span class="cov8" title="1">u.Role = role
        u.UpdatedAt = time.Now()
        return nil</span>
}

// UpdateLastLogin は最終ログイン時刻を更新する
func (u *User) UpdateLastLogin() <span class="cov8" title="1">{
        now := time.Now()
        u.LastLogin = &amp;now
        u.UpdatedAt = now
}</span>

// IsAdmin はユーザーが管理者かどうかを返す
func (u *User) IsAdmin() bool <span class="cov8" title="1">{
        return u.Role == RoleAdmin
}</span>

type RefreshToken struct {
        ID        uuid.UUID  `json:"id"`
        Token     string     `json:"-"`
        UserID    uuid.UUID  `json:"-"`
        ExpiresAt time.Time  `json:"expires_at"`
        IssuedAt  time.Time  `json:"issued_at"`
        RevokedAt *time.Time `json:"revoked_at"`
        CreatedAt time.Time  `json:"created_at"`
        UpdatedAt time.Time  `json:"updated_at"`
}

// NewRefreshToken は新しいRefreshTokenを作成する
func NewRefreshToken(userID uuid.UUID, token string, expirationDuration time.Duration) *RefreshToken <span class="cov8" title="1">{
        now := time.Now()
        return &amp;RefreshToken{
                ID:        uuid.New(),
                Token:     token,
                UserID:    userID,
                ExpiresAt: now.Add(expirationDuration),
                IssuedAt:  now,
                RevokedAt: nil,
                CreatedAt: now,
                UpdatedAt: now,
        }
}</span>

// IsExpired はトークンが期限切れかどうかを判定する
func (rt *RefreshToken) IsExpired() bool <span class="cov8" title="1">{
        return time.Now().After(rt.ExpiresAt)
}</span>

// IsRevoked はトークンが無効化されているかどうかを判定する
func (rt *RefreshToken) IsRevoked() bool <span class="cov8" title="1">{
        return rt.RevokedAt != nil
}</span>

// Revoke はトークンを無効化する
func (rt *RefreshToken) Revoke() <span class="cov8" title="1">{
        now := time.Now()
        rt.RevokedAt = &amp;now
        rt.UpdatedAt = now
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package databaseInfra

import (
        "database/sql"
        "fmt"

        "github.com/hryt430/Yotei+/config"
        commonDB "github.com/hryt430/Yotei+/internal/common/infrastructure/database"
        "github.com/hryt430/Yotei+/internal/modules/auth/interface/database"
)

type SqlHandler struct {
        Conn *sql.DB
}

func NewSqlHandler() SqlHandler <span class="cov0" title="0">{
        config, err := config.LoadConfig(".")
        if err != nil </span><span class="cov0" title="0">{
                panic(err.Error())</span>
        }

        // common/databaseからDBコネクションを取得
        <span class="cov0" title="0">conn, err := commonDB.NewMySQLConnection(config)
        if err != nil </span><span class="cov0" title="0">{
                panic(err.Error())</span>
        }

        <span class="cov0" title="0">sqlHandler := new(SqlHandler)
        sqlHandler.Conn = conn
        return *sqlHandler</span>
}

func (h *SqlHandler) Execute(statement string, args ...interface{}) (database.Result, error) <span class="cov0" title="0">{
        res, err := h.Conn.Exec(statement, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ステートメント実行失敗: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;SqlResult{res}, nil</span>
}

func (h *SqlHandler) Query(statement string, args ...interface{}) (database.Row, error) <span class="cov0" title="0">{
        rows, err := h.Conn.Query(statement, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("クエリ実行失敗: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;SqlRow{Rows: rows}, nil</span>
}

func (h *SqlHandler) Close() error <span class="cov0" title="0">{
        return h.Conn.Close()
}</span>

type SqlResult struct {
        Result sql.Result
}

func (r *SqlResult) LastInsertId() (int64, error) <span class="cov0" title="0">{
        return r.Result.LastInsertId()
}</span>

func (r *SqlResult) RowsAffected() (int64, error) <span class="cov0" title="0">{
        return r.Result.RowsAffected()
}</span>

type SqlRow struct {
        Rows *sql.Rows
}

func (r *SqlRow) Scan(dest ...interface{}) error <span class="cov0" title="0">{
        return r.Rows.Scan(dest...)
}</span>

func (r *SqlRow) Next() bool <span class="cov0" title="0">{
        return r.Rows.Next()
}</span>

func (r *SqlRow) Close() error <span class="cov0" title="0">{
        return r.Rows.Close()
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package middleware

import (
        "net/http"
        "strings"

        commonMiddleware "github.com/hryt430/Yotei+/internal/common/middleware"
        tokenService "github.com/hryt430/Yotei+/internal/modules/auth/usecase/token"
        token "github.com/hryt430/Yotei+/pkg/token"
        "github.com/hryt430/Yotei+/pkg/utils"

        "github.com/gin-gonic/gin"
)

type AuthMiddleware struct {
        tokenUseCase tokenService.TokenService
}

func NewAuthMiddleware(tokenUseCase tokenService.TokenService) *AuthMiddleware <span class="cov0" title="0">{
        return &amp;AuthMiddleware{
                tokenUseCase: tokenUseCase,
        }
}</span>

// AuthRequired は認証を必要とするエンドポイント用のミドルウェア
func (m *AuthMiddleware) AuthRequired() gin.HandlerFunc <span class="cov0" title="0">{
        return func(ctx *gin.Context) </span><span class="cov0" title="0">{
                // トークンの取得（ヘッダーまたはCookie）
                tokenString := m.extractToken(ctx)
                if tokenString == "" </span><span class="cov0" title="0">{
                        ctx.AbortWithStatusJSON(http.StatusUnauthorized, utils.ErrorResponse("Authorization token required"))
                        return
                }</span>

                // トークンの検証
                <span class="cov0" title="0">claims, err := m.tokenUseCase.ValidateAccessToken(tokenString)
                if err != nil </span><span class="cov0" title="0">{
                        if err == token.ErrExpiredToken </span><span class="cov0" title="0">{
                                ctx.AbortWithStatusJSON(http.StatusUnauthorized, utils.ErrorResponse("Token has expired"))
                                return
                        }</span>
                        <span class="cov0" title="0">if err == token.ErrTokenBlacklisted </span><span class="cov0" title="0">{
                                ctx.AbortWithStatusJSON(http.StatusUnauthorized, utils.ErrorResponse("Token has been revoked"))
                                return
                        }</span>
                        <span class="cov0" title="0">ctx.AbortWithStatusJSON(http.StatusUnauthorized, utils.ErrorResponse("Invalid token"))
                        return</span>
                }

                // ユーザー情報をコンテキストに設定
                <span class="cov0" title="0">ctx.Set("user_id", claims.UserID)
                ctx.Set("email", claims.Email)
                ctx.Set("username", claims.Username)
                ctx.Set("role", claims.Role)

                ctx.Next()</span>
        }
}

func (m *AuthMiddleware) WebSocketAuthRequired() gin.HandlerFunc <span class="cov0" title="0">{
        return func(ctx *gin.Context) </span><span class="cov0" title="0">{
                // トークンをクエリパラメータから取得
                tokenString := ctx.Query("token")
                if tokenString == "" </span><span class="cov0" title="0">{
                        ctx.JSON(http.StatusBadRequest, gin.H{"error": "token is required"})
                        ctx.Abort()
                        return
                }</span>

                <span class="cov0" title="0">claims, err := m.tokenUseCase.ValidateAccessToken(tokenString)
                if err != nil </span><span class="cov0" title="0">{
                        if err == token.ErrExpiredToken </span><span class="cov0" title="0">{
                                ctx.JSON(http.StatusUnauthorized, gin.H{"error": "Token has expired"})
                                ctx.Abort()
                                return
                        }</span>
                        <span class="cov0" title="0">if err == token.ErrTokenBlacklisted </span><span class="cov0" title="0">{
                                ctx.JSON(http.StatusUnauthorized, gin.H{"error": "Token has been revoked"})
                                ctx.Abort()
                                return
                        }</span>
                        <span class="cov0" title="0">ctx.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token"})
                        ctx.Abort()
                        return</span>
                }

                // ユーザー情報をコンテキストに設定（既存のAuthRequiredと同じ）
                <span class="cov0" title="0">ctx.Set("user_id", claims.UserID)
                ctx.Set("email", claims.Email)
                ctx.Set("username", claims.Username)
                ctx.Set("role", claims.Role)

                ctx.Next()</span>
        }
}

// extractToken はリクエストからトークンを抽出
func (m *AuthMiddleware) extractToken(ctx *gin.Context) string <span class="cov0" title="0">{
        // Authorizationヘッダーからトークンを取得
        authHeader := ctx.GetHeader("Authorization")
        if authHeader != "" &amp;&amp; strings.HasPrefix(authHeader, "Bearer ") </span><span class="cov0" title="0">{
                return strings.TrimPrefix(authHeader, "Bearer ")
        }</span>

        // ヘッダーがなければCookieから
        <span class="cov0" title="0">token, err := ctx.Cookie("access_token")
        if err == nil </span><span class="cov0" title="0">{
                return token
        }</span>

        <span class="cov0" title="0">return ""</span>
}

// RoleRequired は特定のロールを持つユーザーのみアクセス可能にするミドルウェア
func (m *AuthMiddleware) RoleRequired(role string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(ctx *gin.Context) </span><span class="cov0" title="0">{
                // すでに認証済みであることを前提
                userRole, exists := ctx.Get("role")
                if !exists </span><span class="cov0" title="0">{
                        ctx.AbortWithStatusJSON(http.StatusUnauthorized, utils.ErrorResponse("User not authenticated"))
                        return
                }</span>

                // ロールチェック
                <span class="cov0" title="0">if userRole != role </span><span class="cov0" title="0">{
                        ctx.AbortWithStatusJSON(http.StatusForbidden, utils.ErrorResponse("Access denied: insufficient privileges"))
                        return
                }</span>

                <span class="cov0" title="0">ctx.Next()</span>
        }
}

// CORS、CSRF関連のミドルウェアは共通パッケージから参照
var (
        // CORSMiddleware は共通ミドルウェアのCORSMiddlewareを参照
        CORSMiddleware = commonMiddleware.CORSMiddleware

        // CSRFProtection は共通ミドルウェアのCSRFProtectionを参照
        CSRFProtection = commonMiddleware.CSRFProtection

        // SetCSRFToken は共通ミドルウェアのSetCSRFTokenを参照
        SetCSRFToken = commonMiddleware.SetCSRFToken
)
</pre>
		
		<pre class="file" id="file3" style="display: none">package redis

import (
        "context"
        "time"

        "github.com/go-redis/redis/v8"
)

// RedisTokenCache はRedisを使用したトークンキャッシュの実装
type RedisTokenCache struct {
        client *redis.Client
        ctx    context.Context
}

func NewRedisTokenCache(client *redis.Client) *RedisTokenCache <span class="cov0" title="0">{
        return &amp;RedisTokenCache{
                client: client,
                ctx:    context.Background(),
        }
}</span>

func (r *RedisTokenCache) SetWithTTL(key string, value string, ttl time.Duration) error <span class="cov0" title="0">{
        return r.client.Set(r.ctx, key, value, ttl).Err()
}</span>

func (r *RedisTokenCache) Get(key string) (string, error) <span class="cov0" title="0">{
        return r.client.Get(r.ctx, key).Result()
}</span>

func (r *RedisTokenCache) Exists(key string) bool <span class="cov0" title="0">{
        val, err := r.client.Exists(r.ctx, key).Result()
        return err == nil &amp;&amp; val &gt; 0
}</span>

func (r *RedisTokenCache) Delete(key string) error <span class="cov0" title="0">{
        return r.client.Del(r.ctx, key).Err()
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package controller

import (
        "net/http"
        "strings"
        "time"

        authService "github.com/hryt430/Yotei+/internal/modules/auth/usecase/auth"
        "github.com/hryt430/Yotei+/pkg/logger"

        "github.com/gin-gonic/gin"
)

type AuthController struct {
        Interactor authService.AuthService
        logger     logger.Logger
}

func NewAuthController(interactor authService.AuthService, logger logger.Logger) *AuthController <span class="cov0" title="0">{
        return &amp;AuthController{
                Interactor: interactor,
                logger:     logger,
        }
}</span>

// RegisterRequest はユーザー登録のリクエスト構造体
type RegisterRequest struct {
        Email    string `json:"email" binding:"required,email" example:"user@example.com"`
        Username string `json:"username" binding:"required,min=3,max=30" example:"johndoe"`
        Password string `json:"password" binding:"required,min=8" example:"password123"`
} // @name RegisterRequest

// LoginRequest はログインのリクエスト構造体
type LoginRequest struct {
        Email    string `json:"email" binding:"required,email" example:"user@example.com"`
        Password string `json:"password" binding:"required" example:"password123"`
} // @name LoginRequest

// RefreshTokenRequest はトークン更新のリクエスト構造体
type RefreshTokenRequest struct {
        RefreshToken string `json:"refresh_token" binding:"required" example:"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."`
} // @name RefreshTokenRequest

// LogoutRequest はログアウトのリクエスト構造体
type LogoutRequest struct {
        RefreshToken string `json:"refresh_token" binding:"required" example:"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."`
} // @name LogoutRequest

// ErrorResponse はエラーレスポンス構造体
type ErrorResponse struct {
        Success bool   `json:"success" example:"false"`
        Error   string `json:"error" example:"INVALID_REQUEST"`
        Message string `json:"message" example:"リクエストが無効です"`
} // @name ErrorResponse

// RegisterResponse はユーザー登録のレスポンス構造体
type RegisterResponse struct {
        Success bool   `json:"success" example:"true"`
        Message string `json:"message" example:"User registered successfully"`
        Data    struct {
                UserID   string `json:"user_id" example:"123e4567-e89b-12d3-a456-426614174000"`
                Username string `json:"username" example:"johndoe"`
                Email    string `json:"email" example:"user@example.com"`
        } `json:"data"`
} // @name RegisterResponse

// LoginResponse はログインのレスポンス構造体
type LoginResponse struct {
        Success bool   `json:"success" example:"true"`
        Message string `json:"message" example:"Login successful"`
        Data    struct {
                AccessToken  string `json:"access_token" example:"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."`
                RefreshToken string `json:"refresh_token" example:"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."`
                TokenType    string `json:"token_type" example:"Bearer"`
        } `json:"data"`
} // @name LoginResponse

// RefreshTokenResponse はトークン更新のレスポンス構造体
type RefreshTokenResponse struct {
        Success bool   `json:"success" example:"true"`
        Message string `json:"message" example:"Token refreshed successfully"`
        Data    struct {
                AccessToken  string `json:"access_token" example:"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."`
                RefreshToken string `json:"refresh_token" example:"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."`
                TokenType    string `json:"token_type" example:"Bearer"`
        } `json:"data"`
} // @name RefreshTokenResponse

// MeResponse は現在のユーザー情報のレスポンス構造体
type MeResponse struct {
        Success bool `json:"success" example:"true"`
        Data    struct {
                UserID   string `json:"user_id" example:"123e4567-e89b-12d3-a456-426614174000"`
                Email    string `json:"email" example:"user@example.com"`
                Username string `json:"username" example:"johndoe"`
                Role     string `json:"role" example:"user"`
        } `json:"data"`
} // @name MeResponse

// LogoutResponse はログアウトのレスポンス構造体
type LogoutResponse struct {
        Success bool   `json:"success" example:"true"`
        Message string `json:"message" example:"Logged out successfully"`
} // @name LogoutResponse

// Register ユーザー登録
// @Summary      ユーザー登録
// @Description  新しいユーザーアカウントを作成します
// @Tags         auth
// @Accept       json
// @Produce      json
// @Param        request body RegisterRequest true "ユーザー登録情報"
// @Success      201 {object} RegisterResponse "ユーザー登録成功"
// @Failure      400 {object} ErrorResponse "リクエストが無効"
// @Failure      409 {object} ErrorResponse "ユーザーが既に存在"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /auth/register [post]
func (c *AuthController) Register(ctx *gin.Context) <span class="cov0" title="0">{
        var req RegisterRequest
        if err := ctx.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: err.Error(),
        })
                return
        }</span>

        // 入力値のサニタイズ
        <span class="cov0" title="0">req.Email = strings.TrimSpace(req.Email)
        req.Username = strings.TrimSpace(req.Username)

        user, err := c.Interactor.AuthRepository.Register(ctx, req.Email, req.Username, req.Password)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: err.Error(),
        })
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusCreated, gin.H{
                "success": true,
                "message": "User registered successfully",
                "data": gin.H{
                        "user_id":  user.ID,
                        "username": user.Username,
                        "email":    user.Email,
                },
        })</span>
}

// Login ユーザーログイン
// @Summary      ユーザーログイン
// @Description  メールアドレスとパスワードでログインし、アクセストークンとリフレッシュトークンを取得します
// @Tags         auth
// @Accept       json
// @Produce      json
// @Param        request body LoginRequest true "ログイン情報"
// @Success      200 {object} LoginResponse "ログイン成功"
// @Failure      400 {object} ErrorResponse "リクエストが無効"
// @Failure      401 {object} ErrorResponse "認証情報が無効"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /auth/login [post]
func (c *AuthController) Login(ctx *gin.Context) <span class="cov0" title="0">{
        var req LoginRequest
        if err := ctx.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: err.Error(),
        })
                return
        }</span>

        // 入力値のサニタイズ
        <span class="cov0" title="0">req.Email = strings.TrimSpace(req.Email)

        accessToken, refreshToken, err := c.Interactor.AuthRepository.Login(ctx, req.Email, req.Password)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusUnauthorized, ErrorResponse{
                Success: false,
                Error:   "INVALID_CREDENTIALS",
                Message: "Invalid credentials",
        })
                return
        }</span>

        // HTTPOnly cookieにトークンを設定
        <span class="cov0" title="0">ctx.SetCookie(
                "access_token",
                accessToken,
                int(time.Hour.Seconds()), // 1時間
                "/",
                "",
                true, // Secure
                true, // HTTPOnly
        )

        // リフレッシュトークンもCookieとして設定
        ctx.SetCookie(
                "refresh_token",
                refreshToken,
                int((7 * 24 * time.Hour).Seconds()), // 7日間
                "/",
                "",
                true, // Secure
                true, // HTTPOnly
        )

        ctx.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Login successful",
                "data": gin.H{
                        "access_token":  accessToken,
                        "refresh_token": refreshToken,
                        "token_type":    "Bearer",
                },
        })</span>
}

// RefreshToken トークン更新
// @Summary      アクセストークン更新
// @Description  リフレッシュトークンを使用して新しいアクセストークンを取得します
// @Tags         auth
// @Accept       json
// @Produce      json
// @Param        request body RefreshTokenRequest false "リフレッシュトークン（Cookieからも取得可能）"
// @Success      200 {object} RefreshTokenResponse "トークン更新成功"
// @Failure      400 {object} ErrorResponse "リクエストが無効"
// @Failure      401 {object} ErrorResponse "トークンが無効または期限切れ"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /auth/refresh-token [post]
func (c *AuthController) RefreshToken(ctx *gin.Context) <span class="cov0" title="0">{
        var req RefreshTokenRequest
        if err := ctx.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                // Cookieからリフレッシュトークンを取得を試行
                refreshToken, err := ctx.Cookie("refresh_token")
                if err != nil </span><span class="cov0" title="0">{
                        ctx.JSON(http.StatusBadRequest, ErrorResponse{
                Success: false,
                Error:   "MISSING_REFRESH_TOKEN",
                Message: "Refresh token is required",
        })
                        return
                }</span>
                <span class="cov0" title="0">req.RefreshToken = refreshToken</span>
        }

        <span class="cov0" title="0">newAccessToken, newRefreshToken, err := c.Interactor.RefreshToken(req.RefreshToken)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusUnauthorized, ErrorResponse{
                Success: false,
                Error:   "INVALID_REFRESH_TOKEN",
                Message: "Invalid or expired refresh token",
        })
                return
        }</span>

        // 新しいアクセストークンとリフレッシュトークンをCookieに設定
        <span class="cov0" title="0">ctx.SetCookie(
                "access_token",
                newAccessToken,
                int(time.Hour.Seconds()), // 1時間
                "/",
                "",
                true, // Secure
                true, // HTTPOnly
        )

        ctx.SetCookie(
                "refresh_token",
                newRefreshToken,
                int((7 * 24 * time.Hour).Seconds()), // 7日間
                "/",
                "",
                true, // Secure
                true, // HTTPOnly
        )

        ctx.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Token refreshed successfully",
                "data": gin.H{
                        "access_token":  newAccessToken,
                        "refresh_token": newRefreshToken,
                        "token_type":    "Bearer",
                },
        })</span>
}

// Logout ログアウト
// @Summary      ユーザーログアウト
// @Description  現在のセッションを終了し、トークンを無効化します
// @Tags         auth
// @Accept       json
// @Produce      json
// @Param        request body LogoutRequest false "リフレッシュトークン（Cookieからも取得可能）"
// @Security     BearerAuth
// @Success      200 {object} LogoutResponse "ログアウト成功"
// @Failure      400 {object} ErrorResponse "リクエストが無効"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /auth/logout [post]
func (c *AuthController) Logout(ctx *gin.Context) <span class="cov0" title="0">{
        // アクセストークンをヘッダーから取得
        authHeader := ctx.GetHeader("Authorization")
        accessToken := ""

        // ヘッダーからトークン取得
        if authHeader != "" </span><span class="cov0" title="0">{
                // Bearer トークンから抽出
                if strings.HasPrefix(authHeader, "Bearer ") </span><span class="cov0" title="0">{
                        accessToken = strings.TrimPrefix(authHeader, "Bearer ")
                }</span>
        } else<span class="cov0" title="0"> {
                // ヘッダーにない場合はCookieから取得
                var err error
                accessToken, err = ctx.Cookie("access_token")
                if err != nil </span><span class="cov0" title="0">{
                        // アクセストークンが見つからない場合でも処理を続行
                        c.logger.Warn("Access token not found in cookie", logger.Error(err))
                }</span>
        }

        // リフレッシュトークンをリクエストボディまたはCookieから取得
        <span class="cov0" title="0">var req LogoutRequest
        if err := ctx.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                // Cookieからリフレッシュトークンを取得
                refreshToken, err := ctx.Cookie("refresh_token")
                if err != nil </span><span class="cov0" title="0">{
                        ctx.JSON(http.StatusBadRequest, ErrorResponse{
                Success: false,
                Error:   "MISSING_REFRESH_TOKEN",
                Message: "Refresh token is required",
        })
                        return
                }</span>
                <span class="cov0" title="0">req.RefreshToken = refreshToken</span>
        }

        // ログアウト処理
        <span class="cov0" title="0">if err := c.Interactor.AuthRepository.Logout(ctx, accessToken, req.RefreshToken); err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, ErrorResponse{
                Success: false,
                Error:   "LOGOUT_FAILED",
                Message: "Failed to logout",
        })
                return
        }</span>

        // Cookieを削除
        <span class="cov0" title="0">ctx.SetCookie("access_token", "", -1, "/", "", true, true)
        ctx.SetCookie("refresh_token", "", -1, "/", "", true, true)

        ctx.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Logged out successfully",
        })</span>
}

// Me 現在のユーザー情報取得
// @Summary      現在のユーザー情報取得
// @Description  認証済みユーザーの詳細情報を取得します
// @Tags         auth
// @Accept       json
// @Produce      json
// @Security     BearerAuth
// @Success      200 {object} MeResponse "ユーザー情報取得成功"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /auth/me [get]
func (c *AuthController) Me(ctx *gin.Context) <span class="cov0" title="0">{
        // auth_middlewareで設定されたユーザーIDを取得
        userID, exists := ctx.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusUnauthorized, ErrorResponse{
                Success: false,
                Error:   "UNAUTHORIZED",
                Message: "User not authenticated",
        })
                return
        }</span>

        // ユーザー情報を返す
        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{
                "success": true,
                "data": gin.H{
                        "user_id":  userID,
                        "email":    ctx.GetString("email"),
                        "username": ctx.GetString("username"),
                        "role":     ctx.GetString("role"),
                },
        })</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package controller

import (
        "net/http"
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        userService "github.com/hryt430/Yotei+/internal/modules/auth/usecase/user"
        "github.com/hryt430/Yotei+/pkg/logger"
)

type UserController struct {
        UserService userService.UserService
        logger      logger.Logger
}

func NewUserController(userService userService.UserService, logger logger.Logger) *UserController <span class="cov0" title="0">{
        return &amp;UserController{
                UserService: userService,
                logger:      logger,
        }
}</span>

// UpdateUserRequest はユーザー更新のリクエスト構造体
type UpdateUserRequest struct {
        Username string `json:"username" binding:"omitempty,min=3,max=30"`
        Email    string `json:"email" binding:"omitempty,email"`
}

// UserResponse はAPIレスポンス用のユーザー情報
type UserResponse struct {
        ID       string `json:"id"`
        Username string `json:"username"`
        Email    string `json:"email"`
        Role     string `json:"role"`
}

// DetailedUserResponse は詳細なユーザー情報（本人または管理者用）
type DetailedUserResponse struct {
        ID            string `json:"id"`
        Username      string `json:"username"`
        Email         string `json:"email"`
        Role          string `json:"role"`
        EmailVerified bool   `json:"email_verified"`
        LastLogin     string `json:"last_login"`
        CreatedAt     string `json:"created_at"`
        UpdatedAt     string `json:"updated_at"`
}


// GetUsers はユーザー一覧を取得する（タスク割り当て用）
func (c *UserController) GetUsers(ctx *gin.Context) <span class="cov0" title="0">{
        // 検索クエリの取得
        search := strings.TrimSpace(ctx.Query("search"))

        users, err := c.UserService.GetUsers(ctx, search)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to get users", logger.Error(err))
                ctx.JSON(http.StatusInternalServerError, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: "Failed to get users",
        })
                return
        }</span>

        // 基本情報のみを返す（セキュリティ考慮）
        <span class="cov0" title="0">var userResponses []UserResponse
        for _, user := range users </span><span class="cov0" title="0">{
                userResponses = append(userResponses, UserResponse{
                        ID:       user.ID.String(),
                        Username: user.Username,
                        Email:    user.Email,
                        Role:     user.Role,
                })
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    userResponses,
        })</span>
}

// GetUser は特定のユーザー情報を取得する
func (c *UserController) GetUser(ctx *gin.Context) <span class="cov0" title="0">{
        userID := ctx.Param("id")
        if userID == "" </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: "User ID is required",
        })
                return
        }</span>

        // UUIDの検証
        <span class="cov0" title="0">parsedID, err := uuid.Parse(userID)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: "Invalid user ID format",
        })
                return
        }</span>

        // ユーザー取得
        <span class="cov0" title="0">user, err := c.UserService.FindUserByID(parsedID)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to get user", logger.Any("userID", userID), logger.Error(err))
                ctx.JSON(http.StatusNotFound, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: "User not found",
        })
                return
        }</span>

        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusNotFound, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: "User not found",
        })
                return
        }</span>

        // 現在のユーザー情報を取得
        <span class="cov0" title="0">currentUserID := ctx.GetString("user_id")
        currentUserRole := ctx.GetString("role")

        // 権限チェック：自分の情報または管理者は詳細情報を取得
        if userID == currentUserID || currentUserRole == "admin" </span><span class="cov0" title="0">{
                // 詳細情報を返す
                detailedResponse := DetailedUserResponse{
                        ID:            user.ID.String(),
                        Username:      user.Username,
                        Email:         user.Email,
                        Role:          user.Role,
                        EmailVerified: user.EmailVerified,
                        LastLogin:     user.LastLogin.Format("2006-01-02T15:04:05Z07:00"),
                        CreatedAt:     user.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
                        UpdatedAt:     user.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
                }

                ctx.JSON(http.StatusOK, gin.H{
                        "success": true,
                        "data":    detailedResponse,
                })
        }</span> else<span class="cov0" title="0"> {
                // 他人の情報は基本情報のみ
                basicResponse := UserResponse{
                        ID:       user.ID.String(),
                        Username: user.Username,
                        Email:    user.Email,
                        Role:     user.Role,
                }

                ctx.JSON(http.StatusOK, gin.H{
                        "success": true,
                        "data":    basicResponse,
                })
        }</span>
}

// UpdateUser はユーザー情報を更新する
func (c *UserController) UpdateUser(ctx *gin.Context) <span class="cov0" title="0">{
        userID := ctx.Param("id")
        if userID == "" </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: "User ID is required",
        })
                return
        }</span>

        // UUIDの検証
        <span class="cov0" title="0">parsedID, err := uuid.Parse(userID)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: "Invalid user ID format",
        })
                return
        }</span>

        // 現在のユーザー情報を取得
        <span class="cov0" title="0">currentUserID := ctx.GetString("user_id")
        currentUserRole := ctx.GetString("role")

        // 権限チェック：自分の情報のみ更新可能（管理者は例外）
        if userID != currentUserID &amp;&amp; currentUserRole != "admin" </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusForbidden, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: "Access denied: You can only update your own profile",
        })
                return
        }</span>

        // リクエストボディの解析
        <span class="cov0" title="0">var req UpdateUserRequest
        if err := ctx.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: err.Error(),
        })
                return
        }</span>

        // 少なくとも1つのフィールドが更新対象である必要がある
        <span class="cov0" title="0">if req.Username == "" &amp;&amp; req.Email == "" </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: "At least one field (username or email) must be provided",
        })
                return
        }</span>

        // 入力値のサニタイズ
        <span class="cov0" title="0">if req.Username != "" </span><span class="cov0" title="0">{
                req.Username = strings.TrimSpace(req.Username)
        }</span>
        <span class="cov0" title="0">if req.Email != "" </span><span class="cov0" title="0">{
                req.Email = strings.TrimSpace(req.Email)
        }</span>

        // ユーザー更新
        <span class="cov0" title="0">updatedUser, err := c.UserService.UpdateUserProfile(parsedID, req.Username, req.Email)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to update user", logger.Any("userID", userID), logger.Error(err))
                if strings.Contains(err.Error(), "email already exists") </span><span class="cov0" title="0">{
                        ctx.JSON(http.StatusConflict, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: "Email already exists",
        })
                        return
                }</span>
                <span class="cov0" title="0">if strings.Contains(err.Error(), "username already exists") </span><span class="cov0" title="0">{
                        ctx.JSON(http.StatusConflict, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: "Username already exists",
        })
                        return
                }</span>
                <span class="cov0" title="0">ctx.JSON(http.StatusInternalServerError, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: "Failed to update user",
        })
                return</span>
        }

        // 更新されたユーザー情報を返す
        <span class="cov0" title="0">response := DetailedUserResponse{
                ID:            updatedUser.ID.String(),
                Username:      updatedUser.Username,
                Email:         updatedUser.Email,
                Role:          updatedUser.Role,
                EmailVerified: updatedUser.EmailVerified,
                LastLogin:     updatedUser.LastLogin.Format("2006-01-02T15:04:05Z07:00"),
                CreatedAt:     updatedUser.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
                UpdatedAt:     updatedUser.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
        }

        ctx.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "User updated successfully",
                "data":    response,
        })</span>
}

// GetCurrentUser は現在のユーザー情報を取得する（互換性維持）
func (c *UserController) GetCurrentUser(ctx *gin.Context) <span class="cov0" title="0">{
        // auth_middlewareで設定されたユーザーIDを取得
        userIDStr, exists := ctx.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusUnauthorized, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: "User not authenticated",
        })
                return
        }</span>

        <span class="cov0" title="0">userID, err := uuid.Parse(userIDStr.(string))
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: "Invalid user ID",
        })
                return
        }</span>

        <span class="cov0" title="0">user, err := c.UserService.FindUserByID(userID)
        if err != nil || user == nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to get current user", logger.Any("userID", userID), logger.Error(err))
                ctx.JSON(http.StatusNotFound, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: "User not found",
        })
                return
        }</span>

        // 詳細情報を返す
        <span class="cov0" title="0">response := DetailedUserResponse{
                ID:            user.ID.String(),
                Username:      user.Username,
                Email:         user.Email,
                Role:          user.Role,
                EmailVerified: user.EmailVerified,
                LastLogin:     user.LastLogin.Format("2006-01-02T15:04:05Z07:00"),
                CreatedAt:     user.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
                UpdatedAt:     user.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
        }

        ctx.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    response,
        })</span>
}

// UpdateCurrentUser は現在のユーザー情報を更新する（互換性維持）
func (c *UserController) UpdateCurrentUser(ctx *gin.Context) <span class="cov0" title="0">{
        // auth_middlewareで設定されたユーザーIDを取得
        userIDStr, exists := ctx.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusUnauthorized, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: "User not authenticated",
        })
                return
        }</span>

        // パラメータを設定して既存のUpdateUserメソッドを呼び出し
        <span class="cov0" title="0">ctx.Params = append(ctx.Params, gin.Param{Key: "id", Value: userIDStr.(string)})
        c.UpdateUser(ctx)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package database

import (
        "database/sql"
        "time"

        "github.com/google/uuid"
        "github.com/hryt430/Yotei+/internal/modules/auth/domain"
)

// TokenStorage はデータベースを使用したトークンストレージの実装
type TokenStorage struct {
        SqlHandler
}

func (t *TokenStorage) SaveRefreshToken(token *domain.RefreshToken) error <span class="cov0" title="0">{
        query := `INSERT INTO ` + "`Yotei-Plus`" + `.refresh_tokens 
                (id, token, user_id, expires_at, issued_at, created_at, updated_at) 
                VALUES (?, ?, ?, ?, ?, ?, ?)`
        _, err := t.Execute(query,
                token.ID.String(),
                token.Token,
                token.UserID.String(),
                token.ExpiresAt,
                token.IssuedAt,
                token.CreatedAt,
                token.UpdatedAt,
        )
        return err
}</span>

func (t *TokenStorage) FindRefreshTokenByToken(token string) (*domain.RefreshToken, error) <span class="cov0" title="0">{
        query := `SELECT id, token, user_id, expires_at, issued_at, revoked_at, created_at, updated_at 
                FROM ` + "`Yotei-Plus`" + `.refresh_tokens 
                WHERE token = ? AND revoked_at IS NULL`

        row, err := t.Query(query, token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer row.Close()

        if !row.Next() </span><span class="cov0" title="0">{
                return nil, nil // トークンが見つからない
        }</span>

        <span class="cov0" title="0">var refreshToken domain.RefreshToken
        var revokedAt sql.NullTime
        var idStr, userIDStr string

        if err = row.Scan(
                &amp;idStr,
                &amp;refreshToken.Token,
                &amp;userIDStr,
                &amp;refreshToken.ExpiresAt,
                &amp;refreshToken.IssuedAt,
                &amp;revokedAt,
                &amp;refreshToken.CreatedAt,
                &amp;refreshToken.UpdatedAt,
        ); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        //　UUIDパース
        <span class="cov0" title="0">if parsedID, err := uuid.Parse(idStr); err == nil </span><span class="cov0" title="0">{
                refreshToken.ID = parsedID
        }</span> else<span class="cov0" title="0"> {
                return nil, err
        }</span>

        <span class="cov0" title="0">if parsedUserID, err := uuid.Parse(userIDStr); err == nil </span><span class="cov0" title="0">{
                refreshToken.UserID = parsedUserID
        }</span> else<span class="cov0" title="0"> {
                return nil, err
        }</span>

        <span class="cov0" title="0">if revokedAt.Valid </span><span class="cov0" title="0">{
                refreshToken.RevokedAt = &amp;revokedAt.Time
        }</span>

        <span class="cov0" title="0">return &amp;refreshToken, nil</span>
}

func (t *TokenStorage) RevokeRefreshToken(token string) error <span class="cov0" title="0">{
        query := `UPDATE ` + "`Yotei-Plus`" + `.refresh_tokens 
                SET revoked_at = NOW() 
                WHERE token = ?`
        _, err := t.Execute(query, token)
        return err
}</span>

func (r *TokenStorage) DeleteExpiredRefreshTokens() error <span class="cov0" title="0">{
        query := `DELETE FROM ` + "`Yotei-Plus`" + `.refresh_tokens 
                WHERE expires_at &lt; ?`
        _, err := r.Execute(query, time.Now())
        return err
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package database

import (
        "database/sql"
        "fmt"
        "strings"
        "time"

        "github.com/google/uuid"
        "github.com/hryt430/Yotei+/internal/modules/auth/domain"
)

type IUserRepository struct {
        SqlHandler
}

// UserExists はユーザーが存在するかチェック
func (r *IUserRepository) UserExists(userID string) (bool, error) <span class="cov0" title="0">{
        query := `SELECT 1 FROM ` + "`Yotei-Plus`" + `.users WHERE id = ? LIMIT 1`

        row, err := r.Query(query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to check user existence: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if closeErr := row.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        // ログ出力（実際の実装ではloggerを使用）
                        fmt.Printf("Warning: failed to close row: %v\n", closeErr)
                }</span>
        }()

        <span class="cov0" title="0">return row.Next(), nil</span>
}

// GetUserBasicInfo はユーザーの基本情報のみ取得
func (r *IUserRepository) GetUserBasicInfo(userID string) (*UserBasicInfo, error) <span class="cov0" title="0">{
        query := `SELECT id, username, email FROM ` + "`Yotei-Plus`" + `.users WHERE id = ? LIMIT 1`

        row, err := r.Query(query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user basic info: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if closeErr := row.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: failed to close row: %v\n", closeErr)
                }</span>
        }()

        <span class="cov0" title="0">if !row.Next() </span><span class="cov0" title="0">{
                return nil, nil // ユーザーが見つからない
        }</span>

        <span class="cov0" title="0">var info UserBasicInfo
        if err := row.Scan(&amp;info.ID, &amp;info.Username, &amp;info.Email); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to scan user basic info: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;info, nil</span>
}

// GetUsersBasicInfoBatch は複数ユーザーの基本情報を一括取得（N+1問題解決）
func (r *IUserRepository) GetUsersBasicInfoBatch(userIDs []string) (map[string]*UserBasicInfo, error) <span class="cov0" title="0">{
        if len(userIDs) == 0 </span><span class="cov0" title="0">{
                return make(map[string]*UserBasicInfo), nil
        }</span>

        // プレースホルダーを動的に生成
        <span class="cov0" title="0">placeholders := make([]string, len(userIDs))
        args := make([]interface{}, len(userIDs))
        for i, id := range userIDs </span><span class="cov0" title="0">{
                placeholders[i] = "?"
                args[i] = id
        }</span>

        <span class="cov0" title="0">query := `SELECT id, username, email FROM ` + "`Yotei-Plus`" + `.users 
                WHERE id IN (` + strings.Join(placeholders, ",") + `)`

        rows, err := r.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get users basic info batch: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if closeErr := rows.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: failed to close rows: %v\n", closeErr)
                }</span>
        }()

        <span class="cov0" title="0">result := make(map[string]*UserBasicInfo)
        for rows.Next() </span><span class="cov0" title="0">{
                var info UserBasicInfo
                if err := rows.Scan(&amp;info.ID, &amp;info.Username, &amp;info.Email); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan user basic info: %w", err)
                }</span>
                <span class="cov0" title="0">result[info.ID] = &amp;info</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

// UserBasicInfo はユーザーの基本情報
type UserBasicInfo struct {
        ID       string `json:"id"`
        Username string `json:"username"`
        Email    string `json:"email"`
}

// CreateUser は新しいユーザーを作成する（コネクション管理改善）
func (r *IUserRepository) CreateUser(user *domain.User) error <span class="cov0" title="0">{
        // Role のバリデーションとデフォルト値設定
        if user.Role == "" </span><span class="cov0" title="0">{
                user.Role = domain.RoleUser
        }</span>
        <span class="cov0" title="0">if user.Role != domain.RoleUser &amp;&amp; user.Role != domain.RoleAdmin </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid role: %s", user.Role)
        }</span>

        // 時刻フィールドのバリデーションと修正
        <span class="cov0" title="0">now := time.Now()
        if user.CreatedAt.IsZero() </span><span class="cov0" title="0">{
                user.CreatedAt = now
        }</span>
        <span class="cov0" title="0">if user.UpdatedAt.IsZero() </span><span class="cov0" title="0">{
                user.UpdatedAt = now
        }</span>

        <span class="cov0" title="0">query := `INSERT INTO ` + "`Yotei-Plus`" + `.users 
                (id, username, email, password, role, email_verified, last_login, created_at, updated_at) 
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`

        _, err := r.Execute(query,
                user.ID.String(),
                user.Username,
                user.Email,
                user.Password,
                user.Role,
                user.EmailVerified,
                user.LastLogin,
                user.CreatedAt,
                user.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create user: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// FindUserByEmail はメールアドレスでユーザーを検索する（コネクション管理改善）
func (r *IUserRepository) FindUserByEmail(email string) (*domain.User, error) <span class="cov0" title="0">{
        query := `SELECT id, username, email, password, role, email_verified, last_login, created_at, updated_at 
                FROM ` + "`Yotei-Plus`" + `.users 
                WHERE email = ? LIMIT 1`

        row, err := r.Query(query, email)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query user by email: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if closeErr := row.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: failed to close row: %v\n", closeErr)
                }</span>
        }()

        <span class="cov0" title="0">if !row.Next() </span><span class="cov0" title="0">{
                return nil, nil // ユーザーが見つからない
        }</span>

        <span class="cov0" title="0">return r.scanUser(row)</span>
}

// FindUserByID はIDでユーザーを検索する（コネクション管理改善）
func (r *IUserRepository) FindUserByID(id uuid.UUID) (*domain.User, error) <span class="cov0" title="0">{
        query := `SELECT id, username, email, password, role, email_verified, last_login, created_at, updated_at 
                FROM ` + "`Yotei-Plus`" + `.users 
                WHERE id = ? LIMIT 1`

        row, err := r.Query(query, id.String())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query user by ID: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if closeErr := row.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: failed to close row: %v\n", closeErr)
                }</span>
        }()

        <span class="cov0" title="0">if !row.Next() </span><span class="cov0" title="0">{
                return nil, nil // ユーザーが見つからない
        }</span>

        <span class="cov0" title="0">return r.scanUser(row)</span>
}

// FindUserByUsername はユーザー名による検索（コネクション管理改善）
func (r *IUserRepository) FindUserByUsername(username string) (*domain.User, error) <span class="cov0" title="0">{
        query := `SELECT id, username, email, password, role, email_verified, last_login, created_at, updated_at 
                FROM ` + "`Yotei-Plus`" + `.users 
                WHERE username = ? LIMIT 1`

        row, err := r.Query(query, username)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query user by username: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if closeErr := row.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: failed to close row: %v\n", closeErr)
                }</span>
        }()

        <span class="cov0" title="0">if !row.Next() </span><span class="cov0" title="0">{
                return nil, nil // ユーザーが見つからない
        }</span>

        <span class="cov0" title="0">return r.scanUser(row)</span>
}

// FindUsers はユーザー一覧取得（検索機能付き、コネクション管理改善）
func (r *IUserRepository) FindUsers(search string) ([]*domain.User, error) <span class="cov0" title="0">{
        var query string
        var args []interface{}

        if search != "" </span><span class="cov0" title="0">{
                search = strings.TrimSpace(search)
                searchPattern := "%" + search + "%"
                query = `SELECT id, username, email, password, role, email_verified, last_login, created_at, updated_at 
                        FROM ` + "`Yotei-Plus`" + `.users 
                        WHERE username LIKE ? OR email LIKE ? 
                        ORDER BY username ASC 
                        LIMIT 100`
                args = []interface{}{searchPattern, searchPattern}
        }</span> else<span class="cov0" title="0"> {
                query = `SELECT id, username, email, password, role, email_verified, last_login, created_at, updated_at 
                        FROM ` + "`Yotei-Plus`" + `.users 
                        ORDER BY username ASC 
                        LIMIT 100`
                args = []interface{}{}
        }</span>

        <span class="cov0" title="0">rows, err := r.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query users: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if closeErr := rows.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: failed to close rows: %v\n", closeErr)
                }</span>
        }()

        <span class="cov0" title="0">var users []*domain.User
        for rows.Next() </span><span class="cov0" title="0">{
                user, err := r.scanUser(rows)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan user: %w", err)
                }</span>
                <span class="cov0" title="0">users = append(users, user)</span>
        }

        <span class="cov0" title="0">return users, nil</span>
}

// UpdateUser はユーザーを更新する（コネクション管理改善）
func (r *IUserRepository) UpdateUser(user *domain.User) error <span class="cov0" title="0">{
        // Role のバリデーション
        if user.Role != domain.RoleUser &amp;&amp; user.Role != domain.RoleAdmin </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid role: %s", user.Role)
        }</span>

        // UpdatedAt を現在時刻に設定
        <span class="cov0" title="0">user.UpdatedAt = time.Now()

        query := `UPDATE ` + "`Yotei-Plus`" + `.users 
                SET username = ?, email = ?, password = ?, role = ?, email_verified = ?, last_login = ?, updated_at = ? 
                WHERE id = ?`

        result, err := r.Execute(query,
                user.Username,
                user.Email,
                user.Password,
                user.Role,
                user.EmailVerified,
                user.LastLogin,
                user.UpdatedAt,
                user.ID.String(),
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update user: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("user not found: %s", user.ID.String())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// scanUser は共通のスキャン処理（重複コード削減）
func (r *IUserRepository) scanUser(row Row) (*domain.User, error) <span class="cov0" title="0">{
        var user domain.User
        var idStr string
        var lastLogin sql.NullTime

        if err := row.Scan(
                &amp;idStr,
                &amp;user.Username,
                &amp;user.Email,
                &amp;user.Password,
                &amp;user.Role,
                &amp;user.EmailVerified,
                &amp;lastLogin,
                &amp;user.CreatedAt,
                &amp;user.UpdatedAt,
        ); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to scan user fields: %w", err)
        }</span>

        // UUIDパース
        <span class="cov0" title="0">parsedID, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse user ID: %w", err)
        }</span>
        <span class="cov0" title="0">user.ID = parsedID

        // last_loginのNULL処理
        if lastLogin.Valid </span><span class="cov0" title="0">{
                user.LastLogin = &amp;lastLogin.Time
        }</span>

        <span class="cov0" title="0">return &amp;user, nil</span>
}

// UserValidator の実装
type UserValidator struct {
        userRepo *IUserRepository
}

func NewUserValidator(userRepo *IUserRepository) *UserValidator <span class="cov0" title="0">{
        return &amp;UserValidator{userRepo: userRepo}
}</span>

func (v *UserValidator) UserExists(userID string) (bool, error) <span class="cov0" title="0">{
        return v.userRepo.UserExists(userID)
}</span>

func (v *UserValidator) GetUserBasicInfo(userID string) (*UserBasicInfo, error) <span class="cov0" title="0">{
        return v.userRepo.GetUserBasicInfo(userID)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package redis

import (
        "time"

        "github.com/hryt430/Yotei+/internal/modules/auth/domain"
        "github.com/hryt430/Yotei+/internal/modules/auth/infrastructure/redis"
        "github.com/hryt430/Yotei+/internal/modules/auth/interface/database"
        tokenService "github.com/hryt430/Yotei+/internal/modules/auth/usecase/token"
)

// TokenRepositoryAdapter はinfrastructure層の実装をusecase層のインターフェースに適合させる
type TokenRepositoryAdapter struct {
        tokenCache   *redis.RedisTokenCache
        tokenStorage *database.TokenStorage
}

func NewTokenRepositoryAdapter(
        tokenCache *redis.RedisTokenCache,
        tokenStorage *database.TokenStorage,
) tokenService.ITokenRepository <span class="cov0" title="0">{
        return &amp;TokenRepositoryAdapter{
                tokenCache:   tokenCache,
                tokenStorage: tokenStorage,
        }
}</span>

// ブラックリスト関連（Redis使用）
func (r *TokenRepositoryAdapter) SaveTokenToBlacklist(token string, ttl time.Duration) error <span class="cov0" title="0">{
        key := "blacklist:" + token
        return r.tokenCache.SetWithTTL(key, "1", ttl)
}</span>

func (r *TokenRepositoryAdapter) IsTokenBlacklisted(token string) bool <span class="cov0" title="0">{
        key := "blacklist:" + token
        return r.tokenCache.Exists(key)
}</span>

// リフレッシュトークン関連（DB使用）
func (r *TokenRepositoryAdapter) SaveRefreshToken(token *domain.RefreshToken) error <span class="cov0" title="0">{
        return r.tokenStorage.SaveRefreshToken(token)
}</span>

func (r *TokenRepositoryAdapter) FindRefreshToken(token string) (*domain.RefreshToken, error) <span class="cov0" title="0">{
        return r.tokenStorage.FindRefreshTokenByToken(token)
}</span>

func (r *TokenRepositoryAdapter) RevokeRefreshToken(token string) error <span class="cov0" title="0">{
        return r.tokenStorage.RevokeRefreshToken(token)
}</span>

func (r *TokenRepositoryAdapter) DeleteExpiredRefreshTokens() error <span class="cov0" title="0">{
        // 実装は要件に応じて
        return r.tokenStorage.DeleteExpiredRefreshTokens()
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package authService

import (
        "errors"
        "time"

        "github.com/hryt430/Yotei+/internal/modules/auth/domain"

        tokenService "github.com/hryt430/Yotei+/internal/modules/auth/usecase/token"
        userService "github.com/hryt430/Yotei+/internal/modules/auth/usecase/user"

        "github.com/hryt430/Yotei+/pkg/utils"

        "github.com/google/uuid"
)

type AuthService struct {
        AuthRepository IAuthRepository
        UserService    userService.UserService
        TokenService   tokenService.TokenService
}

func NewAuthService(authRepository IAuthRepository, userService userService.UserService, tokenService tokenService.TokenService) *AuthService <span class="cov8" title="1">{
        return &amp;AuthService{AuthRepository: authRepository, UserService: userService, TokenService: tokenService}
}</span>

func (a *AuthService) Register(email, username, password string) (*domain.User, error) <span class="cov8" title="1">{
        // メールアドレスの重複チェック
        existingUser, err := a.UserService.FindUserByEmail(email)
        if err == nil &amp;&amp; existingUser != nil </span><span class="cov8" title="1">{
                return nil, errors.New("email already exists")
        }</span>

        <span class="cov8" title="1">user := &amp;domain.User{
                ID:        uuid.New(),
                Email:     email,
                Username:  username,
                Password:  password, // UserService.CreateUserでハッシュ化されるので、ここではプレーンテキストを渡す
                Role:      "user",
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
        }

        newUser, err := a.UserService.CreateUser(user)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return newUser, nil</span>
}

func (a *AuthService) Login(email, password string) (string, string, error) <span class="cov8" title="1">{
        user, err := a.UserService.FindUserByEmail(email)
        if err != nil </span><span class="cov8" title="1">{
                return "", "", err
        }</span>

        <span class="cov8" title="1">if user == nil </span><span class="cov8" title="1">{
                return "", "", errors.New("invalid email or password")
        }</span>

        // パスワード検証
        <span class="cov8" title="1">if !utils.CheckPasswordHash(password, user.Password) </span><span class="cov8" title="1">{
                return "", "", errors.New("invalid email or password")
        }</span>

        // 最終ログイン時間を更新
        <span class="cov8" title="1">if err := a.UserService.UpdateLastLogin(user.ID); err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        // アクセストークン生成
        <span class="cov8" title="1">accessToken, err := a.TokenService.GenerateAccessToken(user)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        // リフレッシュトークン生成
        <span class="cov8" title="1">refreshTokenString, err := a.TokenService.GenerateRefreshToken(user)
        if err != nil </span><span class="cov8" title="1">{
                return "", "", err
        }</span>

        <span class="cov8" title="1">return accessToken, refreshTokenString, nil</span>
}

func (a *AuthService) RefreshToken(refreshTokenStr string) (string, string, error) <span class="cov8" title="1">{
        // リフレッシュトークンの検証
        refreshTokenEntity, err := a.TokenService.TokenRepository.FindRefreshToken(refreshTokenStr)
        if err != nil </span><span class="cov8" title="1">{
                return "", "", err
        }</span>

        <span class="cov8" title="1">if refreshTokenEntity == nil || refreshTokenEntity.RevokedAt != nil </span><span class="cov8" title="1">{
                return "", "", errors.New("invalid refresh token")
        }</span>

        // 有効期限切れ確認
        <span class="cov8" title="1">if time.Now().After(refreshTokenEntity.ExpiresAt) </span><span class="cov8" title="1">{
                return "", "", errors.New("refresh token expired")
        }</span>

        // ユーザー取得
        <span class="cov8" title="1">user, err := a.UserService.FindUserByID(refreshTokenEntity.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        // 新しいアクセストークン生成
        <span class="cov8" title="1">newAccessToken, err := a.TokenService.GenerateAccessToken(user)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        // 古いリフレッシュトークンを無効化
        <span class="cov8" title="1">if err := a.TokenService.RevokeToken(refreshTokenStr); err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        // 新しいリフレッシュトークン生成
        <span class="cov8" title="1">newRefreshToken, err := a.TokenService.GenerateRefreshToken(user)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov8" title="1">return newAccessToken, newRefreshToken, nil</span>
}

func (a *AuthService) Logout(accessToken, refreshToken string) error <span class="cov8" title="1">{
        // アクセストークンをブラックリストに追加
        if err := a.TokenService.RevokeAccessToken(accessToken); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // リフレッシュトークンを無効化
        <span class="cov8" title="1">if err := a.TokenService.RevokeToken(refreshToken); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: token/repository.go

// Package mock_tokenService is a generated GoMock package.
package mock_Service

import (
        reflect "reflect"
        time "time"

        gomock "github.com/golang/mock/gomock"
        domain "github.com/hryt430/Yotei+/internal/modules/auth/domain"
)

// MockITokenRepository is a mock of ITokenRepository interface.
type MockITokenRepository struct {
        ctrl     *gomock.Controller
        recorder *MockITokenRepositoryMockRecorder
}

// MockITokenRepositoryMockRecorder is the mock recorder for MockITokenRepository.
type MockITokenRepositoryMockRecorder struct {
        mock *MockITokenRepository
}

// NewMockITokenRepository creates a new mock instance.
func NewMockITokenRepository(ctrl *gomock.Controller) *MockITokenRepository <span class="cov0" title="0">{
        mock := &amp;MockITokenRepository{ctrl: ctrl}
        mock.recorder = &amp;MockITokenRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockITokenRepository) EXPECT() *MockITokenRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// DeleteExpiredRefreshTokens mocks base method.
func (m *MockITokenRepository) DeleteExpiredRefreshTokens() error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteExpiredRefreshTokens")
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteExpiredRefreshTokens indicates an expected call of DeleteExpiredRefreshTokens.
func (mr *MockITokenRepositoryMockRecorder) DeleteExpiredRefreshTokens() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteExpiredRefreshTokens", reflect.TypeOf((*MockITokenRepository)(nil).DeleteExpiredRefreshTokens))
}</span>

// FindRefreshToken mocks base method.
func (m *MockITokenRepository) FindRefreshToken(token string) (*domain.RefreshToken, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindRefreshToken", token)
        ret0, _ := ret[0].(*domain.RefreshToken)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindRefreshToken indicates an expected call of FindRefreshToken.
func (mr *MockITokenRepositoryMockRecorder) FindRefreshToken(token interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindRefreshToken", reflect.TypeOf((*MockITokenRepository)(nil).FindRefreshToken), token)
}</span>

// IsTokenBlacklisted mocks base method.
func (m *MockITokenRepository) IsTokenBlacklisted(token string) bool <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "IsTokenBlacklisted", token)
        ret0, _ := ret[0].(bool)
        return ret0
}</span>

// IsTokenBlacklisted indicates an expected call of IsTokenBlacklisted.
func (mr *MockITokenRepositoryMockRecorder) IsTokenBlacklisted(token interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsTokenBlacklisted", reflect.TypeOf((*MockITokenRepository)(nil).IsTokenBlacklisted), token)
}</span>

// RevokeRefreshToken mocks base method.
func (m *MockITokenRepository) RevokeRefreshToken(token string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RevokeRefreshToken", token)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// RevokeRefreshToken indicates an expected call of RevokeRefreshToken.
func (mr *MockITokenRepositoryMockRecorder) RevokeRefreshToken(token interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RevokeRefreshToken", reflect.TypeOf((*MockITokenRepository)(nil).RevokeRefreshToken), token)
}</span>

// SaveRefreshToken mocks base method.
func (m *MockITokenRepository) SaveRefreshToken(token *domain.RefreshToken) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SaveRefreshToken", token)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// SaveRefreshToken indicates an expected call of SaveRefreshToken.
func (mr *MockITokenRepositoryMockRecorder) SaveRefreshToken(token interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveRefreshToken", reflect.TypeOf((*MockITokenRepository)(nil).SaveRefreshToken), token)
}</span>

// SaveTokenToBlacklist mocks base method.
func (m *MockITokenRepository) SaveTokenToBlacklist(token string, ttl time.Duration) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SaveTokenToBlacklist", token, ttl)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// SaveTokenToBlacklist indicates an expected call of SaveTokenToBlacklist.
func (mr *MockITokenRepositoryMockRecorder) SaveTokenToBlacklist(token, ttl interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveTokenToBlacklist", reflect.TypeOf((*MockITokenRepository)(nil).SaveTokenToBlacklist), token, ttl)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: user/repository.go

// Package mock_userService is a generated GoMock package.
package mock_Service

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        uuid "github.com/google/uuid"
        domain "github.com/hryt430/Yotei+/internal/modules/auth/domain"
)

// MockIUserRepository is a mock of IUserRepository interface.
type MockIUserRepository struct {
        ctrl     *gomock.Controller
        recorder *MockIUserRepositoryMockRecorder
}

// MockIUserRepositoryMockRecorder is the mock recorder for MockIUserRepository.
type MockIUserRepositoryMockRecorder struct {
        mock *MockIUserRepository
}

// NewMockIUserRepository creates a new mock instance.
func NewMockIUserRepository(ctrl *gomock.Controller) *MockIUserRepository <span class="cov0" title="0">{
        mock := &amp;MockIUserRepository{ctrl: ctrl}
        mock.recorder = &amp;MockIUserRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIUserRepository) EXPECT() *MockIUserRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateUser mocks base method.
func (m *MockIUserRepository) CreateUser(user *domain.User) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateUser", user)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CreateUser indicates an expected call of CreateUser.
func (mr *MockIUserRepositoryMockRecorder) CreateUser(user interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateUser", reflect.TypeOf((*MockIUserRepository)(nil).CreateUser), user)
}</span>

// FindUserByEmail mocks base method.
func (m *MockIUserRepository) FindUserByEmail(email string) (*domain.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindUserByEmail", email)
        ret0, _ := ret[0].(*domain.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindUserByEmail indicates an expected call of FindUserByEmail.
func (mr *MockIUserRepositoryMockRecorder) FindUserByEmail(email interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindUserByEmail", reflect.TypeOf((*MockIUserRepository)(nil).FindUserByEmail), email)
}</span>

// FindUserByID mocks base method.
func (m *MockIUserRepository) FindUserByID(id uuid.UUID) (*domain.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindUserByID", id)
        ret0, _ := ret[0].(*domain.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindUserByID indicates an expected call of FindUserByID.
func (mr *MockIUserRepositoryMockRecorder) FindUserByID(id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindUserByID", reflect.TypeOf((*MockIUserRepository)(nil).FindUserByID), id)
}</span>

// FindUsers mocks base method.
func (m *MockIUserRepository) FindUsers(search string) ([]*domain.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindUsers", search)
        ret0, _ := ret[0].([]*domain.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindUsers indicates an expected call of FindUsers.
func (mr *MockIUserRepositoryMockRecorder) FindUsers(search interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindUsers", reflect.TypeOf((*MockIUserRepository)(nil).FindUsers), search)
}</span>

// UpdateUser mocks base method.
func (m *MockIUserRepository) UpdateUser(user *domain.User) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateUser", user)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateUser indicates an expected call of UpdateUser.
func (mr *MockIUserRepositoryMockRecorder) UpdateUser(user interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateUser", reflect.TypeOf((*MockIUserRepository)(nil).UpdateUser), user)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package tokenService

import (
        "errors"
        "time"

        "github.com/google/uuid"
        "github.com/hryt430/Yotei+/internal/modules/auth/domain"
        "github.com/hryt430/Yotei+/pkg/token"
)

type TokenService struct {
        TokenRepository      ITokenRepository
        jwtManager           *token.JWTManager
        tokenDuration        time.Duration
        refreshTokenDuration time.Duration
}

func NewTokenService(
        tokenRepository ITokenRepository,
        jwtManager *token.JWTManager,
        tokenDuration time.Duration,
        refreshTokenDuration time.Duration,
) *TokenService <span class="cov8" title="1">{
        return &amp;TokenService{
                TokenRepository:      tokenRepository,
                jwtManager:           jwtManager,
                tokenDuration:        tokenDuration,
                refreshTokenDuration: refreshTokenDuration,
        }
}</span>

func (t *TokenService) RevokeAccessToken(tokenString string) error <span class="cov8" title="1">{
        // トークンをブラックリストに追加
        claims, err := t.jwtManager.ExtractWithoutValidation(tokenString)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // 有効期限を計算
        <span class="cov8" title="1">expirationTime := time.Unix(claims.ExpiresAt.Time.Unix(), 0)
        ttl := time.Until(expirationTime)
        if ttl &lt; 0 </span><span class="cov0" title="0">{
                ttl = 0
        }</span>

        // リポジトリを使用してブラックリストに保存
        <span class="cov8" title="1">return t.TokenRepository.SaveTokenToBlacklist(tokenString, ttl)</span>
}

func (t *TokenService) GenerateAccessToken(user *domain.User) (string, error) <span class="cov8" title="1">{
        // JWTトークン生成
        claims := &amp;token.Claims{
                UserID:   user.ID.String(),
                Email:    user.Email,
                Username: user.Username,
                Role:     user.Role,
        }

        return t.jwtManager.Generate(claims, t.tokenDuration)
}</span>

func (t *TokenService) GenerateRefreshToken(user *domain.User) (string, error) <span class="cov8" title="1">{
        // ランダムなリフレッシュトークン生成
        refreshTokenStr, err := t.jwtManager.GenerateRefreshToken()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // DBにリフレッシュトークンを保存
        <span class="cov8" title="1">refreshToken := &amp;domain.RefreshToken{
                ID:        uuid.New(),
                Token:     refreshTokenStr,
                UserID:    user.ID,
                ExpiresAt: time.Now().Add(t.refreshTokenDuration),
                IssuedAt:  time.Now(),
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
        }

        if err := t.TokenRepository.SaveRefreshToken(refreshToken); err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return refreshTokenStr, nil</span>
}

func (t *TokenService) ValidateAccessToken(tokenString string) (*token.Claims, error) <span class="cov8" title="1">{
        // トークンがブラックリストにないか確認
        if t.TokenRepository.IsTokenBlacklisted(tokenString) </span><span class="cov8" title="1">{
                return nil, token.ErrTokenBlacklisted
        }</span>

        // トークン検証
        <span class="cov8" title="1">return t.jwtManager.Verify(tokenString)</span>
}

// ValidateRefreshToken はリフレッシュトークンを検証する
func (u *TokenService) ValidateRefreshToken(token string) (*domain.RefreshToken, error) <span class="cov8" title="1">{
        refreshToken, err := u.TokenRepository.FindRefreshToken(token)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if refreshToken == nil </span><span class="cov8" title="1">{
                return nil, errors.New("refresh token not found")
        }</span>

        // トークンが取り消されていないか確認
        <span class="cov8" title="1">if refreshToken.RevokedAt != nil </span><span class="cov8" title="1">{
                return nil, errors.New("refresh token has been revoked")
        }</span>

        // 有効期限の確認
        <span class="cov8" title="1">if time.Now().After(refreshToken.ExpiresAt) </span><span class="cov8" title="1">{
                return nil, errors.New("refresh token has expired")
        }</span>

        <span class="cov8" title="1">return refreshToken, nil</span>
}

// GenerateNewRefreshToken は新しいリフレッシュトークンを生成する
func (u *TokenService) GenerateNewRefreshToken(userID uuid.UUID) (*domain.RefreshToken, error) <span class="cov8" title="1">{
        // トークン文字列の生成（実際の実装では安全な方法で）
        tokenString := uuid.New().String()

        // 有効期限の設定（例: 7日間）
        expiresAt := time.Now().Add(7 * 24 * time.Hour)

        // リフレッシュトークンの作成
        refreshToken := &amp;domain.RefreshToken{
                ID:        uuid.New(),
                Token:     tokenString,
                UserID:    userID,
                ExpiresAt: expiresAt,
                IssuedAt:  time.Now(),
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
        }

        // リフレッシュトークンの保存
        if err := u.TokenRepository.SaveRefreshToken(refreshToken); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return refreshToken, nil</span>
}

// RevokeToken はトークンを無効化する
func (u *TokenService) RevokeToken(token string) error <span class="cov8" title="1">{
        return u.TokenRepository.RevokeRefreshToken(token)
}</span>

// CleanupExpiredTokens は期限切れのトークンをクリーンアップする
func (u *TokenService) CleanupExpiredTokens() error <span class="cov8" title="1">{
        return u.TokenRepository.DeleteExpiredRefreshTokens()
}</span>
func (t *TokenService) IsTokenRevoked(tokenString string) bool <span class="cov8" title="1">{
        return t.TokenRepository.IsTokenBlacklisted(tokenString)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: repository.go

// Package mocks is a generated GoMock package.
package mocks

import (
        reflect "reflect"
        time "time"

        gomock "github.com/golang/mock/gomock"
        domain "github.com/hryt430/Yotei+/internal/modules/auth/domain"
)

// MockITokenRepository is a mock of ITokenRepository interface.
type MockITokenRepository struct {
        ctrl     *gomock.Controller
        recorder *MockITokenRepositoryMockRecorder
}

// MockITokenRepositoryMockRecorder is the mock recorder for MockITokenRepository.
type MockITokenRepositoryMockRecorder struct {
        mock *MockITokenRepository
}

// NewMockITokenRepository creates a new mock instance.
func NewMockITokenRepository(ctrl *gomock.Controller) *MockITokenRepository <span class="cov0" title="0">{
        mock := &amp;MockITokenRepository{ctrl: ctrl}
        mock.recorder = &amp;MockITokenRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockITokenRepository) EXPECT() *MockITokenRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// DeleteExpiredRefreshTokens mocks base method.
func (m *MockITokenRepository) DeleteExpiredRefreshTokens() error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteExpiredRefreshTokens")
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteExpiredRefreshTokens indicates an expected call of DeleteExpiredRefreshTokens.
func (mr *MockITokenRepositoryMockRecorder) DeleteExpiredRefreshTokens() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteExpiredRefreshTokens", reflect.TypeOf((*MockITokenRepository)(nil).DeleteExpiredRefreshTokens))
}</span>

// FindRefreshToken mocks base method.
func (m *MockITokenRepository) FindRefreshToken(token string) (*domain.RefreshToken, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindRefreshToken", token)
        ret0, _ := ret[0].(*domain.RefreshToken)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindRefreshToken indicates an expected call of FindRefreshToken.
func (mr *MockITokenRepositoryMockRecorder) FindRefreshToken(token interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindRefreshToken", reflect.TypeOf((*MockITokenRepository)(nil).FindRefreshToken), token)
}</span>

// IsTokenBlacklisted mocks base method.
func (m *MockITokenRepository) IsTokenBlacklisted(token string) bool <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "IsTokenBlacklisted", token)
        ret0, _ := ret[0].(bool)
        return ret0
}</span>

// IsTokenBlacklisted indicates an expected call of IsTokenBlacklisted.
func (mr *MockITokenRepositoryMockRecorder) IsTokenBlacklisted(token interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsTokenBlacklisted", reflect.TypeOf((*MockITokenRepository)(nil).IsTokenBlacklisted), token)
}</span>

// RevokeRefreshToken mocks base method.
func (m *MockITokenRepository) RevokeRefreshToken(token string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RevokeRefreshToken", token)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// RevokeRefreshToken indicates an expected call of RevokeRefreshToken.
func (mr *MockITokenRepositoryMockRecorder) RevokeRefreshToken(token interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RevokeRefreshToken", reflect.TypeOf((*MockITokenRepository)(nil).RevokeRefreshToken), token)
}</span>

// SaveRefreshToken mocks base method.
func (m *MockITokenRepository) SaveRefreshToken(token *domain.RefreshToken) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SaveRefreshToken", token)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// SaveRefreshToken indicates an expected call of SaveRefreshToken.
func (mr *MockITokenRepositoryMockRecorder) SaveRefreshToken(token interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveRefreshToken", reflect.TypeOf((*MockITokenRepository)(nil).SaveRefreshToken), token)
}</span>

// SaveTokenToBlacklist mocks base method.
func (m *MockITokenRepository) SaveTokenToBlacklist(token string, ttl time.Duration) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SaveTokenToBlacklist", token, ttl)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// SaveTokenToBlacklist indicates an expected call of SaveTokenToBlacklist.
func (mr *MockITokenRepositoryMockRecorder) SaveTokenToBlacklist(token, ttl interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveTokenToBlacklist", reflect.TypeOf((*MockITokenRepository)(nil).SaveTokenToBlacklist), token, ttl)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package userService

import (
        "errors"
        "time"

        "github.com/hryt430/Yotei+/internal/modules/auth/domain"
        "github.com/hryt430/Yotei+/pkg/utils"

        "context"

        "github.com/google/uuid"
)

// userUseCase はユーザー関連のユースケースを実装する構造体
type UserService struct {
        UserRepository IUserRepository
}

// NewUserUseCase は新しいUserUseCaseインスタンスを生成する
func NewUserService(userRepo IUserRepository) *UserService <span class="cov8" title="1">{
        return &amp;UserService{
                UserRepository: userRepo,
        }
}</span>

// CreateUser は新しいユーザーを作成する
func (u *UserService) CreateUser(user *domain.User) (*domain.User, error) <span class="cov8" title="1">{
        // メールアドレスの重複チェック
        existingUser, err := u.UserRepository.FindUserByEmail(user.Email)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if existingUser != nil </span><span class="cov8" title="1">{
                return nil, errors.New("email already exists")
        }</span>

        // パスワードのハッシュ化
        <span class="cov8" title="1">hashedPassword, err := utils.HashPassword(user.Password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">user.Password = hashedPassword

        // ユーザーの保存
        if err := u.UserRepository.CreateUser(user); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return user, nil</span>
}

// GetUsers はユーザー一覧を取得する（検索機能付き）
func (u *UserService) GetUsers(ctx context.Context, search string) ([]*domain.User, error) <span class="cov8" title="1">{
        return u.UserRepository.FindUsers(search)
}</span>

// GetUserByEmail はメールアドレスでユーザーを検索する
func (u *UserService) FindUserByEmail(email string) (*domain.User, error) <span class="cov8" title="1">{
        user, err := u.UserRepository.FindUserByEmail(email)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return user, nil</span>
}

// GetUserByID はIDでユーザーを検索する
func (u *UserService) FindUserByID(id uuid.UUID) (*domain.User, error) <span class="cov8" title="1">{
        user, err := u.UserRepository.FindUserByID(id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return user, nil</span>
}

// UpdateUserProfile はユーザープロフィールを更新する
func (u *UserService) UpdateUserProfile(id uuid.UUID, username, email string) (*domain.User, error) <span class="cov8" title="1">{
        user, err := u.UserRepository.FindUserByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if user == nil </span><span class="cov8" title="1">{
                return nil, errors.New("user not found")
        }</span>

        // 更新するフィールドをチェック
        <span class="cov8" title="1">updated := false

        // メールアドレスの更新
        if email != "" &amp;&amp; email != user.Email </span><span class="cov8" title="1">{
                // メールアドレスの重複チェック
                existingUser, err := u.UserRepository.FindUserByEmail(email)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if existingUser != nil &amp;&amp; existingUser.ID != id </span><span class="cov8" title="1">{
                        return nil, errors.New("email already exists")
                }</span>
                <span class="cov8" title="1">user.Email = email
                // メールアドレス変更時は認証フラグをリセット
                user.EmailVerified = false
                updated = true</span>
        }

        // 更新がある場合のみデータベースを更新
        <span class="cov8" title="1">if updated </span><span class="cov8" title="1">{
                user.UpdatedAt = time.Now()
                if err := u.UserRepository.UpdateUser(user); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">return user, nil</span>
}

// ChangePassword はユーザーのパスワードを変更する
func (u *UserService) ChangePassword(id uuid.UUID, oldPassword, newPassword string) error <span class="cov8" title="1">{
        user, err := u.UserRepository.FindUserByID(id)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if user == nil </span><span class="cov8" title="1">{
                return errors.New("user not found")
        }</span>

        // 古いパスワードの検証
        <span class="cov8" title="1">if !utils.CheckPasswordHash(oldPassword, user.Password) </span><span class="cov0" title="0">{
                return errors.New("incorrect password")
        }</span>

        // 新しいパスワードのハッシュ化
        <span class="cov8" title="1">hashedPassword, err := utils.HashPassword(newPassword)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">user.Password = hashedPassword
        user.UpdatedAt = time.Now()

        return u.UserRepository.UpdateUser(user)</span>
}

// UpdateLastLogin はユーザーの最終ログイン時間を更新する
func (u *UserService) UpdateLastLogin(id uuid.UUID) error <span class="cov8" title="1">{
        user, err := u.UserRepository.FindUserByID(id)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if user == nil </span><span class="cov8" title="1">{
                return errors.New("user not found")
        }</span>

        <span class="cov8" title="1">now := time.Now()
        user.LastLogin = &amp;now

        return u.UserRepository.UpdateUser(user)</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: repository.go

// Package mocks is a generated GoMock package.
package mocks

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        uuid "github.com/google/uuid"
        domain "github.com/hryt430/Yotei+/internal/modules/auth/domain"
)

// MockIUserRepository is a mock of IUserRepository interface.
type MockIUserRepository struct {
        ctrl     *gomock.Controller
        recorder *MockIUserRepositoryMockRecorder
}

// MockIUserRepositoryMockRecorder is the mock recorder for MockIUserRepository.
type MockIUserRepositoryMockRecorder struct {
        mock *MockIUserRepository
}

// NewMockIUserRepository creates a new mock instance.
func NewMockIUserRepository(ctrl *gomock.Controller) *MockIUserRepository <span class="cov0" title="0">{
        mock := &amp;MockIUserRepository{ctrl: ctrl}
        mock.recorder = &amp;MockIUserRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIUserRepository) EXPECT() *MockIUserRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateUser mocks base method.
func (m *MockIUserRepository) CreateUser(user *domain.User) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateUser", user)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CreateUser indicates an expected call of CreateUser.
func (mr *MockIUserRepositoryMockRecorder) CreateUser(user interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateUser", reflect.TypeOf((*MockIUserRepository)(nil).CreateUser), user)
}</span>

// FindUserByEmail mocks base method.
func (m *MockIUserRepository) FindUserByEmail(email string) (*domain.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindUserByEmail", email)
        ret0, _ := ret[0].(*domain.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindUserByEmail indicates an expected call of FindUserByEmail.
func (mr *MockIUserRepositoryMockRecorder) FindUserByEmail(email interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindUserByEmail", reflect.TypeOf((*MockIUserRepository)(nil).FindUserByEmail), email)
}</span>

// FindUserByID mocks base method.
func (m *MockIUserRepository) FindUserByID(id uuid.UUID) (*domain.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindUserByID", id)
        ret0, _ := ret[0].(*domain.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindUserByID indicates an expected call of FindUserByID.
func (mr *MockIUserRepositoryMockRecorder) FindUserByID(id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindUserByID", reflect.TypeOf((*MockIUserRepository)(nil).FindUserByID), id)
}</span>

// FindUsers mocks base method.
func (m *MockIUserRepository) FindUsers(search string) ([]*domain.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindUsers", search)
        ret0, _ := ret[0].([]*domain.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindUsers indicates an expected call of FindUsers.
func (mr *MockIUserRepositoryMockRecorder) FindUsers(search interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindUsers", reflect.TypeOf((*MockIUserRepository)(nil).FindUsers), search)
}</span>

// UpdateUser mocks base method.
func (m *MockIUserRepository) UpdateUser(user *domain.User) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateUser", user)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateUser indicates an expected call of UpdateUser.
func (mr *MockIUserRepositoryMockRecorder) UpdateUser(user interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateUser", reflect.TypeOf((*MockIUserRepository)(nil).UpdateUser), user)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package domain

import (
        "errors"
        "time"

        "github.com/google/uuid"
)

// GroupType はグループの種類を表す
type GroupType string

const (
        GroupTypeProject  GroupType = "PROJECT"  // プロジェクト管理用
        GroupTypeSchedule GroupType = "SCHEDULE" // 予定共有用
)

// MemberRole はグループ内の権限を表す
type MemberRole string

const (
        RoleOwner  MemberRole = "OWNER"  // 所有者
        RoleAdmin  MemberRole = "ADMIN"  // 管理者
        RoleMember MemberRole = "MEMBER" // メンバー
)

// Group はグループ情報を表すドメインエンティティ
type Group struct {
        ID          uuid.UUID     `json:"id"`
        Name        string        `json:"name"`
        Description string        `json:"description"`
        Type        GroupType     `json:"type"`
        OwnerID     uuid.UUID     `json:"owner_id"`
        Settings    GroupSettings `json:"settings"`
        MemberCount int           `json:"member_count"`
        CreatedAt   time.Time     `json:"created_at"`
        UpdatedAt   time.Time     `json:"updated_at"`
        Version     int           `json:"version"` // 楽観的ロック用
}

// GroupSettings はグループの設定を表す
type GroupSettings struct {
        IsPublic            bool `json:"is_public"`            // 公開/非公開
        AllowMemberInvite   bool `json:"allow_member_invite"`  // メンバーの招待許可
        RequireApproval     bool `json:"require_approval"`     // 参加承認制
        EnableNotifications bool `json:"enable_notifications"` // 通知有効

        // 予定共有グループ用
        DefaultPrivacyLevel  PrivacyLevel `json:"default_privacy_level,omitempty"`
        AllowScheduleDetails bool         `json:"allow_schedule_details,omitempty"`

        // プロジェクトグループ用
        EnableGanttChart     bool `json:"enable_gantt_chart,omitempty"`
        EnableTaskDependency bool `json:"enable_task_dependency,omitempty"`
}

// PrivacyLevel は予定の公開レベル
type PrivacyLevel string

const (
        PrivacyLevelNone    PrivacyLevel = "NONE"    // 非表示
        PrivacyLevelBusy    PrivacyLevel = "BUSY"    // 予定ありのみ
        PrivacyLevelTitle   PrivacyLevel = "TITLE"   // タイトルまで
        PrivacyLevelDetails PrivacyLevel = "DETAILS" // 詳細まで
)

// NewGroup は新しいグループを作成する
func NewGroup(name, description string, groupType GroupType, ownerID uuid.UUID) *Group <span class="cov8" title="1">{
        now := time.Now()
        return &amp;Group{
                ID:          uuid.New(),
                Name:        name,
                Description: description,
                Type:        groupType,
                OwnerID:     ownerID,
                Settings:    getDefaultSettings(groupType),
                MemberCount: 1, // 作成者
                CreatedAt:   now,
                UpdatedAt:   now,
                Version:     1,
        }
}</span>

// getDefaultSettings はグループタイプに応じたデフォルト設定を返す
func getDefaultSettings(groupType GroupType) GroupSettings <span class="cov8" title="1">{
        base := GroupSettings{
                IsPublic:            false,
                AllowMemberInvite:   true,
                RequireApproval:     true,
                EnableNotifications: true,
        }

        switch groupType </span>{
        case GroupTypeSchedule:<span class="cov8" title="1">
                base.DefaultPrivacyLevel = PrivacyLevelBusy
                base.AllowScheduleDetails = false</span>
        case GroupTypeProject:<span class="cov8" title="1">
                base.EnableGanttChart = true
                base.EnableTaskDependency = false</span>
        }

        <span class="cov8" title="1">return base</span>
}

// UpdateSettings はグループ設定を更新する
func (g *Group) UpdateSettings(settings GroupSettings) <span class="cov8" title="1">{
        g.Settings = settings
        g.UpdatedAt = time.Now()
        g.Version++
}</span>

// AddMember はメンバー数を増加させる
func (g *Group) AddMember() <span class="cov8" title="1">{
        g.MemberCount++
        g.UpdatedAt = time.Now()
        g.Version++
}</span>

// RemoveMember はメンバー数を減少させる
func (g *Group) RemoveMember() error <span class="cov8" title="1">{
        if g.MemberCount &lt;= 1 </span><span class="cov8" title="1">{
                return errors.New("cannot remove the last member")
        }</span>
        <span class="cov8" title="1">g.MemberCount--
        g.UpdatedAt = time.Now()
        g.Version++
        return nil</span>
}

// GroupMember はグループメンバーシップを表す
type GroupMember struct {
        ID        uuid.UUID  `json:"id"`
        GroupID   uuid.UUID  `json:"group_id"`
        UserID    uuid.UUID  `json:"user_id"`
        Role      MemberRole `json:"role"`
        JoinedAt  time.Time  `json:"joined_at"`
        UpdatedAt time.Time  `json:"updated_at"`
}

// NewGroupMember は新しいグループメンバーを作成する
func NewGroupMember(groupID, userID uuid.UUID, role MemberRole) *GroupMember <span class="cov8" title="1">{
        now := time.Now()
        return &amp;GroupMember{
                ID:        uuid.New(),
                GroupID:   groupID,
                UserID:    userID,
                Role:      role,
                JoinedAt:  now,
                UpdatedAt: now,
        }
}</span>

// CanManageGroup はグループ管理権限があるかチェック
func (gm *GroupMember) CanManageGroup() bool <span class="cov8" title="1">{
        return gm.Role == RoleOwner || gm.Role == RoleAdmin
}</span>

// CanInviteMembers はメンバー招待権限があるかチェック
func (gm *GroupMember) CanInviteMembers(groupSettings GroupSettings) bool <span class="cov8" title="1">{
        if gm.Role == RoleOwner || gm.Role == RoleAdmin </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return gm.Role == RoleMember &amp;&amp; groupSettings.AllowMemberInvite</span>
}

// PromoteToAdmin は管理者に昇格させる
func (gm *GroupMember) PromoteToAdmin() error <span class="cov8" title="1">{
        if gm.Role == RoleOwner </span><span class="cov8" title="1">{
                return errors.New("owner cannot be promoted")
        }</span>
        <span class="cov8" title="1">gm.Role = RoleAdmin
        gm.UpdatedAt = time.Now()
        return nil</span>
}

// DemoteToMember は一般メンバーに降格させる
func (gm *GroupMember) DemoteToMember() error <span class="cov8" title="1">{
        if gm.Role == RoleOwner </span><span class="cov8" title="1">{
                return errors.New("owner cannot be demoted")
        }</span>
        <span class="cov8" title="1">gm.Role = RoleMember
        gm.UpdatedAt = time.Now()
        return nil</span>
}

// TransferOwnership は所有権を移譲する
func (gm *GroupMember) TransferOwnership() <span class="cov8" title="1">{
        gm.Role = RoleOwner
        gm.UpdatedAt = time.Now()
}</span>

// GroupStats はグループ統計情報
type GroupStats struct {
        MemberCount   int `json:"member_count"`
        TaskCount     int `json:"task_count,omitempty"`     // プロジェクトグループの場合
        ScheduleCount int `json:"schedule_count,omitempty"` // 予定共有グループの場合
        ActiveMembers int `json:"active_members"`           // 最近活動したメンバー数
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package database

import (
        "database/sql"
        "fmt"

        "github.com/hryt430/Yotei+/config"
        "github.com/hryt430/Yotei+/internal/common/infrastructure/database"
)

// SqlHandler はGroupモジュール用のSQLハンドラー
type SqlHandler struct {
        Conn *sql.DB
}

// NewSqlHandler は新しいSqlHandlerを作成する
func NewSqlHandler() SqlHandler <span class="cov0" title="0">{
        // 共通のMySQLコネクションを使用
        cfg, err := config.LoadConfig("")
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to load config: %v", err))</span>
        }
        <span class="cov0" title="0">conn, err := database.NewMySQLConnection(cfg)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to connect to database: %v", err))</span>
        }

        <span class="cov0" title="0">return SqlHandler{
                Conn: conn,
        }</span>
}

// Close はデータベース接続を閉じる
func (h *SqlHandler) Close() error <span class="cov0" title="0">{
        if h.Conn != nil </span><span class="cov0" title="0">{
                return h.Conn.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetConnection はデータベース接続を取得する
func (h *SqlHandler) GetConnection() *sql.DB <span class="cov0" title="0">{
        return h.Conn
}</span>

// Begin はトランザクションを開始する
func (h *SqlHandler) Begin() (*sql.Tx, error) <span class="cov0" title="0">{
        return h.Conn.Begin()
}</span>

// ExecInTransaction はトランザクション内でクエリを実行する
func (h *SqlHandler) ExecInTransaction(txFunc func(*sql.Tx) error) error <span class="cov0" title="0">{
        tx, err := h.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if p := recover(); p != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        panic(p)</span>
                } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                }</span> else<span class="cov0" title="0"> {
                        err = tx.Commit()
                }</span>
        }()

        <span class="cov0" title="0">err = txFunc(tx)
        return err</span>
}

// InitializeTables はGroupモジュール用のテーブルを初期化する
func (h *SqlHandler) InitializeTables() error <span class="cov0" title="0">{
        // グループテーブル
        groupsTableSQL := `
        CREATE TABLE IF NOT EXISTS groups (
                id CHAR(36) PRIMARY KEY,
                name VARCHAR(255) NOT NULL,
                description TEXT,
                type ENUM('PUBLIC', 'PRIVATE', 'SECRET') NOT NULL DEFAULT 'PRIVATE',
                owner_id CHAR(36) NOT NULL,
                settings JSON NULL COMMENT 'グループ設定',
                member_count INT DEFAULT 1,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                INDEX idx_owner_id (owner_id),
                INDEX idx_type (type),
                INDEX idx_name (name),
                INDEX idx_created_at (created_at)
        ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
        `

        // グループメンバーテーブル
        groupMembersTableSQL := `
        CREATE TABLE IF NOT EXISTS group_members (
                id CHAR(36) PRIMARY KEY,
                group_id CHAR(36) NOT NULL,
                user_id CHAR(36) NOT NULL,
                role ENUM('OWNER', 'ADMIN', 'MEMBER') NOT NULL DEFAULT 'MEMBER',
                joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                INDEX idx_group_id (group_id),
                INDEX idx_user_id (user_id),
                INDEX idx_role (role),
                INDEX idx_joined_at (joined_at),
                UNIQUE KEY unique_group_member (group_id, user_id)
        ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
        `

        // グループタスクテーブル
        groupTasksTableSQL := `
        CREATE TABLE IF NOT EXISTS group_tasks (
                id CHAR(36) PRIMARY KEY,
                group_id CHAR(36) NOT NULL,
                task_id CHAR(36) NOT NULL,
                assigned_by CHAR(36) NOT NULL,
                assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                INDEX idx_group_id (group_id),
                INDEX idx_task_id (task_id),
                INDEX idx_assigned_by (assigned_by),
                INDEX idx_assigned_at (assigned_at),
                UNIQUE KEY unique_group_task (group_id, task_id)
        ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
        `

        // テーブル作成
        tables := []string{groupsTableSQL, groupMembersTableSQL, groupTasksTableSQL}

        for _, tableSQL := range tables </span><span class="cov0" title="0">{
                if _, err := h.Conn.Exec(tableSQL); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create table: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// CreateIndexes は必要なインデックスを作成する
func (h *SqlHandler) CreateIndexes() error <span class="cov0" title="0">{
        indexes := []string{
                // グループの複合インデックス
                `CREATE INDEX IF NOT EXISTS idx_group_owner_type ON groups (owner_id, type)`,
                `CREATE INDEX IF NOT EXISTS idx_group_type_created ON groups (type, created_at)`,

                // グループメンバーの複合インデックス
                `CREATE INDEX IF NOT EXISTS idx_member_group_role ON group_members (group_id, role)`,
                `CREATE INDEX IF NOT EXISTS idx_member_user_role ON group_members (user_id, role)`,

                // グループタスクの複合インデックス
                `CREATE INDEX IF NOT EXISTS idx_group_task_assigned ON group_tasks (group_id, assigned_at)`,
        }

        for _, indexSQL := range indexes </span><span class="cov0" title="0">{
                if _, err := h.Conn.Exec(indexSQL); err != nil </span><span class="cov0" title="0">{
                        // インデックス作成エラーは警告レベル（既に存在する場合など）
                        fmt.Printf("Warning: Failed to create index: %v\n", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// HealthCheck はデータベース接続の健全性をチェックする
func (h *SqlHandler) HealthCheck() error <span class="cov0" title="0">{
        return h.Conn.Ping()
}</span>

// GetStats はデータベース統計情報を取得する
func (h *SqlHandler) GetStats() sql.DBStats <span class="cov0" title="0">{
        return h.Conn.Stats()
}</pre>
		
		<pre class="file" id="file18" style="display: none">package controller

import (
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        commonDomain "github.com/hryt430/Yotei+/internal/common/domain"
        "github.com/hryt430/Yotei+/internal/common/middleware"
        "github.com/hryt430/Yotei+/internal/modules/group/domain"
        "github.com/hryt430/Yotei+/internal/modules/group/interface/dto"
        groupUsecase "github.com/hryt430/Yotei+/internal/modules/group/usecase"
        "github.com/hryt430/Yotei+/pkg/logger"
        "go.uber.org/zap/zapcore"
)

type GroupController struct {
        groupService groupUsecase.GroupService
        logger       logger.Logger
}

func NewGroupController(groupService groupUsecase.GroupService, logger logger.Logger) *GroupController <span class="cov0" title="0">{
        return &amp;GroupController{
                groupService: groupService,
                logger:       logger,
        }
}</span>

// Swagger用のリクエスト/レスポンス構造体定義
type CreateGroupRequest struct {
        Name        string               `json:"name" binding:"required,max=100" example:"プロジェクトチーム"`
        Description string               `json:"description" binding:"max=500" example:"新製品開発プロジェクトのチーム"`
        Type        string               `json:"type" binding:"required" enums:"PROJECT,SCHEDULE" example:"PROJECT"`
        Settings    domain.GroupSettings `json:"settings"`
} // @name CreateGroupRequest

type UpdateGroupRequest struct {
        Name        *string               `json:"name,omitempty" binding:"omitempty,max=100" example:"プロジェクトチーム"`
        Description *string               `json:"description,omitempty" binding:"omitempty,max=500" example:"新製品開発プロジェクトのチーム"`
        Settings    *domain.GroupSettings `json:"settings,omitempty"`
} // @name UpdateGroupRequest

type AddMemberRequest struct {
        UserID string `json:"user_id" binding:"required" example:"123e4567-e89b-12d3-a456-426614174000"`
        Role   string `json:"role" enums:"OWNER,ADMIN,MEMBER" example:"MEMBER"`
} // @name AddMemberRequest

type UpdateMemberRoleRequest struct {
        Role string `json:"role" binding:"required" enums:"OWNER,ADMIN,MEMBER" example:"ADMIN"`
} // @name UpdateMemberRoleRequest

// ErrorResponse はエラーレスポンス構造体
type ErrorResponse struct {
        Success bool   `json:"success" example:"false"`
        Error   string `json:"error" example:"INVALID_REQUEST"`
        Message string `json:"message" example:"リクエストが無効です"`
} // @name ErrorResponse

// CreateGroup グループ作成
// @Summary      グループ作成
// @Description  新しいグループを作成します（プロジェクト管理用または予定共有用）
// @Tags         groups
// @Accept       json
// @Produce      json
// @Param        request body dto.CreateGroupRequest true "グループ作成情報"
// @Security     BearerAuth
// @Success      201 {object} dto.GroupResponse "グループ作成成功"
// @Failure      400 {object} ErrorResponse "リクエストが無効"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /groups [post]
func (gc *GroupController) CreateGroup(c *gin.Context) <span class="cov0" title="0">{
        user, err := middleware.GetUserFromContext(c)
        if err != nil </span><span class="cov0" title="0">{
                gc.logError("get user from context", err)
                c.JSON(http.StatusUnauthorized, ErrorResponse{
                        Error:   "UNAUTHORIZED",
                        Message: "認証が必要です",
                })
                return
        }</span>

        <span class="cov0" title="0">var req dto.CreateGroupRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                gc.logError("bind JSON", err)
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "INVALID_REQUEST",
                        Message: "リクエストボディが不正です",
                })
                return
        }</span>

        <span class="cov0" title="0">input := groupUsecase.CreateGroupInput{
                Name:        req.Name,
                Description: req.Description,
                Type:        domain.GroupType(req.Type),
                OwnerID:     user.ID,
                Settings:    req.Settings,
        }

        group, err := gc.groupService.CreateGroup(c.Request.Context(), input)
        if err != nil </span><span class="cov0" title="0">{
                gc.logError("create group", err,
                        logger.Any("userID", user.ID),
                        logger.Any("groupName", req.Name))
                c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "INTERNAL_ERROR",
                        Message: "グループの作成に失敗しました",
                })
                return
        }</span>

        <span class="cov0" title="0">gc.logger.Info("Group created successfully",
                logger.Any("groupID", group.ID),
                logger.Any("ownerID", user.ID))

        response := dto.ToGroupResponse(group)
        c.JSON(http.StatusCreated, response)</span>
}

// GetGroup グループ詳細取得
// @Summary      グループ詳細取得
// @Description  指定されたIDのグループの詳細情報とメンバー一覧を取得します
// @Tags         groups
// @Accept       json
// @Produce      json
// @Param        groupId path string true "グループID" example:"123e4567-e89b-12d3-a456-426614174000"
// @Security     BearerAuth
// @Success      200 {object} GroupWithMembersResponse "グループ詳細取得成功"
// @Failure      400 {object} ErrorResponse "グループIDが無効"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      404 {object} ErrorResponse "グループが見つからない"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /groups/{groupId} [get]
func (gc *GroupController) GetGroup(c *gin.Context) <span class="cov0" title="0">{
        user, err := middleware.GetUserFromContext(c)
        if err != nil </span><span class="cov0" title="0">{
                gc.logError("get user from context", err)
                c.JSON(http.StatusUnauthorized, ErrorResponse{
                        Error:   "UNAUTHORIZED",
                        Message: "認証が必要です",
                })
                return
        }</span>

        <span class="cov0" title="0">groupID, err := gc.validateUUID(c.Param("groupId"), "group ID")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "INVALID_GROUP_ID",
                        Message: "グループIDが不正です",
                })
                return
        }</span>

        <span class="cov0" title="0">groupWithMembers, err := gc.groupService.GetGroup(c.Request.Context(), groupID, user.ID)
        if err != nil </span><span class="cov0" title="0">{
                gc.logError("get group", err,
                        logger.Any("groupID", groupID),
                        logger.Any("userID", user.ID))
                c.JSON(http.StatusNotFound, ErrorResponse{
                        Error:   "GROUP_NOT_FOUND",
                        Message: "グループが見つかりません",
                })
                return
        }</span>

        <span class="cov0" title="0">response := dto.ToGroupWithMembersResponse(groupWithMembers)
        c.JSON(http.StatusOK, response)</span>
}

// UpdateGroup グループ更新
// @Summary      グループ更新
// @Description  指定されたIDのグループ情報を更新します（管理者のみ）
// @Tags         groups
// @Accept       json
// @Produce      json
// @Param        groupId path string true "グループID" example:"123e4567-e89b-12d3-a456-426614174000"
// @Param        request body UpdateGroupRequest true "グループ更新情報"
// @Security     BearerAuth
// @Success      200 {object} GroupResponse "グループ更新成功"
// @Failure      400 {object} ErrorResponse "リクエストが無効"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      403 {object} ErrorResponse "権限不足"
// @Failure      404 {object} ErrorResponse "グループが見つからない"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /groups/{groupId} [put]
func (gc *GroupController) UpdateGroup(c *gin.Context) <span class="cov0" title="0">{
        user, err := middleware.GetUserFromContext(c)
        if err != nil </span><span class="cov0" title="0">{
                gc.logError("get user from context", err)
                c.JSON(http.StatusUnauthorized, ErrorResponse{
                        Error:   "UNAUTHORIZED",
                        Message: "認証が必要です",
                })
                return
        }</span>

        <span class="cov0" title="0">groupID, err := gc.validateUUID(c.Param("groupId"), "group ID")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "INVALID_GROUP_ID",
                        Message: "グループIDが不正です",
                })
                return
        }</span>

        <span class="cov0" title="0">var req dto.UpdateGroupRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                gc.logError("bind JSON", err)
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "INVALID_REQUEST",
                        Message: "リクエストボディが不正です",
                })
                return
        }</span>

        <span class="cov0" title="0">input := groupUsecase.UpdateGroupInput{
                Name:        req.Name,
                Description: req.Description,
                Settings:    req.Settings,
        }

        group, err := gc.groupService.UpdateGroup(c.Request.Context(), groupID, input, user.ID)
        if err != nil </span><span class="cov0" title="0">{
                gc.logError("update group", err,
                        logger.Any("groupID", groupID),
                        logger.Any("userID", user.ID))
                c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "INTERNAL_ERROR",
                        Message: "グループの更新に失敗しました",
                })
                return
        }</span>

        <span class="cov0" title="0">gc.logger.Info("Group updated successfully",
                logger.Any("groupID", groupID),
                logger.Any("userID", user.ID))

        response := dto.ToGroupResponse(group)
        c.JSON(http.StatusOK, response)</span>
}

// DeleteGroup グループ削除
// @Summary      グループ削除
// @Description  指定されたIDのグループを削除します（オーナーのみ）
// @Tags         groups
// @Accept       json
// @Produce      json
// @Param        groupId path string true "グループID" example:"123e4567-e89b-12d3-a456-426614174000"
// @Security     BearerAuth
// @Success      200 {object} SuccessResponse "グループ削除成功"
// @Failure      400 {object} ErrorResponse "グループIDが無効"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      403 {object} ErrorResponse "権限不足（オーナーのみ削除可能）"
// @Failure      404 {object} ErrorResponse "グループが見つからない"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /groups/{groupId} [delete]
func (gc *GroupController) DeleteGroup(c *gin.Context) <span class="cov0" title="0">{
        user, err := middleware.GetUserFromContext(c)
        if err != nil </span><span class="cov0" title="0">{
                gc.logError("get user from context", err)
                c.JSON(http.StatusUnauthorized, ErrorResponse{
                        Error:   "UNAUTHORIZED",
                        Message: "認証が必要です",
                })
                return
        }</span>

        <span class="cov0" title="0">groupID, err := gc.validateUUID(c.Param("groupId"), "group ID")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "INVALID_GROUP_ID",
                        Message: "グループIDが不正です",
                })
                return
        }</span>

        <span class="cov0" title="0">err = gc.groupService.DeleteGroup(c.Request.Context(), groupID, user.ID)
        if err != nil </span><span class="cov0" title="0">{
                gc.logError("delete group", err,
                        logger.Any("groupID", groupID),
                        logger.Any("userID", user.ID))
                c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "INTERNAL_ERROR",
                        Message: "グループの削除に失敗しました",
                })
                return
        }</span>

        <span class="cov0" title="0">gc.logger.Info("Group deleted successfully",
                logger.Any("groupID", groupID),
                logger.Any("userID", user.ID))

        c.JSON(http.StatusOK, dto.SuccessResponse{
                Success: true,
                Message: "グループを削除しました",
        })</span>
}

// ListMyGroups 自分のグループ一覧取得
// @Summary      自分のグループ一覧取得
// @Description  自分が所属しているグループの一覧を取得します（ページング対応）
// @Tags         groups
// @Accept       json
// @Produce      json
// @Param        type query string false "グループタイプでフィルタ" enums:"PROJECT,SCHEDULE"
// @Param        page query int false "ページ番号" default(1) minimum(1)
// @Param        page_size query int false "ページサイズ" default(10) minimum(1) maximum(100)
// @Security     BearerAuth
// @Success      200 {object} GroupListResponse "グループ一覧取得成功"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /groups/my [get]
func (gc *GroupController) ListMyGroups(c *gin.Context) <span class="cov0" title="0">{
        user, err := middleware.GetUserFromContext(c)
        if err != nil </span><span class="cov0" title="0">{
                gc.logError("get user from context", err)
                c.JSON(http.StatusUnauthorized, ErrorResponse{
                        Error:   "UNAUTHORIZED",
                        Message: "認証が必要です",
                })
                return
        }</span>

        // クエリパラメータの解析
        <span class="cov0" title="0">var groupType *domain.GroupType
        if typeStr := c.Query("type"); typeStr != "" </span><span class="cov0" title="0">{
                gt := domain.GroupType(typeStr)
                groupType = &amp;gt
        }</span>

        <span class="cov0" title="0">page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
        pageSize, _ := strconv.Atoi(c.DefaultQuery("page_size", "10"))

        pagination := commonDomain.Pagination{
                Page:     page,
                PageSize: pageSize,
        }

        groups, total, err := gc.groupService.GetMyGroups(c.Request.Context(), user.ID, groupType, pagination)
        if err != nil </span><span class="cov0" title="0">{
                gc.logError("get my groups", err, logger.Any("userID", user.ID))
                c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "INTERNAL_ERROR",
                        Message: "グループ一覧の取得に失敗しました",
                })
                return
        }</span>

        <span class="cov0" title="0">response := dto.ToGroupListResponse(groups, total, page, pageSize)
        c.JSON(http.StatusOK, response)</span>
}

// SearchGroups グループ検索
// @Summary      グループ検索
// @Description  キーワードでグループを検索します（ページング対応）
// @Tags         groups
// @Accept       json
// @Produce      json
// @Param        q query string true "検索クエリ" example:"プロジェクト"
// @Param        type query string false "グループタイプでフィルタ" enums:"PROJECT,SCHEDULE"
// @Param        page query int false "ページ番号" default(1) minimum(1)
// @Param        page_size query int false "ページサイズ" default(10) minimum(1) maximum(100)
// @Security     BearerAuth
// @Success      200 {object} GroupListResponse "グループ検索成功"
// @Failure      400 {object} ErrorResponse "検索クエリが必要"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /groups/search [get]
func (gc *GroupController) SearchGroups(c *gin.Context) <span class="cov0" title="0">{
        query := c.Query("q")
        if query == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "MISSING_QUERY",
                        Message: "検索クエリが必要です",
                })
                return
        }</span>

        <span class="cov0" title="0">var groupType *domain.GroupType
        if typeStr := c.Query("type"); typeStr != "" </span><span class="cov0" title="0">{
                gt := domain.GroupType(typeStr)
                groupType = &amp;gt
        }</span>

        <span class="cov0" title="0">page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
        pageSize, _ := strconv.Atoi(c.DefaultQuery("page_size", "10"))

        pagination := commonDomain.Pagination{
                Page:     page,
                PageSize: pageSize,
        }

        groups, total, err := gc.groupService.SearchGroups(c.Request.Context(), query, groupType, pagination)
        if err != nil </span><span class="cov0" title="0">{
                gc.logError("search groups", err,
                        logger.Any("query", query),
                        logger.Any("groupType", groupType))
                c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "INTERNAL_ERROR",
                        Message: "グループの検索に失敗しました",
                })
                return
        }</span>

        <span class="cov0" title="0">response := dto.ToGroupListResponse(groups, total, page, pageSize)
        c.JSON(http.StatusOK, response)</span>
}

// AddMember メンバー追加
// @Summary      メンバー追加
// @Description  指定されたグループにメンバーを追加します（管理者のみ）
// @Tags         groups
// @Accept       json
// @Produce      json
// @Param        groupId path string true "グループID" example:"123e4567-e89b-12d3-a456-426614174000"
// @Param        request body AddMemberRequest true "メンバー追加情報"
// @Security     BearerAuth
// @Success      200 {object} SuccessResponse "メンバー追加成功"
// @Failure      400 {object} ErrorResponse "リクエストが無効"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      403 {object} ErrorResponse "権限不足"
// @Failure      404 {object} ErrorResponse "グループまたはユーザーが見つからない"
// @Failure      409 {object} ErrorResponse "既にメンバー"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /groups/{groupId}/members [post]
func (gc *GroupController) AddMember(c *gin.Context) <span class="cov0" title="0">{
        user, err := middleware.GetUserFromContext(c)
        if err != nil </span><span class="cov0" title="0">{
                gc.logError("get user from context", err)
                c.JSON(http.StatusUnauthorized, ErrorResponse{
                        Error:   "UNAUTHORIZED",
                        Message: "認証が必要です",
                })
                return
        }</span>

        <span class="cov0" title="0">groupID, err := gc.validateUUID(c.Param("groupId"), "group ID")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "INVALID_GROUP_ID",
                        Message: "グループIDが不正です",
                })
                return
        }</span>

        <span class="cov0" title="0">var req dto.AddMemberRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                gc.logError("bind JSON", err)
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "INVALID_REQUEST",
                        Message: "リクエストボディが不正です",
                })
                return
        }</span>

        <span class="cov0" title="0">userIDToAdd, err := gc.validateUUID(req.UserID, "user ID")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "INVALID_USER_ID",
                        Message: "ユーザーIDが不正です",
                })
                return
        }</span>

        <span class="cov0" title="0">role := domain.MemberRole(req.Role)
        if role == "" </span><span class="cov0" title="0">{
                role = domain.RoleMember
        }</span>

        <span class="cov0" title="0">err = gc.groupService.AddMember(c.Request.Context(), groupID, userIDToAdd, user.ID, role)
        if err != nil </span><span class="cov0" title="0">{
                gc.logError("add member", err,
                        logger.Any("groupID", groupID),
                        logger.Any("userIDToAdd", userIDToAdd),
                        logger.Any("requesterID", user.ID))
                c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "INTERNAL_ERROR",
                        Message: "メンバーの追加に失敗しました",
                })
                return
        }</span>

        <span class="cov0" title="0">gc.logger.Info("Member added successfully",
                logger.Any("groupID", groupID),
                logger.Any("userIDToAdd", userIDToAdd),
                logger.Any("role", role))

        c.JSON(http.StatusOK, dto.SuccessResponse{
                Success: true,
                Message: "メンバーを追加しました",
        })</span>
}

// RemoveMember メンバー削除
// @Summary      メンバー削除
// @Description  指定されたグループからメンバーを削除します（管理者のみ、または自分自身の脱退）
// @Tags         groups
// @Accept       json
// @Produce      json
// @Param        groupId path string true "グループID" example:"123e4567-e89b-12d3-a456-426614174000"
// @Param        userId path string true "削除するユーザーID" example:"123e4567-e89b-12d3-a456-426614174000"
// @Security     BearerAuth
// @Success      200 {object} SuccessResponse "メンバー削除成功"
// @Failure      400 {object} ErrorResponse "IDが無効"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      403 {object} ErrorResponse "権限不足"
// @Failure      404 {object} ErrorResponse "グループまたはユーザーが見つからない"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /groups/{groupId}/members/{userId} [delete]
func (gc *GroupController) RemoveMember(c *gin.Context) <span class="cov0" title="0">{
        user, err := middleware.GetUserFromContext(c)
        if err != nil </span><span class="cov0" title="0">{
                gc.logError("get user from context", err)
                c.JSON(http.StatusUnauthorized, ErrorResponse{
                        Error:   "UNAUTHORIZED",
                        Message: "認証が必要です",
                })
                return
        }</span>

        <span class="cov0" title="0">groupID, err := gc.validateUUID(c.Param("groupId"), "group ID")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "INVALID_GROUP_ID",
                        Message: "グループIDが不正です",
                })
                return
        }</span>

        <span class="cov0" title="0">userIDToRemove, err := gc.validateUUID(c.Param("userId"), "user ID")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "INVALID_USER_ID",
                        Message: "ユーザーIDが不正です",
                })
                return
        }</span>

        <span class="cov0" title="0">err = gc.groupService.RemoveMember(c.Request.Context(), groupID, userIDToRemove, user.ID)
        if err != nil </span><span class="cov0" title="0">{
                gc.logError("remove member", err,
                        logger.Any("groupID", groupID),
                        logger.Any("userIDToRemove", userIDToRemove),
                        logger.Any("requesterID", user.ID))
                c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "INTERNAL_ERROR",
                        Message: "メンバーの削除に失敗しました",
                })
                return
        }</span>

        <span class="cov0" title="0">gc.logger.Info("Member removed successfully",
                logger.Any("groupID", groupID),
                logger.Any("userIDToRemove", userIDToRemove))

        c.JSON(http.StatusOK, dto.SuccessResponse{
                Success: true,
                Message: "メンバーを削除しました",
        })</span>
}

// UpdateMemberRole メンバー権限変更
// @Summary      メンバー権限変更
// @Description  指定されたメンバーの権限を変更します（管理者のみ）
// @Tags         groups
// @Accept       json
// @Produce      json
// @Param        groupId path string true "グループID" example:"123e4567-e89b-12d3-a456-426614174000"
// @Param        userId path string true "権限変更するユーザーID" example:"123e4567-e89b-12d3-a456-426614174000"
// @Param        request body UpdateMemberRoleRequest true "権限変更情報"
// @Security     BearerAuth
// @Success      200 {object} SuccessResponse "権限変更成功"
// @Failure      400 {object} ErrorResponse "リクエストが無効"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      403 {object} ErrorResponse "権限不足"
// @Failure      404 {object} ErrorResponse "グループまたはユーザーが見つからない"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /groups/{groupId}/members/{userId}/role [put]
func (gc *GroupController) UpdateMemberRole(c *gin.Context) <span class="cov0" title="0">{
        user, err := middleware.GetUserFromContext(c)
        if err != nil </span><span class="cov0" title="0">{
                gc.logError("get user from context", err)
                c.JSON(http.StatusUnauthorized, ErrorResponse{
                        Error:   "UNAUTHORIZED",
                        Message: "認証が必要です",
                })
                return
        }</span>

        <span class="cov0" title="0">groupID, err := gc.validateUUID(c.Param("groupId"), "group ID")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "INVALID_GROUP_ID",
                        Message: "グループIDが不正です",
                })
                return
        }</span>

        <span class="cov0" title="0">userIDToUpdate, err := gc.validateUUID(c.Param("userId"), "user ID")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "INVALID_USER_ID",
                        Message: "ユーザーIDが不正です",
                })
                return
        }</span>

        <span class="cov0" title="0">var req dto.UpdateMemberRoleRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                gc.logError("bind JSON", err)
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "INVALID_REQUEST",
                        Message: "リクエストボディが不正です",
                })
                return
        }</span>

        <span class="cov0" title="0">newRole := domain.MemberRole(req.Role)

        err = gc.groupService.UpdateMemberRole(c.Request.Context(), groupID, userIDToUpdate, user.ID, newRole)
        if err != nil </span><span class="cov0" title="0">{
                gc.logError("update member role", err,
                        logger.Any("groupID", groupID),
                        logger.Any("userIDToUpdate", userIDToUpdate),
                        logger.Any("newRole", newRole),
                        logger.Any("requesterID", user.ID))
                c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "INTERNAL_ERROR",
                        Message: "メンバー権限の更新に失敗しました",
                })
                return
        }</span>

        <span class="cov0" title="0">gc.logger.Info("Member role updated successfully",
                logger.Any("groupID", groupID),
                logger.Any("userIDToUpdate", userIDToUpdate),
                logger.Any("newRole", newRole))

        c.JSON(http.StatusOK, dto.SuccessResponse{
                Success: true,
                Message: "メンバー権限を更新しました",
        })</span>
}

// ListMembers メンバー一覧取得
// @Summary      メンバー一覧取得
// @Description  指定されたグループのメンバー一覧を取得します（ページング対応）
// @Tags         groups
// @Accept       json
// @Produce      json
// @Param        groupId path string true "グループID" example:"123e4567-e89b-12d3-a456-426614174000"
// @Param        page query int false "ページ番号" default(1) minimum(1)
// @Param        page_size query int false "ページサイズ" default(20) minimum(1) maximum(100)
// @Security     BearerAuth
// @Success      200 {object} MemberListResponse "メンバー一覧取得成功"
// @Failure      400 {object} ErrorResponse "グループIDが無効"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      403 {object} ErrorResponse "グループへのアクセス権限なし"
// @Failure      404 {object} ErrorResponse "グループが見つからない"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /groups/{groupId}/members [get]
func (gc *GroupController) ListMembers(c *gin.Context) <span class="cov0" title="0">{
        groupID, err := gc.validateUUID(c.Param("groupId"), "group ID")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "INVALID_GROUP_ID",
                        Message: "グループIDが不正です",
                })
                return
        }</span>

        <span class="cov0" title="0">page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
        pageSize, _ := strconv.Atoi(c.DefaultQuery("page_size", "20"))

        pagination := commonDomain.Pagination{
                Page:     page,
                PageSize: pageSize,
        }

        members, err := gc.groupService.GetMembers(c.Request.Context(), groupID, pagination)
        if err != nil </span><span class="cov0" title="0">{
                gc.logError("get members", err, logger.Any("groupID", groupID))
                c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "INTERNAL_ERROR",
                        Message: "メンバー一覧の取得に失敗しました",
                })
                return
        }</span>

        <span class="cov0" title="0">response := dto.ToMemberListResponse(members)
        c.JSON(http.StatusOK, response)</span>
}

// GetGroupStats グループ統計取得
// @Summary      グループ統計取得
// @Description  指定されたグループの統計情報（メンバー数、タスク数など）を取得します
// @Tags         groups
// @Accept       json
// @Produce      json
// @Param        groupId path string true "グループID" example:"123e4567-e89b-12d3-a456-426614174000"
// @Security     BearerAuth
// @Success      200 {object} GroupStatsResponse "統計情報取得成功"
// @Failure      400 {object} ErrorResponse "グループIDが無効"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      403 {object} ErrorResponse "グループへのアクセス権限なし"
// @Failure      404 {object} ErrorResponse "グループが見つからない"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /groups/{groupId}/stats [get]
func (gc *GroupController) GetGroupStats(c *gin.Context) <span class="cov0" title="0">{
        user, err := middleware.GetUserFromContext(c)
        if err != nil </span><span class="cov0" title="0">{
                gc.logError("get user from context", err)
                c.JSON(http.StatusUnauthorized, ErrorResponse{
                        Error:   "UNAUTHORIZED",
                        Message: "認証が必要です",
                })
                return
        }</span>

        <span class="cov0" title="0">groupID, err := gc.validateUUID(c.Param("groupId"), "group ID")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "INVALID_GROUP_ID",
                        Message: "グループIDが不正です",
                })
                return
        }</span>

        <span class="cov0" title="0">stats, err := gc.groupService.GetGroupStats(c.Request.Context(), groupID, user.ID)
        if err != nil </span><span class="cov0" title="0">{
                gc.logError("get group stats", err,
                        logger.Any("groupID", groupID),
                        logger.Any("userID", user.ID))
                c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "INTERNAL_ERROR",
                        Message: "グループ統計の取得に失敗しました",
                })
                return
        }</span>

        <span class="cov0" title="0">response := dto.ToGroupStatsResponse(stats)
        c.JSON(http.StatusOK, response)</span>
}

// === ヘルパーメソッド ===

func (gc *GroupController) validateUUID(id string, fieldName string) (uuid.UUID, error) <span class="cov0" title="0">{
        parsedID, err := uuid.Parse(id)
        if err != nil </span><span class="cov0" title="0">{
                gc.logger.Error("Invalid UUID format",
                        logger.String("field", fieldName),
                        logger.String("value", id),
                        logger.Error(err))
                return uuid.Nil, err
        }</span>
        <span class="cov0" title="0">return parsedID, nil</span>
}

func (gc *GroupController) logError(operation string, err error, fields ...zapcore.Field) <span class="cov0" title="0">{
        allFields := append([]zapcore.Field{
                logger.String("operation", operation),
                logger.Error(err),
        }, fields...)
        gc.logger.Error("Operation failed", allFields...)
}</span>

// RegisterGroupRoutes はグループ関連のルートを登録する
func RegisterGroupRoutes(router *gin.RouterGroup, controller *GroupController) <span class="cov0" title="0">{
        groups := router.Group("/groups")
        </span><span class="cov0" title="0">{
                // グループ基本操作
                groups.POST("", controller.CreateGroup)
                groups.GET("/my", controller.ListMyGroups)
                groups.GET("/search", controller.SearchGroups)
                groups.GET("/:groupId", controller.GetGroup)
                groups.PUT("/:groupId", controller.UpdateGroup)
                groups.DELETE("/:groupId", controller.DeleteGroup)

                // メンバー管理
                groups.POST("/:groupId/members", controller.AddMember)
                groups.DELETE("/:groupId/members/:userId", controller.RemoveMember)
                groups.PUT("/:groupId/members/:userId/role", controller.UpdateMemberRole)
                groups.GET("/:groupId/members", controller.ListMembers)

                // 統計情報
                groups.GET("/:groupId/stats", controller.GetGroupStats)
        }</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package database

import (
        "context"
        "database/sql"
        "fmt"
        "strings"

        "github.com/google/uuid"
        commonDomain "github.com/hryt430/Yotei+/internal/common/domain"
        "github.com/hryt430/Yotei+/internal/modules/group/domain"
        groupUsecase "github.com/hryt430/Yotei+/internal/modules/group/usecase"
        "github.com/hryt430/Yotei+/pkg/logger"
)

type GroupRepository struct {
        db     *sql.DB
        logger logger.Logger
}

func NewGroupRepository(db *sql.DB, logger logger.Logger) groupUsecase.GroupRepository <span class="cov0" title="0">{
        return &amp;GroupRepository{
                db:     db,
                logger: logger,
        }
}</span>

// CreateGroup はグループを作成する
func (r *GroupRepository) CreateGroup(ctx context.Context, group *domain.Group) error <span class="cov0" title="0">{
        query := `
                INSERT INTO groups (
                        id, name, description, type, owner_id, member_count, 
                        is_public, allow_member_invite, require_approval, enable_notifications,
                        default_privacy_level, allow_schedule_details, enable_gantt_chart, enable_task_dependency,
                        created_at, updated_at, version
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err := r.db.ExecContext(ctx, query,
                group.ID.String(),
                group.Name,
                group.Description,
                string(group.Type),
                group.OwnerID.String(),
                group.MemberCount,
                group.Settings.IsPublic,
                group.Settings.AllowMemberInvite,
                group.Settings.RequireApproval,
                group.Settings.EnableNotifications,
                group.Settings.DefaultPrivacyLevel,
                group.Settings.AllowScheduleDetails,
                group.Settings.EnableGanttChart,
                group.Settings.EnableTaskDependency,
                group.CreatedAt,
                group.UpdatedAt,
                group.Version,
        )

        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to create group", logger.Error(err))
                return fmt.Errorf("failed to create group: %w", err)
        }</span>

        // オーナーをメンバーとして追加
        <span class="cov0" title="0">member := domain.NewGroupMember(group.ID, group.OwnerID, domain.RoleOwner)
        return r.AddMember(ctx, member)</span>
}

// GetGroupByID はIDでグループを取得する
func (r *GroupRepository) GetGroupByID(ctx context.Context, id uuid.UUID) (*domain.Group, error) <span class="cov0" title="0">{
        query := `
                SELECT id, name, description, type, owner_id, member_count,
                           is_public, allow_member_invite, require_approval, enable_notifications,
                           default_privacy_level, allow_schedule_details, enable_gantt_chart, enable_task_dependency,
                           created_at, updated_at, version
                FROM groups
                WHERE id = ?
        `

        var group domain.Group
        var idStr, ownerIDStr string
        var defaultPrivacyLevel, allowScheduleDetails, enableGanttChart, enableTaskDependency sql.NullString

        err := r.db.QueryRowContext(ctx, query, id.String()).Scan(
                &amp;idStr,
                &amp;group.Name,
                &amp;group.Description,
                (*string)(&amp;group.Type),
                &amp;ownerIDStr,
                &amp;group.MemberCount,
                &amp;group.Settings.IsPublic,
                &amp;group.Settings.AllowMemberInvite,
                &amp;group.Settings.RequireApproval,
                &amp;group.Settings.EnableNotifications,
                &amp;defaultPrivacyLevel,
                &amp;allowScheduleDetails,
                &amp;enableGanttChart,
                &amp;enableTaskDependency,
                &amp;group.CreatedAt,
                &amp;group.UpdatedAt,
                &amp;group.Version,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">r.logger.Error("Failed to get group by ID", logger.Error(err))
                return nil, fmt.Errorf("failed to get group: %w", err)</span>
        }

        <span class="cov0" title="0">group.ID, _ = uuid.Parse(idStr)
        group.OwnerID, _ = uuid.Parse(ownerIDStr)

        // Optional fieldsの処理
        if defaultPrivacyLevel.Valid </span><span class="cov0" title="0">{
                group.Settings.DefaultPrivacyLevel = domain.PrivacyLevel(defaultPrivacyLevel.String)
        }</span>
        <span class="cov0" title="0">if allowScheduleDetails.Valid </span><span class="cov0" title="0">{
                group.Settings.AllowScheduleDetails = allowScheduleDetails.String == "1"
        }</span>
        <span class="cov0" title="0">if enableGanttChart.Valid </span><span class="cov0" title="0">{
                group.Settings.EnableGanttChart = enableGanttChart.String == "1"
        }</span>
        <span class="cov0" title="0">if enableTaskDependency.Valid </span><span class="cov0" title="0">{
                group.Settings.EnableTaskDependency = enableTaskDependency.String == "1"
        }</span>

        <span class="cov0" title="0">return &amp;group, nil</span>
}

// UpdateGroup はグループを更新する
func (r *GroupRepository) UpdateGroup(ctx context.Context, group *domain.Group) error <span class="cov0" title="0">{
        query := `
                UPDATE groups
                SET name = ?, description = ?, member_count = ?, 
                        is_public = ?, allow_member_invite = ?, require_approval = ?, enable_notifications = ?,
                        default_privacy_level = ?, allow_schedule_details = ?, enable_gantt_chart = ?, enable_task_dependency = ?,
                        updated_at = ?, version = ?
                WHERE id = ? AND version = ?
        `

        oldVersion := group.Version - 1

        result, err := r.db.ExecContext(ctx, query,
                group.Name,
                group.Description,
                group.MemberCount,
                group.Settings.IsPublic,
                group.Settings.AllowMemberInvite,
                group.Settings.RequireApproval,
                group.Settings.EnableNotifications,
                group.Settings.DefaultPrivacyLevel,
                group.Settings.AllowScheduleDetails,
                group.Settings.EnableGanttChart,
                group.Settings.EnableTaskDependency,
                group.UpdatedAt,
                group.Version,
                group.ID.String(),
                oldVersion,
        )

        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to update group", logger.Error(err))
                return fmt.Errorf("failed to update group: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get affected rows: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("group not found or version conflict")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteGroup はグループを削除する
func (r *GroupRepository) DeleteGroup(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        tx, err := r.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // メンバーを削除
        _, err = tx.ExecContext(ctx, "DELETE FROM group_members WHERE group_id = ?", id.String())
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to delete group members", logger.Error(err))
                return fmt.Errorf("failed to delete group members: %w", err)
        }</span>

        // グループを削除
        <span class="cov0" title="0">_, err = tx.ExecContext(ctx, "DELETE FROM groups WHERE id = ?", id.String())
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to delete group", logger.Error(err))
                return fmt.Errorf("failed to delete group: %w", err)
        }</span>

        <span class="cov0" title="0">return tx.Commit()</span>
}

// ListGroupsByOwner はオーナーでグループを検索する
func (r *GroupRepository) ListGroupsByOwner(ctx context.Context, ownerID uuid.UUID, pagination commonDomain.Pagination) ([]*domain.Group, int, error) <span class="cov0" title="0">{
        // 総数を取得
        countQuery := "SELECT COUNT(*) FROM groups WHERE owner_id = ?"
        var total int
        err := r.db.QueryRowContext(ctx, countQuery, ownerID.String()).Scan(&amp;total)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to count groups by owner", logger.Error(err))
                return nil, 0, fmt.Errorf("failed to count groups: %w", err)
        }</span>

        // データを取得
        <span class="cov0" title="0">offset := (pagination.Page - 1) * pagination.PageSize
        query := `
                SELECT id, name, description, type, owner_id, settings, member_count, created_at, updated_at, version
                FROM groups
                WHERE owner_id = ?
                ORDER BY created_at DESC
                LIMIT ? OFFSET ?
        `

        rows, err := r.db.QueryContext(ctx, query, ownerID.String(), pagination.PageSize, offset)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to list groups by owner", logger.Error(err))
                return nil, 0, fmt.Errorf("failed to list groups: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        groups, err := r.scanGroups(rows)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return groups, total, nil</span>
}

// ListGroupsByMember はメンバーでグループを検索する
func (r *GroupRepository) ListGroupsByMember(ctx context.Context, userID uuid.UUID, pagination commonDomain.Pagination) ([]*domain.Group, int, error) <span class="cov0" title="0">{
        // 総数を取得
        countQuery := `
                SELECT COUNT(*)
                FROM groups g
                INNER JOIN group_members gm ON g.id = gm.group_id
                WHERE gm.user_id = ?
        `
        var total int
        err := r.db.QueryRowContext(ctx, countQuery, userID.String()).Scan(&amp;total)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to count groups by member", logger.Error(err))
                return nil, 0, fmt.Errorf("failed to count groups: %w", err)
        }</span>

        // データを取得
        <span class="cov0" title="0">offset := (pagination.Page - 1) * pagination.PageSize
        query := `
                SELECT g.id, g.name, g.description, g.type, g.owner_id, g.settings, g.member_count, g.created_at, g.updated_at, g.version
                FROM groups g
                INNER JOIN group_members gm ON g.id = gm.group_id
                WHERE gm.user_id = ?
                ORDER BY g.created_at DESC
                LIMIT ? OFFSET ?
        `

        rows, err := r.db.QueryContext(ctx, query, userID.String(), pagination.PageSize, offset)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to list groups by member", logger.Error(err))
                return nil, 0, fmt.Errorf("failed to list groups: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        groups, err := r.scanGroups(rows)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return groups, total, nil</span>
}

// SearchGroups はグループを検索する
func (r *GroupRepository) SearchGroups(ctx context.Context, query string, groupType *domain.GroupType, pagination commonDomain.Pagination) ([]*domain.Group, int, error) <span class="cov0" title="0">{
        // 条件構築
        conditions := []string{"(g.name LIKE ? OR g.description LIKE ?)"}
        args := []interface{}{"%" + query + "%", "%" + query + "%"}

        if groupType != nil </span><span class="cov0" title="0">{
                conditions = append(conditions, "g.type = ?")
                args = append(args, string(*groupType))
        }</span>

        <span class="cov0" title="0">whereClause := "WHERE " + strings.Join(conditions, " AND ")

        // 総数を取得
        countQuery := fmt.Sprintf("SELECT COUNT(*) FROM groups g %s", whereClause)
        var total int
        err := r.db.QueryRowContext(ctx, countQuery, args...).Scan(&amp;total)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to count search results", logger.Error(err))
                return nil, 0, fmt.Errorf("failed to count search results: %w", err)
        }</span>

        // データを取得
        <span class="cov0" title="0">offset := (pagination.Page - 1) * pagination.PageSize
        searchQuery := fmt.Sprintf(`
                SELECT g.id, g.name, g.description, g.type, g.owner_id, g.settings, g.member_count, g.created_at, g.updated_at, g.version
                FROM groups g
                %s
                ORDER BY g.created_at DESC
                LIMIT ? OFFSET ?
        `, whereClause)

        args = append(args, pagination.PageSize, offset)

        rows, err := r.db.QueryContext(ctx, searchQuery, args...)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to search groups", logger.Error(err))
                return nil, 0, fmt.Errorf("failed to search groups: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        groups, err := r.scanGroups(rows)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return groups, total, nil</span>
}

// AddMember はメンバーを追加する
func (r *GroupRepository) AddMember(ctx context.Context, member *domain.GroupMember) error <span class="cov0" title="0">{
        query := `
                INSERT INTO group_members (id, group_id, user_id, role, joined_at, updated_at)
                VALUES (?, ?, ?, ?, ?, ?)
        `

        _, err := r.db.ExecContext(ctx, query,
                member.ID.String(),
                member.GroupID.String(),
                member.UserID.String(),
                string(member.Role),
                member.JoinedAt,
                member.UpdatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to add member", logger.Error(err))
                return fmt.Errorf("failed to add member: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetMember はメンバーを取得する
func (r *GroupRepository) GetMember(ctx context.Context, groupID, userID uuid.UUID) (*domain.GroupMember, error) <span class="cov0" title="0">{
        query := `
                SELECT id, group_id, user_id, role, joined_at, updated_at
                FROM group_members
                WHERE group_id = ? AND user_id = ?
        `

        var member domain.GroupMember
        var idStr, groupIDStr, userIDStr string

        err := r.db.QueryRowContext(ctx, query, groupID.String(), userID.String()).Scan(
                &amp;idStr,
                &amp;groupIDStr,
                &amp;userIDStr,
                (*string)(&amp;member.Role),
                &amp;member.JoinedAt,
                &amp;member.UpdatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">r.logger.Error("Failed to get member", logger.Error(err))
                return nil, fmt.Errorf("failed to get member: %w", err)</span>
        }

        <span class="cov0" title="0">member.ID, _ = uuid.Parse(idStr)
        member.GroupID, _ = uuid.Parse(groupIDStr)
        member.UserID, _ = uuid.Parse(userIDStr)

        return &amp;member, nil</span>
}

// UpdateMemberRole はメンバーの権限を更新する
func (r *GroupRepository) UpdateMemberRole(ctx context.Context, groupID, userID uuid.UUID, role domain.MemberRole) error <span class="cov0" title="0">{
        query := `
                UPDATE group_members
                SET role = ?, updated_at = ?
                WHERE group_id = ? AND user_id = ?
        `

        _, err := r.db.ExecContext(ctx, query,
                string(role),
                sql.Named("updated_at", "NOW()"),
                groupID.String(),
                userID.String(),
        )

        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to update member role", logger.Error(err))
                return fmt.Errorf("failed to update member role: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RemoveMember はメンバーを削除する
func (r *GroupRepository) RemoveMember(ctx context.Context, groupID, userID uuid.UUID) error <span class="cov0" title="0">{
        query := "DELETE FROM group_members WHERE group_id = ? AND user_id = ?"

        _, err := r.db.ExecContext(ctx, query, groupID.String(), userID.String())
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to remove member", logger.Error(err))
                return fmt.Errorf("failed to remove member: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ListMembers はメンバー一覧を取得する
func (r *GroupRepository) ListMembers(ctx context.Context, groupID uuid.UUID, pagination commonDomain.Pagination) ([]*domain.GroupMember, error) <span class="cov0" title="0">{
        offset := (pagination.Page - 1) * pagination.PageSize
        query := `
                SELECT id, group_id, user_id, role, joined_at, updated_at
                FROM group_members
                WHERE group_id = ?
                ORDER BY joined_at ASC
                LIMIT ? OFFSET ?
        `

        rows, err := r.db.QueryContext(ctx, query, groupID.String(), pagination.PageSize, offset)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to list members", logger.Error(err))
                return nil, fmt.Errorf("failed to list members: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var members []*domain.GroupMember
        for rows.Next() </span><span class="cov0" title="0">{
                var member domain.GroupMember
                var idStr, groupIDStr, userIDStr string

                err := rows.Scan(
                        &amp;idStr,
                        &amp;groupIDStr,
                        &amp;userIDStr,
                        (*string)(&amp;member.Role),
                        &amp;member.JoinedAt,
                        &amp;member.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to scan member", logger.Error(err))
                        return nil, fmt.Errorf("failed to scan member: %w", err)
                }</span>

                <span class="cov0" title="0">member.ID, _ = uuid.Parse(idStr)
                member.GroupID, _ = uuid.Parse(groupIDStr)
                member.UserID, _ = uuid.Parse(userIDStr)

                members = append(members, &amp;member)</span>
        }

        <span class="cov0" title="0">return members, nil</span>
}

// IsMember はメンバーかどうかチェックする
func (r *GroupRepository) IsMember(ctx context.Context, groupID, userID uuid.UUID) (bool, error) <span class="cov0" title="0">{
        query := "SELECT COUNT(*) FROM group_members WHERE group_id = ? AND user_id = ?"

        var count int
        err := r.db.QueryRowContext(ctx, query, groupID.String(), userID.String()).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to check membership", logger.Error(err))
                return false, fmt.Errorf("failed to check membership: %w", err)
        }</span>

        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

// GetMemberRole はメンバーの権限を取得する
func (r *GroupRepository) GetMemberRole(ctx context.Context, groupID, userID uuid.UUID) (domain.MemberRole, error) <span class="cov0" title="0">{
        query := "SELECT role FROM group_members WHERE group_id = ? AND user_id = ?"

        var role string
        err := r.db.QueryRowContext(ctx, query, groupID.String(), userID.String()).Scan(&amp;role)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("member not found")
                }</span>
                <span class="cov0" title="0">r.logger.Error("Failed to get member role", logger.Error(err))
                return "", fmt.Errorf("failed to get member role: %w", err)</span>
        }

        <span class="cov0" title="0">return domain.MemberRole(role), nil</span>
}

// GetMemberCount はメンバー数を取得する
func (r *GroupRepository) GetMemberCount(ctx context.Context, groupID uuid.UUID) (int, error) <span class="cov0" title="0">{
        query := "SELECT COUNT(*) FROM group_members WHERE group_id = ?"

        var count int
        err := r.db.QueryRowContext(ctx, query, groupID.String()).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to get member count", logger.Error(err))
                return 0, fmt.Errorf("failed to get member count: %w", err)
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}

// GetGroupStats はグループ統計情報を取得する
func (r *GroupRepository) GetGroupStats(ctx context.Context, groupID uuid.UUID) (*domain.GroupStats, error) <span class="cov0" title="0">{
        stats := &amp;domain.GroupStats{}

        // メンバー数取得
        memberCount, err := r.GetMemberCount(ctx, groupID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">stats.MemberCount = memberCount

        // TODO: タスク数と予定数の取得は該当するモジュールのリポジトリと連携する必要がある
        // 現在は基本的な統計のみ実装
        stats.ActiveMembers = memberCount // 簡易実装

        return stats, nil</span>
}

// === ヘルパーメソッド ===

func (r *GroupRepository) scanGroups(rows *sql.Rows) ([]*domain.Group, error) <span class="cov0" title="0">{
        var groups []*domain.Group

        for rows.Next() </span><span class="cov0" title="0">{
                var group domain.Group
                var settingsJSON string
                var idStr, ownerIDStr string

                err := rows.Scan(
                        &amp;idStr,
                        &amp;group.Name,
                        &amp;group.Description,
                        (*string)(&amp;group.Type),
                        &amp;ownerIDStr,
                        &amp;settingsJSON,
                        &amp;group.MemberCount,
                        &amp;group.CreatedAt,
                        &amp;group.UpdatedAt,
                        &amp;group.Version,
                )
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to scan group", logger.Error(err))
                        return nil, fmt.Errorf("failed to scan group: %w", err)
                }</span>

                <span class="cov0" title="0">group.ID, _ = uuid.Parse(idStr)
                group.OwnerID, _ = uuid.Parse(ownerIDStr)
                group.Settings = r.decodeGroupSettings(settingsJSON)

                groups = append(groups, &amp;group)</span>
        }

        <span class="cov0" title="0">return groups, nil</span>
}

func (r *GroupRepository) encodeGroupSettings(settings domain.GroupSettings) string <span class="cov0" title="0">{
        // 簡易実装：JSONエンコード（実際の実装では適切なJSONライブラリを使用）
        return fmt.Sprintf(`{
                "is_public": %t,
                "allow_member_invite": %t,
                "require_approval": %t,
                "enable_notifications": %t,
                "default_privacy_level": "%s",
                "allow_schedule_details": %t,
                "enable_gantt_chart": %t,
                "enable_task_dependency": %t
        }`,
                settings.IsPublic,
                settings.AllowMemberInvite,
                settings.RequireApproval,
                settings.EnableNotifications,
                string(settings.DefaultPrivacyLevel),
                settings.AllowScheduleDetails,
                settings.EnableGanttChart,
                settings.EnableTaskDependency,
        )
}</span>

func (r *GroupRepository) decodeGroupSettings(settingsJSON string) domain.GroupSettings <span class="cov0" title="0">{
        // 簡易実装：デフォルト値を返す（実際の実装ではJSONパースを行う）
        return domain.GroupSettings{
                IsPublic:             false,
                AllowMemberInvite:    true,
                RequireApproval:      true,
                EnableNotifications:  true,
                DefaultPrivacyLevel:  domain.PrivacyLevelBusy,
                AllowScheduleDetails: false,
                EnableGanttChart:     true,
                EnableTaskDependency: false,
        }
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package dto

import (
        "time"

        "github.com/google/uuid"
        "github.com/hryt430/Yotei+/internal/modules/group/domain"
        groupUsecase "github.com/hryt430/Yotei+/internal/modules/group/usecase"
)

// === リクエストDTO ===

type CreateGroupRequest struct {
        Name        string               `json:"name" binding:"required,max=100" example:"プロジェクトチーム"`
        Description string               `json:"description" binding:"max=500" example:"新製品開発プロジェクトのチーム"`
        Type        string               `json:"type" binding:"required" enums:"PROJECT,SCHEDULE" example:"PROJECT"`
        Settings    domain.GroupSettings `json:"settings"`
} // @name CreateGroupRequest

type UpdateGroupRequest struct {
        Name        *string               `json:"name,omitempty" binding:"omitempty,max=100" example:"プロジェクトチーム"`
        Description *string               `json:"description,omitempty" binding:"omitempty,max=500" example:"新製品開発プロジェクトのチーム"`
        Settings    *domain.GroupSettings `json:"settings,omitempty"`
} // @name UpdateGroupRequest

type AddMemberRequest struct {
        UserID string `json:"user_id" binding:"required" example:"123e4567-e89b-12d3-a456-426614174000"`
        Role   string `json:"role" enums:"OWNER,ADMIN,MEMBER" example:"MEMBER"`
} // @name AddMemberRequest

type UpdateMemberRoleRequest struct {
        Role string `json:"role" binding:"required" enums:"OWNER,ADMIN,MEMBER" example:"ADMIN"`
} // @name UpdateMemberRoleRequest

// === レスポンスDTO ===

type GroupResponse struct {
        ID          uuid.UUID            `json:"id" example:"123e4567-e89b-12d3-a456-426614174000"`
        Name        string               `json:"name" example:"プロジェクトチーム"`
        Description string               `json:"description" example:"新製品開発プロジェクトのチーム"`
        Type        string               `json:"type" example:"PROJECT"`
        OwnerID     uuid.UUID            `json:"owner_id" example:"123e4567-e89b-12d3-a456-426614174000"`
        Settings    domain.GroupSettings `json:"settings"`
        MemberCount int                  `json:"member_count" example:"5"`
        CreatedAt   time.Time            `json:"created_at" example:"2024-01-01T00:00:00Z"`
        UpdatedAt   time.Time            `json:"updated_at" example:"2024-01-01T00:00:00Z"`
        Version     int                  `json:"version" example:"1"`
} // @name GroupResponse

type GroupWithMembersResponse struct {
        Group   GroupResponse            `json:"group"`
        Members []MemberWithUserResponse `json:"members"`
        MyRole  string                   `json:"my_role" example:"ADMIN"`
} // @name GroupWithMembersResponse

type MemberWithUserResponse struct {
        ID       uuid.UUID `json:"id" example:"123e4567-e89b-12d3-a456-426614174000"`
        GroupID  uuid.UUID `json:"group_id" example:"123e4567-e89b-12d3-a456-426614174000"`
        UserID   uuid.UUID `json:"user_id" example:"123e4567-e89b-12d3-a456-426614174000"`
        Role     string    `json:"role" example:"MEMBER"`
        JoinedAt time.Time `json:"joined_at" example:"2024-01-01T00:00:00Z"`
        UserInfo *UserInfo `json:"user_info,omitempty"`
} // @name MemberWithUserResponse

type GroupListResponse struct {
        Groups     []GroupResponse `json:"groups"`
        Pagination PaginationInfo  `json:"pagination"`
} // @name GroupListResponse

type MemberListResponse struct {
        Members []MemberWithUserResponse `json:"members"`
} // @name MemberListResponse

type GroupStatsResponse struct {
        MemberCount   int `json:"member_count" example:"5"`
        TaskCount     int `json:"task_count,omitempty" example:"10"`
        ScheduleCount int `json:"schedule_count,omitempty" example:"3"`
        ActiveMembers int `json:"active_members" example:"4"`
} // @name GroupStatsResponse

type PaginationInfo struct {
        Page       int `json:"page" example:"1"`
        PageSize   int `json:"page_size" example:"10"`
        Total      int `json:"total" example:"100"`
        TotalPages int `json:"total_pages" example:"10"`
} // @name PaginationInfo

// UserInfo はユーザー基本情報
type UserInfo struct {
        ID       string `json:"id" example:"123e4567-e89b-12d3-a456-426614174000"`
        Username string `json:"username" example:"user123"`
        Email    string `json:"email" example:"user@example.com"`
} // @name UserInfo

// === 変換関数 ===

func ToGroupResponse(group *domain.Group) *GroupResponse <span class="cov0" title="0">{
        return &amp;GroupResponse{
                ID:          group.ID,
                Name:        group.Name,
                Description: group.Description,
                Type:        string(group.Type),
                OwnerID:     group.OwnerID,
                Settings:    group.Settings,
                MemberCount: group.MemberCount,
                CreatedAt:   group.CreatedAt,
                UpdatedAt:   group.UpdatedAt,
                Version:     group.Version,
        }
}</span>

func ToGroupWithMembersResponse(groupWithMembers *groupUsecase.GroupWithMembers) *GroupWithMembersResponse <span class="cov0" title="0">{
        groupResp := ToGroupResponse(groupWithMembers.Group)

        members := make([]MemberWithUserResponse, len(groupWithMembers.Members))
        for i, member := range groupWithMembers.Members </span><span class="cov0" title="0">{
                var userInfo *UserInfo
                if member.UserInfo != nil </span><span class="cov0" title="0">{
                        userInfo = &amp;UserInfo{
                                ID:       member.UserInfo.ID,
                                Username: member.UserInfo.Username,
                                Email:    member.UserInfo.Email,
                        }
                }</span>
                <span class="cov0" title="0">members[i] = MemberWithUserResponse{
                        ID:       member.Member.ID,
                        GroupID:  member.Member.GroupID,
                        UserID:   member.Member.UserID,
                        Role:     string(member.Member.Role),
                        JoinedAt: member.Member.JoinedAt,
                        UserInfo: userInfo,
                }</span>
        }

        <span class="cov0" title="0">return &amp;GroupWithMembersResponse{
                Group:   *groupResp,
                Members: members,
                MyRole:  string(groupWithMembers.MyRole),
        }</span>
}

func ToGroupListResponse(groups []*domain.Group, total, page, pageSize int) *GroupListResponse <span class="cov0" title="0">{
        groupResponses := make([]GroupResponse, len(groups))
        for i, group := range groups </span><span class="cov0" title="0">{
                groupResponses[i] = *ToGroupResponse(group)
        }</span>

        <span class="cov0" title="0">totalPages := total / pageSize
        if total%pageSize &gt; 0 </span><span class="cov0" title="0">{
                totalPages++
        }</span>

        <span class="cov0" title="0">return &amp;GroupListResponse{
                Groups: groupResponses,
                Pagination: PaginationInfo{
                        Page:       page,
                        PageSize:   pageSize,
                        Total:      total,
                        TotalPages: totalPages,
                },
        }</span>
}

func ToMemberListResponse(members []*groupUsecase.MemberWithUserInfo) *MemberListResponse <span class="cov0" title="0">{
        memberResponses := make([]MemberWithUserResponse, len(members))
        for i, member := range members </span><span class="cov0" title="0">{
                var userInfo *UserInfo
                if member.UserInfo != nil </span><span class="cov0" title="0">{
                        userInfo = &amp;UserInfo{
                                ID:       member.UserInfo.ID,
                                Username: member.UserInfo.Username,
                                Email:    member.UserInfo.Email,
                        }
                }</span>
                <span class="cov0" title="0">memberResponses[i] = MemberWithUserResponse{
                        ID:       member.Member.ID,
                        GroupID:  member.Member.GroupID,
                        UserID:   member.Member.UserID,
                        Role:     string(member.Member.Role),
                        JoinedAt: member.Member.JoinedAt,
                        UserInfo: userInfo,
                }</span>
        }

        <span class="cov0" title="0">return &amp;MemberListResponse{
                Members: memberResponses,
        }</span>
}

func ToGroupStatsResponse(stats *domain.GroupStats) *GroupStatsResponse <span class="cov0" title="0">{
        return &amp;GroupStatsResponse{
                MemberCount:   stats.MemberCount,
                TaskCount:     stats.TaskCount,
                ScheduleCount: stats.ScheduleCount,
                ActiveMembers: stats.ActiveMembers,
        }
}</span>

// === 共通レスポンス ===

// SuccessResponse は成功レスポンス構造体
type SuccessResponse struct {
        Success bool   `json:"success" example:"true"`
        Message string `json:"message" example:"操作が正常に完了しました"`
} // @name SuccessResponse

// ErrorResponse はエラーレスポンス構造体
type ErrorResponse struct {
        Success bool   `json:"success" example:"false"`
        Error   string `json:"error" example:"INVALID_REQUEST"`
        Message string `json:"message" example:"リクエストが無効です"`
} // @name ErrorResponse
</pre>
		
		<pre class="file" id="file21" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/hryt430/Yotei+/internal/modules/group/usecase (interfaces: GroupRepository)

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        uuid "github.com/google/uuid"
        domain "github.com/hryt430/Yotei+/internal/common/domain"
        domain0 "github.com/hryt430/Yotei+/internal/modules/group/domain"
)


// MockGroupRepository is a mock of GroupRepository interface.
type MockGroupRepository struct {
        ctrl     *gomock.Controller
        recorder *MockGroupRepositoryMockRecorder
}

// MockGroupRepositoryMockRecorder is the mock recorder for MockGroupRepository.
type MockGroupRepositoryMockRecorder struct {
        mock *MockGroupRepository
}

// NewMockGroupRepository creates a new mock instance.
func NewMockGroupRepository(ctrl *gomock.Controller) *MockGroupRepository <span class="cov0" title="0">{
        mock := &amp;MockGroupRepository{ctrl: ctrl}
        mock.recorder = &amp;MockGroupRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGroupRepository) EXPECT() *MockGroupRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// AddMember mocks base method.
func (m *MockGroupRepository) AddMember(arg0 context.Context, arg1 *domain0.GroupMember) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AddMember", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// AddMember indicates an expected call of AddMember.
func (mr *MockGroupRepositoryMockRecorder) AddMember(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddMember", reflect.TypeOf((*MockGroupRepository)(nil).AddMember), arg0, arg1)
}</span>

// CreateGroup mocks base method.
func (m *MockGroupRepository) CreateGroup(arg0 context.Context, arg1 *domain0.Group) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateGroup", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CreateGroup indicates an expected call of CreateGroup.
func (mr *MockGroupRepositoryMockRecorder) CreateGroup(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateGroup", reflect.TypeOf((*MockGroupRepository)(nil).CreateGroup), arg0, arg1)
}</span>

// DeleteGroup mocks base method.
func (m *MockGroupRepository) DeleteGroup(arg0 context.Context, arg1 uuid.UUID) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteGroup", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteGroup indicates an expected call of DeleteGroup.
func (mr *MockGroupRepositoryMockRecorder) DeleteGroup(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteGroup", reflect.TypeOf((*MockGroupRepository)(nil).DeleteGroup), arg0, arg1)
}</span>

// GetGroupByID mocks base method.
func (m *MockGroupRepository) GetGroupByID(arg0 context.Context, arg1 uuid.UUID) (*domain0.Group, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetGroupByID", arg0, arg1)
        ret0, _ := ret[0].(*domain0.Group)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetGroupByID indicates an expected call of GetGroupByID.
func (mr *MockGroupRepositoryMockRecorder) GetGroupByID(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetGroupByID", reflect.TypeOf((*MockGroupRepository)(nil).GetGroupByID), arg0, arg1)
}</span>

// GetGroupStats mocks base method.
func (m *MockGroupRepository) GetGroupStats(arg0 context.Context, arg1 uuid.UUID) (*domain0.GroupStats, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetGroupStats", arg0, arg1)
        ret0, _ := ret[0].(*domain0.GroupStats)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetGroupStats indicates an expected call of GetGroupStats.
func (mr *MockGroupRepositoryMockRecorder) GetGroupStats(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetGroupStats", reflect.TypeOf((*MockGroupRepository)(nil).GetGroupStats), arg0, arg1)
}</span>

// GetMember mocks base method.
func (m *MockGroupRepository) GetMember(arg0 context.Context, arg1, arg2 uuid.UUID) (*domain0.GroupMember, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetMember", arg0, arg1, arg2)
        ret0, _ := ret[0].(*domain0.GroupMember)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetMember indicates an expected call of GetMember.
func (mr *MockGroupRepositoryMockRecorder) GetMember(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMember", reflect.TypeOf((*MockGroupRepository)(nil).GetMember), arg0, arg1, arg2)
}</span>

// GetMemberCount mocks base method.
func (m *MockGroupRepository) GetMemberCount(arg0 context.Context, arg1 uuid.UUID) (int, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetMemberCount", arg0, arg1)
        ret0, _ := ret[0].(int)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetMemberCount indicates an expected call of GetMemberCount.
func (mr *MockGroupRepositoryMockRecorder) GetMemberCount(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMemberCount", reflect.TypeOf((*MockGroupRepository)(nil).GetMemberCount), arg0, arg1)
}</span>

// GetMemberRole mocks base method.
func (m *MockGroupRepository) GetMemberRole(arg0 context.Context, arg1, arg2 uuid.UUID) (domain0.MemberRole, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetMemberRole", arg0, arg1, arg2)
        ret0, _ := ret[0].(domain0.MemberRole)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetMemberRole indicates an expected call of GetMemberRole.
func (mr *MockGroupRepositoryMockRecorder) GetMemberRole(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMemberRole", reflect.TypeOf((*MockGroupRepository)(nil).GetMemberRole), arg0, arg1, arg2)
}</span>

// IsMember mocks base method.
func (m *MockGroupRepository) IsMember(arg0 context.Context, arg1, arg2 uuid.UUID) (bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "IsMember", arg0, arg1, arg2)
        ret0, _ := ret[0].(bool)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// IsMember indicates an expected call of IsMember.
func (mr *MockGroupRepositoryMockRecorder) IsMember(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsMember", reflect.TypeOf((*MockGroupRepository)(nil).IsMember), arg0, arg1, arg2)
}</span>

// ListGroupsByMember mocks base method.
func (m *MockGroupRepository) ListGroupsByMember(arg0 context.Context, arg1 uuid.UUID, arg2 domain.Pagination) ([]*domain0.Group, int, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListGroupsByMember", arg0, arg1, arg2)
        ret0, _ := ret[0].([]*domain0.Group)
        ret1, _ := ret[1].(int)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// ListGroupsByMember indicates an expected call of ListGroupsByMember.
func (mr *MockGroupRepositoryMockRecorder) ListGroupsByMember(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListGroupsByMember", reflect.TypeOf((*MockGroupRepository)(nil).ListGroupsByMember), arg0, arg1, arg2)
}</span>

// ListGroupsByOwner mocks base method.
func (m *MockGroupRepository) ListGroupsByOwner(arg0 context.Context, arg1 uuid.UUID, arg2 domain.Pagination) ([]*domain0.Group, int, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListGroupsByOwner", arg0, arg1, arg2)
        ret0, _ := ret[0].([]*domain0.Group)
        ret1, _ := ret[1].(int)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// ListGroupsByOwner indicates an expected call of ListGroupsByOwner.
func (mr *MockGroupRepositoryMockRecorder) ListGroupsByOwner(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListGroupsByOwner", reflect.TypeOf((*MockGroupRepository)(nil).ListGroupsByOwner), arg0, arg1, arg2)
}</span>

// ListMembers mocks base method.
func (m *MockGroupRepository) ListMembers(arg0 context.Context, arg1 uuid.UUID, arg2 domain.Pagination) ([]*domain0.GroupMember, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListMembers", arg0, arg1, arg2)
        ret0, _ := ret[0].([]*domain0.GroupMember)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListMembers indicates an expected call of ListMembers.
func (mr *MockGroupRepositoryMockRecorder) ListMembers(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListMembers", reflect.TypeOf((*MockGroupRepository)(nil).ListMembers), arg0, arg1, arg2)
}</span>

// RemoveMember mocks base method.
func (m *MockGroupRepository) RemoveMember(arg0 context.Context, arg1, arg2 uuid.UUID) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RemoveMember", arg0, arg1, arg2)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// RemoveMember indicates an expected call of RemoveMember.
func (mr *MockGroupRepositoryMockRecorder) RemoveMember(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveMember", reflect.TypeOf((*MockGroupRepository)(nil).RemoveMember), arg0, arg1, arg2)
}</span>

// SearchGroups mocks base method.
func (m *MockGroupRepository) SearchGroups(arg0 context.Context, arg1 string, arg2 *domain0.GroupType, arg3 domain.Pagination) ([]*domain0.Group, int, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SearchGroups", arg0, arg1, arg2, arg3)
        ret0, _ := ret[0].([]*domain0.Group)
        ret1, _ := ret[1].(int)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// SearchGroups indicates an expected call of SearchGroups.
func (mr *MockGroupRepositoryMockRecorder) SearchGroups(arg0, arg1, arg2, arg3 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SearchGroups", reflect.TypeOf((*MockGroupRepository)(nil).SearchGroups), arg0, arg1, arg2, arg3)
}</span>

// UpdateGroup mocks base method.
func (m *MockGroupRepository) UpdateGroup(arg0 context.Context, arg1 *domain0.Group) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateGroup", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateGroup indicates an expected call of UpdateGroup.
func (mr *MockGroupRepositoryMockRecorder) UpdateGroup(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateGroup", reflect.TypeOf((*MockGroupRepository)(nil).UpdateGroup), arg0, arg1)
}</span>

// UpdateMemberRole mocks base method.
func (m *MockGroupRepository) UpdateMemberRole(arg0 context.Context, arg1, arg2 uuid.UUID, arg3 domain0.MemberRole) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateMemberRole", arg0, arg1, arg2, arg3)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateMemberRole indicates an expected call of UpdateMemberRole.
func (mr *MockGroupRepositoryMockRecorder) UpdateMemberRole(arg0, arg1, arg2, arg3 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateMemberRole", reflect.TypeOf((*MockGroupRepository)(nil).UpdateMemberRole), arg0, arg1, arg2, arg3)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/hryt430/Yotei+/internal/common/domain (interfaces: UserValidator)

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        domain "github.com/hryt430/Yotei+/internal/common/domain"
)

// MockUserValidator is a mock of UserValidator interface.
type MockUserValidator struct {
        ctrl     *gomock.Controller
        recorder *MockUserValidatorMockRecorder
}

// MockUserValidatorMockRecorder is the mock recorder for MockUserValidator.
type MockUserValidatorMockRecorder struct {
        mock *MockUserValidator
}

// NewMockUserValidator creates a new mock instance.
func NewMockUserValidator(ctrl *gomock.Controller) *MockUserValidator <span class="cov0" title="0">{
        mock := &amp;MockUserValidator{ctrl: ctrl}
        mock.recorder = &amp;MockUserValidatorMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserValidator) EXPECT() *MockUserValidatorMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetUserInfo mocks base method.
func (m *MockUserValidator) GetUserInfo(arg0 context.Context, arg1 string) (*domain.UserInfo, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUserInfo", arg0, arg1)
        ret0, _ := ret[0].(*domain.UserInfo)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUserInfo indicates an expected call of GetUserInfo.
func (mr *MockUserValidatorMockRecorder) GetUserInfo(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserInfo", reflect.TypeOf((*MockUserValidator)(nil).GetUserInfo), arg0, arg1)
}</span>

// GetUsersInfoBatch mocks base method.
func (m *MockUserValidator) GetUsersInfoBatch(arg0 context.Context, arg1 []string) (map[string]*domain.UserInfo, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUsersInfoBatch", arg0, arg1)
        ret0, _ := ret[0].(map[string]*domain.UserInfo)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUsersInfoBatch indicates an expected call of GetUsersInfoBatch.
func (mr *MockUserValidatorMockRecorder) GetUsersInfoBatch(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUsersInfoBatch", reflect.TypeOf((*MockUserValidator)(nil).GetUsersInfoBatch), arg0, arg1)
}</span>

// UserExists mocks base method.
func (m *MockUserValidator) UserExists(arg0 context.Context, arg1 string) (bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UserExists", arg0, arg1)
        ret0, _ := ret[0].(bool)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UserExists indicates an expected call of UserExists.
func (mr *MockUserValidatorMockRecorder) UserExists(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UserExists", reflect.TypeOf((*MockUserValidator)(nil).UserExists), arg0, arg1)
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package usecase

import (
        "context"
        "errors"
        "fmt"

        "github.com/google/uuid"
        commonDomain "github.com/hryt430/Yotei+/internal/common/domain"
        "github.com/hryt430/Yotei+/internal/modules/group/domain"
        "github.com/hryt430/Yotei+/pkg/logger"
)

type groupService struct {
        groupRepo     GroupRepository
        userValidator commonDomain.UserValidator
        logger        *logger.Logger
}

func NewGroupService(
        groupRepo GroupRepository,
        userValidator commonDomain.UserValidator,
        logger *logger.Logger,
) GroupService <span class="cov8" title="1">{
        return &amp;groupService{
                groupRepo:     groupRepo,
                userValidator: userValidator,
                logger:        logger,
        }
}</span>

// CreateGroup はグループを作成する
func (s *groupService) CreateGroup(ctx context.Context, input CreateGroupInput) (*domain.Group, error) <span class="cov8" title="1">{
        // 入力バリデーション
        if err := s.validateCreateGroupInput(input); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid input: %w", err)
        }</span>

        // オーナーIDを入力から取得（修正）
        <span class="cov8" title="1">ownerID := input.OwnerID

        exists, err := s.userValidator.UserExists(ctx, ownerID.String())
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error("Failed to validate owner existence", logger.Error(err))
                return nil, fmt.Errorf("failed to validate owner: %w", err)
        }</span>
        <span class="cov8" title="1">if !exists </span><span class="cov8" title="1">{
                return nil, errors.New("owner not found")
        }</span>

        // グループ作成
        <span class="cov8" title="1">group := domain.NewGroup(input.Name, input.Description, input.Type, ownerID)
        group.UpdateSettings(input.Settings)

        err = s.groupRepo.CreateGroup(ctx, group)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error("Failed to create group", logger.Error(err))
                return nil, fmt.Errorf("failed to create group: %w", err)
        }</span>

        <span class="cov8" title="1">s.logger.Info("Group created successfully", logger.Any("groupID", group.ID))
        return group, nil</span>
}

// GetGroup はグループ詳細を取得する
func (s *groupService) GetGroup(ctx context.Context, groupID uuid.UUID, requesterID uuid.UUID) (*GroupWithMembers, error) <span class="cov8" title="1">{
        // グループ取得
        group, err := s.groupRepo.GetGroupByID(ctx, groupID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get group: %w", err)
        }</span>
        <span class="cov8" title="1">if group == nil </span><span class="cov8" title="1">{
                return nil, errors.New("group not found")
        }</span>

        // メンバーシップ確認
        <span class="cov8" title="1">isMember, err := s.groupRepo.IsMember(ctx, groupID, requesterID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check membership: %w", err)
        }</span>
        <span class="cov8" title="1">if !isMember &amp;&amp; !group.Settings.IsPublic </span><span class="cov8" title="1">{
                return nil, errors.New("access denied")
        }</span>

        // リクエスターの権限取得
        <span class="cov8" title="1">var myRole domain.MemberRole
        if isMember </span><span class="cov8" title="1">{
                myRole, err = s.groupRepo.GetMemberRole(ctx, groupID, requesterID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get member role: %w", err)
                }</span>
        }

        // メンバー一覧取得
        <span class="cov8" title="1">pagination := commonDomain.Pagination{Page: 1, PageSize: 100}
        members, err := s.groupRepo.ListMembers(ctx, groupID, pagination)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get members: %w", err)
        }</span>

        // ユーザー情報を一括取得
        <span class="cov8" title="1">memberWithUserInfo, err := s.enrichMembersWithUserInfo(ctx, members)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to enrich members with user info", logger.Error(err))
                // エラーでも継続（ユーザー情報なしで返す）
                memberWithUserInfo = make([]*MemberWithUserInfo, len(members))
                for i, member := range members </span><span class="cov0" title="0">{
                        memberWithUserInfo[i] = &amp;MemberWithUserInfo{
                                Member:   member,
                                UserInfo: nil,
                        }
                }</span>
        }

        <span class="cov8" title="1">return &amp;GroupWithMembers{
                Group:   group,
                Members: memberWithUserInfo,
                MyRole:  myRole,
        }, nil</span>
}

// UpdateGroup はグループ情報を更新する
func (s *groupService) UpdateGroup(ctx context.Context, groupID uuid.UUID, input UpdateGroupInput, requesterID uuid.UUID) (*domain.Group, error) <span class="cov8" title="1">{
        // 権限チェック
        hasPermission, err := s.CheckPermission(ctx, groupID, requesterID, ActionEditGroup)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check permission: %w", err)
        }</span>
        <span class="cov8" title="1">if !hasPermission </span><span class="cov8" title="1">{
                return nil, errors.New("insufficient permissions")
        }</span>

        // グループ取得
        <span class="cov8" title="1">group, err := s.groupRepo.GetGroupByID(ctx, groupID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get group: %w", err)
        }</span>
        <span class="cov8" title="1">if group == nil </span><span class="cov0" title="0">{
                return nil, errors.New("group not found")
        }</span>

        // 更新適用
        <span class="cov8" title="1">hasChanges := false
        if input.Name != nil &amp;&amp; *input.Name != group.Name </span><span class="cov8" title="1">{
                group.Name = *input.Name
                hasChanges = true
        }</span>
        <span class="cov8" title="1">if input.Description != nil &amp;&amp; *input.Description != group.Description </span><span class="cov8" title="1">{
                group.Description = *input.Description
                hasChanges = true
        }</span>
        <span class="cov8" title="1">if input.Settings != nil </span><span class="cov8" title="1">{
                group.UpdateSettings(*input.Settings)
                hasChanges = true
        }</span>

        <span class="cov8" title="1">if !hasChanges </span><span class="cov8" title="1">{
                return group, nil
        }</span>

        // 更新実行
        <span class="cov8" title="1">err = s.groupRepo.UpdateGroup(ctx, group)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to update group", logger.Error(err))
                return nil, fmt.Errorf("failed to update group: %w", err)
        }</span>

        <span class="cov8" title="1">s.logger.Info("Group updated successfully", logger.Any("groupID", groupID))
        return group, nil</span>
}

// DeleteGroup はグループを削除する
func (s *groupService) DeleteGroup(ctx context.Context, groupID uuid.UUID, requesterID uuid.UUID) error <span class="cov8" title="1">{
        // 権限チェック（オーナーのみ）
        group, err := s.groupRepo.GetGroupByID(ctx, groupID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get group: %w", err)
        }</span>
        <span class="cov8" title="1">if group == nil </span><span class="cov8" title="1">{
                return errors.New("group not found")
        }</span>
        <span class="cov8" title="1">if group.OwnerID != requesterID </span><span class="cov8" title="1">{
                return errors.New("only owner can delete group")
        }</span>

        // 削除実行
        <span class="cov8" title="1">err = s.groupRepo.DeleteGroup(ctx, groupID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to delete group", logger.Error(err))
                return fmt.Errorf("failed to delete group: %w", err)
        }</span>

        <span class="cov8" title="1">s.logger.Info("Group deleted successfully", logger.Any("groupID", groupID))
        return nil</span>
}

// GetMyGroups は自分のグループ一覧を取得する
func (s *groupService) GetMyGroups(ctx context.Context, userID uuid.UUID, groupType *domain.GroupType, pagination commonDomain.Pagination) ([]*domain.Group, int, error) <span class="cov8" title="1">{
        // オーナーのグループ取得
        ownedGroups, ownedTotal, err := s.groupRepo.ListGroupsByOwner(ctx, userID, pagination)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get owned groups", logger.Error(err))
                return nil, 0, fmt.Errorf("failed to get owned groups: %w", err)
        }</span>

        // メンバーのグループ取得
        <span class="cov8" title="1">memberGroups, memberTotal, err := s.groupRepo.ListGroupsByMember(ctx, userID, pagination)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get member groups", logger.Error(err))
                return nil, 0, fmt.Errorf("failed to get member groups: %w", err)
        }</span>

        // 重複除去してマージ
        <span class="cov8" title="1">groupMap := make(map[uuid.UUID]*domain.Group)
        for _, group := range ownedGroups </span><span class="cov8" title="1">{
                if groupType == nil || group.Type == *groupType </span><span class="cov8" title="1">{
                        groupMap[group.ID] = group
                }</span>
        }
        <span class="cov8" title="1">for _, group := range memberGroups </span><span class="cov8" title="1">{
                if groupType == nil || group.Type == *groupType </span><span class="cov8" title="1">{
                        groupMap[group.ID] = group
                }</span>
        }

        // 結果をスライスに変換
        <span class="cov8" title="1">groups := make([]*domain.Group, 0, len(groupMap))
        for _, group := range groupMap </span><span class="cov8" title="1">{
                groups = append(groups, group)
        }</span>

        <span class="cov8" title="1">total := ownedTotal + memberTotal
        return groups, total, nil</span>
}

// SearchGroups はグループを検索する
func (s *groupService) SearchGroups(ctx context.Context, query string, groupType *domain.GroupType, pagination commonDomain.Pagination) ([]*domain.Group, int, error) <span class="cov0" title="0">{
        groups, total, err := s.groupRepo.SearchGroups(ctx, query, groupType, pagination)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to search groups", logger.Error(err))
                return nil, 0, fmt.Errorf("failed to search groups: %w", err)
        }</span>

        <span class="cov0" title="0">return groups, total, nil</span>
}

// AddMember はメンバーを追加する
func (s *groupService) AddMember(ctx context.Context, groupID, userID, inviterID uuid.UUID, role domain.MemberRole) error <span class="cov8" title="1">{
        // 権限チェック
        hasPermission, err := s.CheckPermission(ctx, groupID, inviterID, ActionInviteMembers)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check permission: %w", err)
        }</span>
        <span class="cov8" title="1">if !hasPermission </span><span class="cov8" title="1">{
                return errors.New("insufficient permissions")
        }</span>

        // ユーザー存在確認
        <span class="cov8" title="1">exists, err := s.userValidator.UserExists(ctx, userID.String())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to validate user: %w", err)
        }</span>
        <span class="cov8" title="1">if !exists </span><span class="cov0" title="0">{
                return errors.New("user not found")
        }</span>

        // 既にメンバーかチェック
        <span class="cov8" title="1">isMember, err := s.groupRepo.IsMember(ctx, groupID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check membership: %w", err)
        }</span>
        <span class="cov8" title="1">if isMember </span><span class="cov8" title="1">{
                return errors.New("user is already a member")
        }</span>

        // メンバー追加
        <span class="cov8" title="1">member := domain.NewGroupMember(groupID, userID, role)
        err = s.groupRepo.AddMember(ctx, member)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to add member", logger.Error(err))
                return fmt.Errorf("failed to add member: %w", err)
        }</span>

        // グループのメンバー数更新
        <span class="cov8" title="1">group, err := s.groupRepo.GetGroupByID(ctx, groupID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get group for member count update: %w", err)
        }</span>
        <span class="cov8" title="1">group.AddMember()
        err = s.groupRepo.UpdateGroup(ctx, group)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to update group member count", logger.Error(err))
        }</span>

        <span class="cov8" title="1">s.logger.Info("Member added successfully",
                logger.Any("groupID", groupID),
                logger.Any("userID", userID))
        return nil</span>
}

// RemoveMember はメンバーを削除する
func (s *groupService) RemoveMember(ctx context.Context, groupID, userID, requesterID uuid.UUID) error <span class="cov8" title="1">{
        // 権限チェック
        hasPermission, err := s.CheckPermission(ctx, groupID, requesterID, ActionRemoveMembers)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check permission: %w", err)
        }</span>
        <span class="cov8" title="1">if !hasPermission &amp;&amp; requesterID != userID </span><span class="cov0" title="0">{
                return errors.New("insufficient permissions")
        }</span>

        // メンバー削除
        <span class="cov8" title="1">err = s.groupRepo.RemoveMember(ctx, groupID, userID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to remove member", logger.Error(err))
                return fmt.Errorf("failed to remove member: %w", err)
        }</span>

        // グループのメンバー数更新
        <span class="cov8" title="1">group, err := s.groupRepo.GetGroupByID(ctx, groupID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get group for member count update: %w", err)
        }</span>
        <span class="cov8" title="1">err = group.RemoveMember()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update group member count: %w", err)
        }</span>
        <span class="cov8" title="1">err = s.groupRepo.UpdateGroup(ctx, group)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to update group member count", logger.Error(err))
        }</span>

        <span class="cov8" title="1">s.logger.Info("Member removed successfully",
                logger.Any("groupID", groupID),
                logger.Any("userID", userID))
        return nil</span>
}

// UpdateMemberRole はメンバーの権限を変更する
func (s *groupService) UpdateMemberRole(ctx context.Context, groupID, userID, requesterID uuid.UUID, newRole domain.MemberRole) error <span class="cov8" title="1">{
        // 権限チェック
        hasPermission, err := s.CheckPermission(ctx, groupID, requesterID, ActionManageRoles)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check permission: %w", err)
        }</span>
        <span class="cov8" title="1">if !hasPermission </span><span class="cov8" title="1">{
                return errors.New("insufficient permissions")
        }</span>

        // オーナーの変更は不可
        <span class="cov8" title="1">requesterRole, err := s.groupRepo.GetMemberRole(ctx, groupID, requesterID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get requester role: %w", err)
        }</span>

        <span class="cov8" title="1">targetRole, err := s.groupRepo.GetMemberRole(ctx, groupID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get target role: %w", err)
        }</span>

        <span class="cov8" title="1">if targetRole == domain.RoleOwner &amp;&amp; requesterRole != domain.RoleOwner </span><span class="cov8" title="1">{
                return errors.New("cannot change owner role")
        }</span>

        // 権限更新
        <span class="cov0" title="0">err = s.groupRepo.UpdateMemberRole(ctx, groupID, userID, newRole)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to update member role", logger.Error(err))
                return fmt.Errorf("failed to update member role: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Member role updated successfully",
                logger.Any("groupID", groupID),
                logger.Any("userID", userID),
                logger.Any("newRole", newRole))
        return nil</span>
}

// GetMembers はメンバー一覧を取得する
func (s *groupService) GetMembers(ctx context.Context, groupID uuid.UUID, pagination commonDomain.Pagination) ([]*MemberWithUserInfo, error) <span class="cov0" title="0">{
        members, err := s.groupRepo.ListMembers(ctx, groupID, pagination)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get members: %w", err)
        }</span>

        <span class="cov0" title="0">return s.enrichMembersWithUserInfo(ctx, members)</span>
}

// CheckPermission は権限をチェックする
func (s *groupService) CheckPermission(ctx context.Context, groupID, userID uuid.UUID, action GroupAction) (bool, error) <span class="cov8" title="1">{
        // メンバーかどうかチェック
        isMember, err := s.groupRepo.IsMember(ctx, groupID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to check membership: %w", err)
        }</span>
        <span class="cov8" title="1">if !isMember </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        // 権限取得
        <span class="cov8" title="1">role, err := s.groupRepo.GetMemberRole(ctx, groupID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to get member role: %w", err)
        }</span>

        // 権限チェック
        <span class="cov8" title="1">return s.hasPermissionForAction(role, action), nil</span>
}

// GetUserRole はユーザーの権限を取得する
func (s *groupService) GetUserRole(ctx context.Context, groupID, userID uuid.UUID) (domain.MemberRole, error) <span class="cov0" title="0">{
        return s.groupRepo.GetMemberRole(ctx, groupID, userID)
}</span>

// GetGroupStats はグループ統計情報を取得する
func (s *groupService) GetGroupStats(ctx context.Context, groupID uuid.UUID, requesterID uuid.UUID) (*domain.GroupStats, error) <span class="cov8" title="1">{
        // 権限チェック
        hasPermission, err := s.CheckPermission(ctx, groupID, requesterID, ActionViewGroup)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check permission: %w", err)
        }</span>
        <span class="cov8" title="1">if !hasPermission </span><span class="cov8" title="1">{
                return nil, errors.New("insufficient permissions")
        }</span>

        <span class="cov8" title="1">return s.groupRepo.GetGroupStats(ctx, groupID)</span>
}

// GetGroupActivity はグループ活動情報を取得する
func (s *groupService) GetGroupActivity(ctx context.Context, groupID uuid.UUID, days int) (*GroupActivity, error) <span class="cov0" title="0">{
        // 簡易実装
        return &amp;GroupActivity{
                TasksCreated:    0,
                TasksCompleted:  0,
                SchedulesShared: 0,
                ActiveMembers:   0,
        }, nil
}</span>

// === ヘルパーメソッド ===

func (s *groupService) validateCreateGroupInput(input CreateGroupInput) error <span class="cov8" title="1">{
        if input.Name == "" </span><span class="cov8" title="1">{
                return errors.New("name is required")
        }</span>
        <span class="cov8" title="1">if len(input.Name) &gt; 100 </span><span class="cov8" title="1">{
                return errors.New("name too long")
        }</span>
        <span class="cov8" title="1">if len(input.Description) &gt; 500 </span><span class="cov8" title="1">{
                return errors.New("description too long")
        }</span>
        <span class="cov8" title="1">if input.Type != domain.GroupTypeProject &amp;&amp; input.Type != domain.GroupTypeSchedule </span><span class="cov8" title="1">{
                return errors.New("invalid group type")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *groupService) hasPermissionForAction(role domain.MemberRole, action GroupAction) bool <span class="cov8" title="1">{
        switch action </span>{
        case ActionViewGroup:<span class="cov8" title="1">
                return true</span> // 全メンバーが閲覧可能
        case ActionEditGroup, ActionDeleteGroup:<span class="cov8" title="1">
                return role == domain.RoleOwner || role == domain.RoleAdmin</span>
        case ActionInviteMembers:<span class="cov8" title="1">
                return role == domain.RoleOwner || role == domain.RoleAdmin</span>
        case ActionRemoveMembers, ActionManageRoles:<span class="cov8" title="1">
                return role == domain.RoleOwner || role == domain.RoleAdmin</span>
        case ActionCreateTasks, ActionEditTasks, ActionDeleteTasks:<span class="cov0" title="0">
                return role == domain.RoleOwner || role == domain.RoleAdmin</span>
        case ActionViewTasks, ActionViewSchedules:<span class="cov8" title="1">
                return true</span> // 全メンバーが閲覧可能
        default:<span class="cov8" title="1">
                return false</span>
        }
}

func (s *groupService) enrichMembersWithUserInfo(ctx context.Context, members []*domain.GroupMember) ([]*MemberWithUserInfo, error) <span class="cov8" title="1">{
        if len(members) == 0 </span><span class="cov8" title="1">{
                return []*MemberWithUserInfo{}, nil
        }</span>

        // ユーザーIDを収集
        <span class="cov8" title="1">userIDs := make([]string, len(members))
        for i, member := range members </span><span class="cov8" title="1">{
                userIDs[i] = member.UserID.String()
        }</span>

        // ユーザー情報を一括取得
        <span class="cov8" title="1">userInfoMap, err := s.userValidator.GetUsersInfoBatch(ctx, userIDs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user info batch: %w", err)
        }</span>

        // 結果を組み立て
        <span class="cov8" title="1">result := make([]*MemberWithUserInfo, len(members))
        for i, member := range members </span><span class="cov8" title="1">{
                result[i] = &amp;MemberWithUserInfo{
                        Member:   member,
                        UserInfo: userInfoMap[member.UserID.String()],
                }
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

// === 友達招待（Social連携） ===

// InviteFriendsToGroup は友達をグループに招待する
func (s *groupService) InviteFriendsToGroup(ctx context.Context, groupID, inviterID uuid.UUID, friendIDs []uuid.UUID, message string) ([]*GroupInviteResult, error) <span class="cov0" title="0">{
        // 権限チェック
        hasPermission, err := s.CheckPermission(ctx, groupID, inviterID, ActionInviteMembers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check permission: %w", err)
        }</span>
        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                return nil, errors.New("insufficient permissions")
        }</span>

        <span class="cov0" title="0">results := make([]*GroupInviteResult, len(friendIDs))

        for i, friendID := range friendIDs </span><span class="cov0" title="0">{
                result := &amp;GroupInviteResult{
                        FriendID: friendID,
                }

                // 既にメンバーかチェック
                isMember, err := s.groupRepo.IsMember(ctx, groupID, friendID)
                if err != nil </span><span class="cov0" title="0">{
                        result.Success = false
                        result.Error = "メンバーシップの確認に失敗しました"
                        results[i] = result
                        continue</span>
                }

                <span class="cov0" title="0">if isMember </span><span class="cov0" title="0">{
                        result.Success = false
                        result.Error = "既にグループのメンバーです"
                        results[i] = result
                        continue</span>
                }

                // ユーザー存在確認
                <span class="cov0" title="0">exists, err := s.userValidator.UserExists(ctx, friendID.String())
                if err != nil || !exists </span><span class="cov0" title="0">{
                        result.Success = false
                        result.Error = "ユーザーが見つかりません"
                        results[i] = result
                        continue</span>
                }

                // TODO: Social モジュールとの連携でグループ招待を作成
                // 現在は直接メンバーとして追加
                <span class="cov0" title="0">member := domain.NewGroupMember(groupID, friendID, domain.RoleMember)
                err = s.groupRepo.AddMember(ctx, member)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to add member to group",
                                logger.Any("groupID", groupID),
                                logger.Any("friendID", friendID),
                                logger.Error(err))
                        result.Success = false
                        result.Error = "グループへの追加に失敗しました"
                }</span> else<span class="cov0" title="0"> {
                        // グループのメンバー数を更新
                        group, err := s.groupRepo.GetGroupByID(ctx, groupID)
                        if err == nil </span><span class="cov0" title="0">{
                                group.AddMember()
                                s.groupRepo.UpdateGroup(ctx, group)
                        }</span>

                        <span class="cov0" title="0">result.Success = true
                        result.Message = "グループに招待しました"</span>
                }

                <span class="cov0" title="0">results[i] = result</span>
        }

        <span class="cov0" title="0">return results, nil</span>
}

// GetAvailableFriends は招待可能な友達一覧を取得する
func (s *groupService) GetAvailableFriends(ctx context.Context, groupID, userID uuid.UUID) ([]*AvailableFriend, error) <span class="cov0" title="0">{
        // メンバーシップ確認
        isMember, err := s.groupRepo.IsMember(ctx, groupID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check membership: %w", err)
        }</span>
        <span class="cov0" title="0">if !isMember </span><span class="cov0" title="0">{
                return nil, errors.New("not a group member")
        }</span>

        // TODO: Social モジュールとの連携で友達一覧を取得
        // 現在は空の配列を返す
        <span class="cov0" title="0">return []*AvailableFriend{}, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package domain

// ChannelType は通知チャネルの種類を表す
type ChannelType string

const (
        AppInternal ChannelType = "APP_INTERNAL" // アプリ内通知
        LineMessage ChannelType = "LINE"         // LINE通知
)

// Channel は通知チャネルを表すインターフェース
type Channel interface {
        GetType() ChannelType
}

// AppChannel はアプリ内通知チャネル
type AppChannel struct {
        UserID string
}

// GetType はチャネルタイプを返す
func (c *AppChannel) GetType() ChannelType <span class="cov8" title="1">{
        return AppInternal
}</span>

// NewAppChannel は新しいアプリ内通知チャネルを作成する
func NewAppChannel(userID string) *AppChannel <span class="cov8" title="1">{
        return &amp;AppChannel{
                UserID: userID,
        }
}</span>

// LineChannel はLINE通知チャネル
type LineChannel struct {
        UserID      string
        LineUserID  string // LINEユーザーID
        AccessToken string // LINEアクセストークン
}

// GetType はチャネルタイプを返す
func (c *LineChannel) GetType() ChannelType <span class="cov8" title="1">{
        return LineMessage
}</span>

// NewLineChannel は新しいLINE通知チャネルを作成する
func NewLineChannel(userID, lineUserID, accessToken string) *LineChannel <span class="cov8" title="1">{
        return &amp;LineChannel{
                UserID:      userID,
                LineUserID:  lineUserID,
                AccessToken: accessToken,
        }
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package domain

import (
        "time"

        "github.com/google/uuid"
)

// NotificationType は通知の種類を表す
type NotificationType string

const (
        AppNotification NotificationType = "APP_NOTIFICATION" // アプリ内通知
        TaskAssigned    NotificationType = "TASK_ASSIGNED"    // タスク割り当て
        TaskCompleted   NotificationType = "TASK_COMPLETED"   // タスク完了
        TaskDueSoon     NotificationType = "TASK_DUE_SOON"    // タスク期限間近
        SystemNotice    NotificationType = "SYSTEM_NOTICE"    // システムからの通知
)

// NotificationStatus は通知の状態を表す
type NotificationStatus string

const (
        StatusPending NotificationStatus = "PENDING" // 保留中
        StatusSent    NotificationStatus = "SENT"    // 送信済み
        StatusRead    NotificationStatus = "READ"    // 既読
        StatusFailed  NotificationStatus = "FAILED"  // 送信失敗
)

// Notification は通知情報を保持するエンティティ
type Notification struct {
        ID        string             `json:"id"`
        UserID    string             `json:"user_id"`
        Type      NotificationType   `json:"type"`
        Title     string             `json:"title"`
        Message   string             `json:"message"`
        Status    NotificationStatus `json:"status"`
        Metadata  map[string]string  `json:"metadata,omitempty"`
        Channels  []Channel          `json:"-"` // 送信チャネルのリスト
        CreatedAt time.Time          `json:"created_at"`
        UpdatedAt time.Time          `json:"updated_at"`
        SentAt    *time.Time         `json:"sent_at,omitempty"`
}

// NewNotification は新しい通知エンティティを作成する
func NewNotification(
        userID string,
        notificationType NotificationType,
        title string,
        message string,
        metadata map[string]string,
) *Notification <span class="cov8" title="1">{
        now := time.Now()
        return &amp;Notification{
                ID:        uuid.New().String(),
                UserID:    userID,
                Type:      notificationType,
                Title:     title,
                Message:   message,
                Status:    StatusPending,
                Metadata:  metadata,
                Channels:  []Channel{},
                CreatedAt: now,
                UpdatedAt: now,
        }
}</span>

// GetID はIDを取得する
func (n *Notification) GetID() string <span class="cov8" title="1">{
        return n.ID
}</span>

// GetUserID はユーザーIDを取得する
func (n *Notification) GetUserID() string <span class="cov8" title="1">{
        return n.UserID
}</span>

// GetTitle はタイトルを取得する
func (n *Notification) GetTitle() string <span class="cov8" title="1">{
        return n.Title
}</span>

// MarkAsSent は通知を送信済みにする
func (n *Notification) MarkAsSent() <span class="cov8" title="1">{
        n.Status = StatusSent
        now := time.Now()
        n.SentAt = &amp;now
        n.UpdatedAt = now
}</span>

// MarkAsRead は通知を既読にする
func (n *Notification) MarkAsRead() <span class="cov8" title="1">{
        n.Status = StatusRead
        n.UpdatedAt = time.Now()
}</span>

// MarkAsFailed は通知を送信失敗にする
func (n *Notification) MarkAsFailed() <span class="cov8" title="1">{
        n.Status = StatusFailed
        n.UpdatedAt = time.Now()
}</span>

// AddChannel は通知に送信チャネルを追加する
func (n *Notification) AddChannel(channel Channel) <span class="cov8" title="1">{
        n.Channels = append(n.Channels, channel)
}</span>

// AddMetadata はメタデータに項目を追加する
func (n *Notification) AddMetadata(key, value string) <span class="cov8" title="1">{
        if n.Metadata == nil </span><span class="cov8" title="1">{
                n.Metadata = make(map[string]string)
        }</span>
        <span class="cov8" title="1">n.Metadata[key] = value
        n.UpdatedAt = time.Now()</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package database

import (
        "context"
        "database/sql"

        _ "github.com/go-sql-driver/mysql"

        "github.com/hryt430/Yotei+/config"
        commonDB "github.com/hryt430/Yotei+/internal/common/infrastructure/database"
        "github.com/hryt430/Yotei+/internal/modules/notification/interface/database"
)

type SqlHandler struct {
        Conn *sql.DB
}

func NewSqlHandler() SqlHandler <span class="cov0" title="0">{
        config, err := config.LoadConfig(".")
        if err != nil </span><span class="cov0" title="0">{
                panic(err.Error())</span>
        }

        // common/databaseからDBコネクションを取得
        <span class="cov0" title="0">conn, err := commonDB.NewMySQLConnection(config)
        if err != nil </span><span class="cov0" title="0">{
                panic(err.Error())</span>
        }

        <span class="cov0" title="0">sqlHandler := new(SqlHandler)
        sqlHandler.Conn = conn
        return *sqlHandler</span>
}

func (handler *SqlHandler) Execute(statement string, args ...interface{}) (database.Result, error) <span class="cov0" title="0">{
        res := SqlResult{}
        result, err := handler.Conn.Exec(statement, args...)
        if err != nil </span><span class="cov0" title="0">{
                return res, err
        }</span>
        <span class="cov0" title="0">res.Result = result
        return res, nil</span>
}

func (handler *SqlHandler) Query(statement string, args ...interface{}) (database.Rows, error) <span class="cov0" title="0">{
        rows, err := handler.Conn.Query(statement, args...)
        if err != nil </span><span class="cov0" title="0">{
                return new(SqlRows), err
        }</span>
        <span class="cov0" title="0">rowsStruct := new(SqlRows)
        rowsStruct.Rows = rows
        return rowsStruct, nil</span>
}

func (handler *SqlHandler) Close() error <span class="cov0" title="0">{
        return handler.Conn.Close()
}</span>

func (handler *SqlHandler) ExecContext(ctx context.Context, query string, args ...interface{}) (database.Result, error) <span class="cov0" title="0">{
        result, err := handler.Conn.ExecContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return new(SqlResult), err
        }</span>
        <span class="cov0" title="0">return &amp;SqlResult{Result: result}, nil</span>
}

func (handler *SqlHandler) QueryContext(ctx context.Context, query string, args ...interface{}) (database.Rows, error) <span class="cov0" title="0">{
        rows, err := handler.Conn.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return new(SqlRows), err
        }</span>
        <span class="cov0" title="0">return &amp;SqlRows{Rows: rows}, nil</span>
}

func (handler *SqlHandler) QueryRowContext(ctx context.Context, query string, args ...interface{}) database.Row <span class="cov0" title="0">{
        row := handler.Conn.QueryRowContext(ctx, query, args...)
        return &amp;SqlRow{Row: row}
}</span>

type SqlResult struct {
        Result sql.Result
}

func (r SqlResult) LastInsertId() (int64, error) <span class="cov0" title="0">{
        return r.Result.LastInsertId()
}</span>

func (r SqlResult) RowsAffected() (int64, error) <span class="cov0" title="0">{
        return r.Result.RowsAffected()
}</span>

type SqlRows struct {
        Rows *sql.Rows
}

func (r SqlRows) Scan(dest ...interface{}) error <span class="cov0" title="0">{
        return r.Rows.Scan(dest...)
}</span>

func (r SqlRows) Next() bool <span class="cov0" title="0">{
        return r.Rows.Next()
}</span>

func (r SqlRows) Close() error <span class="cov0" title="0">{
        return r.Rows.Close()
}</span>

func (r SqlRows) Err() error <span class="cov0" title="0">{
        return r.Rows.Err()
}</span>

type SqlRow struct {
        Row *sql.Row
}

func (r SqlRow) Scan(dest ...interface{}) error <span class="cov0" title="0">{
        return r.Row.Scan(dest...)
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package gateway

import (
        "context"
        "fmt"

        "github.com/hryt430/Yotei+/config"
        "github.com/hryt430/Yotei+/internal/modules/notification/domain"
        "github.com/hryt430/Yotei+/internal/modules/notification/interface/websocket"
        "github.com/hryt430/Yotei+/internal/modules/notification/usecase/output"
        "github.com/hryt430/Yotei+/internal/modules/notification/usecase/persistence"
        "github.com/hryt430/Yotei+/pkg/logger"
)

// AppNotificationGateway はアプリ内通知のゲートウェイ実装
type AppNotificationGateway struct {
        config     *config.Config
        repository persistence.NotificationRepository
        wsHub      *websocket.Hub // WebSocketハブ
        logger     logger.Logger
}

// NewAppNotificationGateway は新しいAppNotificationGatewayを作成する
func NewAppNotificationGateway(
        config *config.Config,
        repository persistence.NotificationRepository,
        wsHub *websocket.Hub,
        logger logger.Logger,
) output.AppNotificationGateway <span class="cov0" title="0">{
        return &amp;AppNotificationGateway{
                config:     config,
                repository: repository,
                wsHub:      wsHub,
                logger:     logger,
        }
}</span>

// SendNotification はアプリ内通知を送信する
func (g *AppNotificationGateway) SendNotification(ctx context.Context, userID, title, message string, metadata map[string]string) error <span class="cov0" title="0">{
        // 通知オブジェクトを作成
        notification := domain.NewNotification(
                userID,
                domain.AppNotification,
                title,
                message,
                metadata,
        )

        // データベースに保存
        if err := g.repository.Save(ctx, notification); err != nil </span><span class="cov0" title="0">{
                g.logger.Error("Failed to save app notification", logger.Error(err))
                return fmt.Errorf("failed to save app notification: %w", err)
        }</span>

        // WebSocketでリアルタイム送信
        <span class="cov0" title="0">if g.wsHub != nil </span><span class="cov0" title="0">{
                g.wsHub.SendNotification(notification)
                g.logger.Info("Sent real-time notification", logger.Any("userID", userID), logger.Any("notificationID", notification.ID))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// MarkAsRead は通知を既読としてマークする
func (g *AppNotificationGateway) MarkAsRead(ctx context.Context, notificationID string) error <span class="cov0" title="0">{
        if err := g.repository.UpdateStatus(ctx, notificationID, domain.StatusRead); err != nil </span><span class="cov0" title="0">{
                g.logger.Error("Failed to mark notification as read", logger.Any("notificationID", notificationID), logger.Error(err))
                return fmt.Errorf("failed to mark notification as read: %w", err)
        }</span>

        <span class="cov0" title="0">g.logger.Info("Marked notification as read", logger.Any("notificationID", notificationID))
        return nil</span>
}

// GetUnreadCount はユーザーの未読通知数を取得する
func (g *AppNotificationGateway) GetUnreadCount(ctx context.Context, userID string) (int, error) <span class="cov0" title="0">{
        count, err := g.repository.CountByUserIDAndStatus(ctx, userID, domain.StatusSent)
        if err != nil </span><span class="cov0" title="0">{
                g.logger.Error("Failed to get unread count", logger.Any("userID", userID), logger.Error(err))
                return 0, fmt.Errorf("failed to get unread count: %w", err)
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package gateway

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "time"

        "github.com/hryt430/Yotei+/config"
        "github.com/hryt430/Yotei+/internal/modules/notification/usecase/output"
        "github.com/hryt430/Yotei+/pkg/logger"
)

// LineMessage はLINE Messaging APIに送信するメッセージ形式
type LineMessage struct {
        To       string              `json:"to"`
        Messages []LineMessageDetail `json:"messages"`
}

// LineMessageDetail はLINEメッセージの詳細
type LineMessageDetail struct {
        Type string `json:"type"`
        Text string `json:"text"`
}

// LineGateway はLINE通知のゲートウェイ実装
type LineGateway struct {
        config     *config.Config
        httpClient *http.Client
        logger     logger.Logger
}

// NewLineGateway は新しいLineGatewayを作成する
func NewLineGateway(config *config.Config, logger logger.Logger) output.LineNotificationGateway <span class="cov0" title="0">{
        return &amp;LineGateway{
                config: config,
                httpClient: &amp;http.Client{
                        Timeout: 10 * time.Second,
                },
                logger: logger,
        }
}</span>

// SendNotification は通知を送信する
func (g *LineGateway) SendNotification(ctx context.Context, userID, title, message string, metadata map[string]string) error <span class="cov0" title="0">{
        lineUserID, ok := metadata["line_user_id"]
        if !ok </span><span class="cov0" title="0">{
                g.logger.Warn("LINE user ID not found in metadata", logger.Any("userID", userID))
                return nil // LINEユーザーIDがない場合は何もしない
        }</span>

        <span class="cov0" title="0">return g.SendLineNotification(ctx, lineUserID, title+"\n"+message)</span>
}

// SendLineNotification はLINE通知を送信する
func (g *LineGateway) SendLineNotification(ctx context.Context, lineUserID, message string) error <span class="cov0" title="0">{
        // LINE Messaging APIのエンドポイント
        url := "https://api.line.me/v2/bot/message/push"

        // メッセージの構築
        lineMsg := LineMessage{
                To: lineUserID,
                Messages: []LineMessageDetail{
                        {
                                Type: "text",
                                Text: message,
                        },
                },
        }

        // JSONに変換
        jsonData, err := json.Marshal(lineMsg)
        if err != nil </span><span class="cov0" title="0">{
                g.logger.Error("Failed to marshal LINE message", logger.Error(err))
                return fmt.Errorf("failed to marshal LINE message: %w", err)
        }</span>

        // リクエストの作成
        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, http.MethodPost, url, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                g.logger.Error("Failed to create HTTP request", logger.Error(err))
                return fmt.Errorf("failed to create HTTP request: %w", err)
        }</span>

        // ヘッダーの設定
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+g.config.External.LineChannelToken)

        // リクエストの送信
        resp, err := g.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                g.logger.Error("Failed to send LINE notification", logger.Error(err))
                return fmt.Errorf("failed to send LINE notification: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // レスポンスの確認
        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                g.logger.Error("LINE API returned non-OK status", logger.Any("status", resp.Status))
                return fmt.Errorf("LINE API returned non-OK status: %s", resp.Status)
        }</span>

        <span class="cov0" title="0">g.logger.Info("Successfully sent LINE notification", logger.Any("lineUserID", lineUserID))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package messaging

import (
        "context"
        "encoding/json"
        "fmt"

        "github.com/hryt430/Yotei+/pkg/logger"
)

// MessageBroker はメッセージブローカーのインターフェース
type MessageBroker interface {
        // Publish はトピックにメッセージを公開する
        Publish(ctx context.Context, topic string, message []byte) error

        // Subscribe はトピックからメッセージを購読する
        Subscribe(ctx context.Context, topic string, handler func([]byte) error) error

        // Close はブローカー接続を閉じる
        Close() error
}

// InMemoryMessageBroker はメモリ上で動作するシンプルなメッセージブローカー
// 開発・テスト用途に適しています
type InMemoryMessageBroker struct {
        subscribers map[string][]func([]byte) error
        logger      logger.Logger
}

// NewInMemoryMessageBroker は新しいInMemoryMessageBrokerを作成する
func NewInMemoryMessageBroker(logger logger.Logger) MessageBroker <span class="cov0" title="0">{
        return &amp;InMemoryMessageBroker{
                subscribers: make(map[string][]func([]byte) error),
                logger:      logger,
        }
}</span>

// Publish はトピックにメッセージを公開する
func (b *InMemoryMessageBroker) Publish(ctx context.Context, topic string, message []byte) error <span class="cov0" title="0">{
        b.logger.Info("Publishing message", logger.Any("topic", topic), logger.Any("size", len(message)))

        for _, handler := range b.subscribers[topic] </span><span class="cov0" title="0">{
                if err := handler(message); err != nil </span><span class="cov0" title="0">{
                        b.logger.Error("Error handling message", logger.Any("topic", topic), logger.Any("error", err))
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Subscribe はトピックからメッセージを購読する
func (b *InMemoryMessageBroker) Subscribe(ctx context.Context, topic string, handler func([]byte) error) error <span class="cov0" title="0">{
        b.logger.Info("Subscribing to topic", logger.Any("topic", topic))
        b.subscribers[topic] = append(b.subscribers[topic], handler)
        return nil
}</span>

// Close はブローカー接続を閉じる
func (b *InMemoryMessageBroker) Close() error <span class="cov0" title="0">{
        b.subscribers = make(map[string][]func([]byte) error)
        return nil
}</span>

// WebSocketMessage はWebSocketに送信するメッセージ
type WebSocketMessage struct {
        Type    string      `json:"type"`
        Payload interface{} `json:"payload"`
}

// WSMessageBroker はWebSocket向けのメッセージブローカー
type WSMessageBroker struct {
        broker MessageBroker
        logger logger.Logger
}

// NewWSMessageBroker は新しいWSMessageBrokerを作成する
func NewWSMessageBroker(broker MessageBroker, logger logger.Logger) *WSMessageBroker <span class="cov0" title="0">{
        return &amp;WSMessageBroker{
                broker: broker,
                logger: logger,
        }
}</span>

// PublishToUser は特定ユーザー向けにメッセージを公開する
func (b *WSMessageBroker) PublishToUser(ctx context.Context, userID string, messageType string, payload interface{}) error <span class="cov0" title="0">{
        message := WebSocketMessage{
                Type:    messageType,
                Payload: payload,
        }

        data, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal message: %w", err)
        }</span>

        <span class="cov0" title="0">topic := fmt.Sprintf("user.%s.notifications", userID)
        return b.broker.Publish(ctx, topic, data)</span>
}

// PublishNotification は通知メッセージを公開する
func (b *WSMessageBroker) PublishNotification(ctx context.Context, userID string, notification interface{}) error <span class="cov0" title="0">{
        return b.PublishToUser(ctx, userID, "notification", notification)
}</span>

// PublishNotificationRead は通知既読メッセージを公開する
func (b *WSMessageBroker) PublishNotificationRead(ctx context.Context, userID string, notificationID string) error <span class="cov0" title="0">{
        payload := map[string]interface{}{
                "notification_id": notificationID,
                "read_at":         true,
        }
        return b.PublishToUser(ctx, userID, "notification_read", payload)
}</span>

// SubscribeToUserNotifications はユーザー通知を購読する
func (b *WSMessageBroker) SubscribeToUserNotifications(ctx context.Context, userID string, handler func([]byte) error) error <span class="cov0" title="0">{
        topic := fmt.Sprintf("user.%s.notifications", userID)
        return b.broker.Subscribe(ctx, topic, handler)
}</span>

// Close はブローカー接続を閉じる
func (b *WSMessageBroker) Close() error <span class="cov0" title="0">{
        return b.broker.Close()
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package messaging

import (
        "context"
        "fmt"
        "time"

        notiDomain "github.com/hryt430/Yotei+/internal/modules/notification/domain"
        "github.com/hryt430/Yotei+/internal/modules/notification/usecase/input"
        taskDomain "github.com/hryt430/Yotei+/internal/modules/task/domain"
        "github.com/hryt430/Yotei+/internal/modules/task/usecase"
        "github.com/hryt430/Yotei+/pkg/logger"
)

// NotificationService は通知サービスのインターフェース
type NotificationService interface {
        CreateScheduledNotification(
                ctx context.Context,
                userID, title, message string,
                notificationType notiDomain.NotificationType,
                scheduledTime time.Time,
                metadata map[string]string,
        ) error
        CreateNotification(ctx context.Context, input input.CreateNotificationInput) (*notiDomain.Notification, error)
}

// TaskDueNotificationScheduler はタスク期限通知のスケジューラー
type TaskDueNotificationScheduler struct {
        taskService         usecase.TaskService
        notificationService NotificationService
        logger              logger.Logger
        ticker              *time.Ticker
        stopCh              chan struct{}
        isRunning           bool
}

// NewTaskDueNotificationScheduler は新しいスケジューラーを作成
func NewTaskDueNotificationScheduler(
        taskService usecase.TaskService,
        notificationService NotificationService,
        logger logger.Logger,
) *TaskDueNotificationScheduler <span class="cov0" title="0">{
        return &amp;TaskDueNotificationScheduler{
                taskService:         taskService,
                notificationService: notificationService,
                logger:              logger,
                stopCh:              make(chan struct{}),
        }
}</span>

// Start はスケジューラーを開始（1時間ごとにチェック）
func (s *TaskDueNotificationScheduler) Start(ctx context.Context) <span class="cov0" title="0">{
        if s.isRunning </span><span class="cov0" title="0">{
                s.logger.Warn("Task due notification scheduler already running")
                return
        }</span>

        <span class="cov0" title="0">s.isRunning = true
        s.ticker = time.NewTicker(1 * time.Hour) // 1時間ごとにチェック

        s.logger.Info("Starting task due notification scheduler")

        // 初回実行
        go s.checkAndNotifyDueTasks(ctx)

        go func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        s.ticker.Stop()
                        s.isRunning = false
                }</span>()

                <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-s.ticker.C:<span class="cov0" title="0">
                                s.checkAndNotifyDueTasks(ctx)</span>
                        case &lt;-s.stopCh:<span class="cov0" title="0">
                                s.logger.Info("Task due notification scheduler stopped")
                                return</span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                s.logger.Info("Task due notification scheduler stopped due to context cancellation")
                                return</span>
                        }
                }
        }()
}

// Stop はスケジューラーを停止
func (s *TaskDueNotificationScheduler) Stop() <span class="cov0" title="0">{
        if !s.isRunning </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">close(s.stopCh)
        s.logger.Info("Stopping task due notification scheduler")</span>
}

// checkAndNotifyDueTasks は12時間以内に期限を迎えるタスクをチェックして通知
func (s *TaskDueNotificationScheduler) checkAndNotifyDueTasks(ctx context.Context) <span class="cov0" title="0">{
        s.logger.Info("Checking tasks due within 12 hours")

        // 現在時刻から12時間後までのタスクを取得
        now := time.Now()
        twelveHoursLater := now.Add(12 * time.Hour)

        // カスタムフィルターでタスクを取得（期限が12時間以内）
        tasks, err := s.getTasksDueWithin12Hours(ctx, now, twelveHoursLater)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get tasks due within 12 hours", logger.Error(err))
                return
        }</span>

        <span class="cov0" title="0">s.logger.Info("Found tasks due within 12 hours", logger.Any("count", len(tasks)))

        // 各タスクについて通知を作成
        for _, task := range tasks </span><span class="cov0" title="0">{
                if err := s.createDueNotification(ctx, task, now); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to create due notification",
                                logger.Any("taskID", task.ID),
                                logger.Error(err))
                        continue</span>
                }
        }
}

// getTasksDueWithin12Hours は12時間以内に期限を迎えるタスクを取得
func (s *TaskDueNotificationScheduler) getTasksDueWithin12Hours(ctx context.Context, from, to time.Time) ([]*taskDomain.Task, error) <span class="cov0" title="0">{
        // TaskServiceにカスタムフィルターメソッドを追加する必要がある
        // ここでは仮の実装として、すべてのタスクを取得してフィルタリング
        filter := taskDomain.ListFilter{
                DueDateFrom: &amp;from,
                DueDateTo:   &amp;to,
        }

        pagination := taskDomain.Pagination{
                Page:     1,
                PageSize: 1000, // 大きめの値を設定（実際のプロダクションではより適切な値に調整）
        }

        sortOptions := taskDomain.SortOptions{
                Field:     "due_date",
                Direction: "ASC",
        }

        // まだ完了していないタスクのみを対象
        incompleteTasks := []*taskDomain.Task{}

        tasks, _, err := s.taskService.ListTasks(ctx, filter, pagination, sortOptions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list tasks: %w", err)
        }</span>

        // 完了していないタスクのみフィルタリング
        <span class="cov0" title="0">for _, task := range tasks </span><span class="cov0" title="0">{
                if task.Status != taskDomain.TaskStatusDone &amp;&amp; task.DueDate != nil </span><span class="cov0" title="0">{
                        // 12時間以内かつ、まだ通知していないタスクをフィルタ
                        if s.shouldNotifyForTask(task, from, to) </span><span class="cov0" title="0">{
                                incompleteTasks = append(incompleteTasks, task)
                        }</span>
                }
        }

        <span class="cov0" title="0">return incompleteTasks, nil</span>
}

// shouldNotifyForTask はタスクに対して通知すべきかを判断
func (s *TaskDueNotificationScheduler) shouldNotifyForTask(task *taskDomain.Task, from, to time.Time) bool <span class="cov0" title="0">{
        if task.DueDate == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // 12時間以内に期限を迎える
        <span class="cov0" title="0">if task.DueDate.After(from) &amp;&amp; task.DueDate.Before(to) </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// createDueNotification は期限通知を作成
func (s *TaskDueNotificationScheduler) createDueNotification(ctx context.Context, task *taskDomain.Task, now time.Time) error <span class="cov0" title="0">{
        // アサインされていないタスクは通知しない
        if task.AssigneeID == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // 期限までの時間を計算
        <span class="cov0" title="0">timeUntilDue := task.DueDate.Sub(now)
        hoursUntilDue := int(timeUntilDue.Hours())

        title := fmt.Sprintf("タスク期限通知: %s", task.Title)
        message := fmt.Sprintf(
                "タスク「%s」の期限まであと%d時間です。\n期限: %s\n優先度: %s",
                task.Title,
                hoursUntilDue,
                task.DueDate.Format("2006-01-02 15:04"),
                task.Priority,
        )

        // メタデータを設定
        metadata := map[string]string{
                "task_id":           task.ID,
                "task_title":        task.Title,
                "due_date":          task.DueDate.Format(time.RFC3339),
                "hours_until":       fmt.Sprintf("%d", hoursUntilDue),
                "priority":          string(task.Priority),
                "notification_type": "task_due_soon",
        }

        // 通知作成の入力データ
        createInput := input.CreateNotificationInput{
                UserID:   *task.AssigneeID,
                Type:     "TASK_DUE_SOON",
                Title:    title,
                Message:  message,
                Metadata: metadata,
                Channels: []string{"app"}, // アプリ内通知のみ
        }

        // 通知を作成
        notification, err := s.notificationService.CreateNotification(ctx, createInput)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create notification: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Created due notification",
                logger.Any("taskID", task.ID),
                logger.Any("notificationID", notification.ID),
                logger.Any("assigneeID", *task.AssigneeID))

        return nil</span>
}

// TaskEventHandler はタスクイベントを処理
type TaskEventHandler struct {
        notificationService NotificationService
        logger              logger.Logger
}

// NewTaskEventHandler は新しいイベントハンドラーを作成
func NewTaskEventHandler(
        notificationService NotificationService,
        logger logger.Logger,
) *TaskEventHandler <span class="cov0" title="0">{
        return &amp;TaskEventHandler{
                notificationService: notificationService,
                logger:              logger,
        }
}</span>

// HandleTaskAssigned はタスク割り当てイベントを処理
func (h *TaskEventHandler) HandleTaskAssigned(ctx context.Context, task *taskDomain.Task) error <span class="cov0" title="0">{
        if task.AssigneeID == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">title := fmt.Sprintf("新しいタスクが割り当てられました: %s", task.Title)
        message := fmt.Sprintf(
                "タスク「%s」が割り当てられました。\n説明: %s\n優先度: %s",
                task.Title,
                task.Description,
                task.Priority,
        )

        if task.DueDate != nil </span><span class="cov0" title="0">{
                message += fmt.Sprintf("\n期限: %s", task.DueDate.Format("2006-01-02 15:04"))
        }</span>

        <span class="cov0" title="0">metadata := map[string]string{
                "task_id":    task.ID,
                "task_title": task.Title,
                "priority":   string(task.Priority),
                "created_by": task.CreatedBy,
        }

        createInput := input.CreateNotificationInput{
                UserID:   *task.AssigneeID,
                Type:     "TASK_ASSIGNED",
                Title:    title,
                Message:  message,
                Metadata: metadata,
                Channels: []string{"app"},
        }

        _, err := h.notificationService.CreateNotification(ctx, createInput)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create task assigned notification: %w", err)
        }</span>

        <span class="cov0" title="0">h.logger.Info("Created task assigned notification",
                logger.Any("taskID", task.ID),
                logger.Any("assigneeID", *task.AssigneeID))

        return nil</span>
}

// HandleTaskCompleted はタスク完了イベントを処理
func (h *TaskEventHandler) HandleTaskCompleted(ctx context.Context, task *taskDomain.Task) error <span class="cov0" title="0">{
        // タスク作成者に完了通知を送信
        title := fmt.Sprintf("タスクが完了されました: %s", task.Title)
        message := fmt.Sprintf(
                "タスク「%s」が完了されました。",
                task.Title,
        )

        if task.AssigneeID != nil </span><span class="cov0" title="0">{
                message += fmt.Sprintf("\n担当者: %s", *task.AssigneeID)
        }</span>

        <span class="cov0" title="0">metadata := map[string]string{
                "task_id":      task.ID,
                "task_title":   task.Title,
                "completed_at": time.Now().Format(time.RFC3339),
        }

        if task.AssigneeID != nil </span><span class="cov0" title="0">{
                metadata["assignee_id"] = *task.AssigneeID
        }</span>

        <span class="cov0" title="0">createInput := input.CreateNotificationInput{
                UserID:   task.CreatedBy,
                Type:     "TASK_COMPLETED",
                Title:    title,
                Message:  message,
                Metadata: metadata,
                Channels: []string{"app"},
        }

        _, err := h.notificationService.CreateNotification(ctx, createInput)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create task completed notification: %w", err)
        }</span>

        <span class="cov0" title="0">h.logger.Info("Created task completed notification",
                logger.Any("taskID", task.ID),
                logger.Any("createdBy", task.CreatedBy))

        return nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package controller

import (
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"

        "github.com/hryt430/Yotei+/internal/common/middleware"
        "github.com/hryt430/Yotei+/internal/modules/notification/interface/dto"
        "github.com/hryt430/Yotei+/internal/modules/notification/usecase/input"
        "github.com/hryt430/Yotei+/pkg/logger"
        "go.uber.org/zap/zapcore"
)

// NotificationController は通知コントローラー
type NotificationController struct {
        notificationUseCase input.NotificationUseCase
        logger              logger.Logger
}

// NewNotificationController は新しいNotificationControllerを作成する
func NewNotificationController(useCase input.NotificationUseCase, logger logger.Logger) *NotificationController <span class="cov0" title="0">{
        return &amp;NotificationController{
                notificationUseCase: useCase,
                logger:              logger,
        }
}</span>

// CreateNotificationRequest は通知作成のリクエスト構造体
type CreateNotificationRequest struct {
        UserID   string            `json:"user_id" binding:"required" example:"123e4567-e89b-12d3-a456-426614174000"`
        Type     string            `json:"type" binding:"required" example:"TASK_ASSIGNED"`
        Title    string            `json:"title" binding:"required" example:"新しいタスクが割り当てられました"`
        Message  string            `json:"message" binding:"required" example:"「重要なプロジェクト」タスクが割り当てられました"`
        Metadata map[string]string `json:"metadata,omitempty" example:"{\"task_id\":\"task-123\",\"priority\":\"HIGH\"}"`
        Channels []string          `json:"channels" binding:"required" example:"[\"app\",\"line\"]"`
} // @name CreateNotificationRequest

// NotificationResponse は通知のレスポンス構造体
type NotificationResponse struct {
        ID        string            `json:"id" example:"123e4567-e89b-12d3-a456-426614174000"`
        UserID    string            `json:"user_id" example:"123e4567-e89b-12d3-a456-426614174000"`
        Type      string            `json:"type" example:"TASK_ASSIGNED"`
        Title     string            `json:"title" example:"新しいタスクが割り当てられました"`
        Message   string            `json:"message" example:"「重要なプロジェクト」タスクが割り当てられました"`
        Status    string            `json:"status" example:"SENT"`
        Metadata  map[string]string `json:"metadata,omitempty" example:"{\"task_id\":\"task-123\",\"priority\":\"HIGH\"}"`
        CreatedAt string            `json:"created_at" example:"2024-01-01T00:00:00Z"`
        UpdatedAt string            `json:"updated_at" example:"2024-01-01T00:00:00Z"`
        SentAt    *string           `json:"sent_at,omitempty" example:"2024-01-01T00:05:00Z"`
} // @name NotificationResponse

// CreateNotificationResponse は通知作成のレスポンス構造体
type CreateNotificationResponse struct {
        Success bool                 `json:"success" example:"true"`
        Data    NotificationResponse `json:"data"`
} // @name CreateNotificationResponse

// GetNotificationResponse は通知取得のレスポンス構造体
type GetNotificationResponse struct {
        Success bool                 `json:"success" example:"true"`
        Data    NotificationResponse `json:"data"`
} // @name GetNotificationResponse

// GetUserNotificationsResponse はユーザー通知一覧のレスポンス構造体
type GetUserNotificationsResponse struct {
        Success bool                   `json:"success" example:"true"`
        Data    []NotificationResponse `json:"data"`
} // @name GetUserNotificationsResponse

// UnreadCountResponse は未読通知数のレスポンス構造体
type UnreadCountResponse struct {
        Success bool `json:"success" example:"true"`
        Count   int  `json:"count" example:"5"`
} // @name UnreadCountResponse

// MessageResponse は基本メッセージレスポンス構造体
type MessageResponse struct {
        Success bool   `json:"success" example:"true"`
        Message string `json:"message" example:"操作が正常に完了しました"`
} // @name MessageResponse

// ErrorResponse はエラーレスポンス構造体
type ErrorResponse struct {
        Error   string `json:"error" example:"INVALID_REQUEST"`
        Message string `json:"message" example:"リクエストが無効です"`
} // @name ErrorResponse

// CreateNotification 通知作成
// @Summary      通知作成
// @Description  新しい通知を作成します
// @Tags         notifications
// @Accept       json
// @Produce      json
// @Param        request body CreateNotificationRequest true "通知作成情報"
// @Security     BearerAuth
// @Success      201 {object} CreateNotificationResponse "通知作成成功"
// @Failure      400 {object} ErrorResponse "リクエストが無効"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /notifications [post]
func (c *NotificationController) CreateNotification(ctx *gin.Context) <span class="cov0" title="0">{
        user, err := middleware.GetUserFromContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                c.logError("get user from context", err)
                ctx.JSON(http.StatusUnauthorized, dto.ErrorResponse{
                        Error:   "unauthorized",
                        Message: "認証が必要です",
                })
                return
        }</span>

        <span class="cov0" title="0">var createInput input.CreateNotificationInput
        if err := ctx.ShouldBindJSON(&amp;createInput); err != nil </span><span class="cov0" title="0">{
                c.logError("bind JSON", err)
                ctx.JSON(http.StatusBadRequest, dto.ErrorResponse{
                        Error:   "invalid_request",
                        Message: "リクエストの形式が正しくありません",
                })
                return
        }</span>

        <span class="cov0" title="0">notification, err := c.notificationUseCase.CreateNotification(ctx, createInput)
        if err != nil </span><span class="cov0" title="0">{
                c.logError("create notification", err, logger.Any("userID", user.ID))
                ctx.JSON(http.StatusInternalServerError, dto.ErrorResponse{
                        Error:   "create_notification_failed",
                        Message: "通知の作成に失敗しました",
                })
                return
        }</span>

        <span class="cov0" title="0">c.logger.Info("Notification created successfully",
                logger.Any("userID", user.ID),
                logger.Any("notificationID", notification.ID))

        ctx.JSON(http.StatusCreated, notification)</span>
}

// GetNotification 通知取得
// @Summary      通知取得
// @Description  指定されたIDの通知を取得します
// @Tags         notifications
// @Accept       json
// @Produce      json
// @Param        id path string true "通知ID" example:"123e4567-e89b-12d3-a456-426614174000"
// @Security     BearerAuth
// @Success      200 {object} GetNotificationResponse "通知取得成功"
// @Failure      400 {object} ErrorResponse "通知IDが必要"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      404 {object} ErrorResponse "通知が見つからない"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /notifications/{id} [get]
func (c *NotificationController) GetNotification(ctx *gin.Context) <span class="cov0" title="0">{
        user, err := middleware.GetUserFromContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                c.logError("get user from context", err)
                ctx.JSON(http.StatusUnauthorized, dto.ErrorResponse{
                        Error:   "unauthorized",
                        Message: "認証が必要です",
                })
                return
        }</span>

        <span class="cov0" title="0">notificationID, err := c.validateUUID(ctx.Param("id"), "notification ID")
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, dto.ErrorResponse{
                        Error:   "invalid_notification_id",
                        Message: "無効な通知IDです",
                })
                return
        }</span>

        <span class="cov0" title="0">notification, err := c.notificationUseCase.GetNotification(ctx, notificationID.String())
        if err != nil </span><span class="cov0" title="0">{
                c.logError("get notification", err,
                        logger.Any("userID", user.ID),
                        logger.Any("notificationID", notificationID))
                ctx.JSON(http.StatusInternalServerError, dto.ErrorResponse{
                        Error:   "get_notification_failed",
                        Message: "通知の取得に失敗しました",
                })
                return
        }</span>

        <span class="cov0" title="0">if notification == nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusNotFound, dto.ErrorResponse{
                        Error:   "notification_not_found",
                        Message: "通知が見つかりません",
                })
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, notification)</span>
}

// GetUserNotifications ユーザーの通知一覧取得
// @Summary      ユーザーの通知一覧取得
// @Description  指定されたユーザーの通知一覧を取得します（ページング対応）
// @Tags         notifications
// @Accept       json
// @Produce      json
// @Param        user_id path string true "ユーザーID" example:"123e4567-e89b-12d3-a456-426614174000"
// @Param        limit query int false "取得数の上限" default(10) minimum(1) maximum(100)
// @Param        offset query int false "取得開始位置" default(0) minimum(0)
// @Security     BearerAuth
// @Success      200 {object} GetUserNotificationsResponse "通知一覧取得成功"
// @Failure      400 {object} ErrorResponse "ユーザーIDが必要"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /notifications/user/{user_id} [get]
func (c *NotificationController) GetUserNotifications(ctx *gin.Context) <span class="cov0" title="0">{
        user, err := middleware.GetUserFromContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                c.logError("get user from context", err)
                ctx.JSON(http.StatusUnauthorized, dto.ErrorResponse{
                        Error:   "unauthorized",
                        Message: "認証が必要です",
                })
                return
        }</span>

        <span class="cov0" title="0">targetUserID, err := c.validateUUID(ctx.Param("user_id"), "user ID")
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, dto.ErrorResponse{
                        Error:   "invalid_user_id",
                        Message: "無効なユーザーIDです",
                })
                return
        }</span>

        // 権限チェック（自分の通知のみ閲覧可能）
        <span class="cov0" title="0">if user.ID != targetUserID </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusForbidden, dto.ErrorResponse{
                        Error:   "access_denied",
                        Message: "他のユーザーの通知を閲覧する権限がありません",
                })
                return
        }</span>

        // クエリパラメータからlimitとoffsetを取得
        <span class="cov0" title="0">limitStr := ctx.DefaultQuery("limit", "10")
        offsetStr := ctx.DefaultQuery("offset", "0")

        limit, err := strconv.Atoi(limitStr)
        if err != nil || limit &lt; 1 || limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 10
        }</span>

        <span class="cov0" title="0">offset, err := strconv.Atoi(offsetStr)
        if err != nil || offset &lt; 0 </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        <span class="cov0" title="0">inputData := input.GetNotificationsInput{
                UserID: targetUserID.String(),
                Limit:  limit,
                Offset: offset,
        }

        notifications, err := c.notificationUseCase.GetUserNotifications(ctx, inputData)
        if err != nil </span><span class="cov0" title="0">{
                c.logError("get user notifications", err,
                        logger.Any("userID", user.ID),
                        logger.Any("targetUserID", targetUserID))
                ctx.JSON(http.StatusInternalServerError, dto.ErrorResponse{
                        Error:   "get_user_notifications_failed",
                        Message: "ユーザー通知一覧の取得に失敗しました",
                })
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, notifications)</span>
}

// SendNotification 通知送信
// @Summary      通知送信
// @Description  指定された通知を即座に送信します
// @Tags         notifications
// @Accept       json
// @Produce      json
// @Param        id path string true "通知ID" example:"123e4567-e89b-12d3-a456-426614174000"
// @Security     BearerAuth
// @Success      200 {object} MessageResponse "通知送信成功"
// @Failure      400 {object} ErrorResponse "通知IDが必要"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      404 {object} ErrorResponse "通知が見つからない"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /notifications/{id}/send [post]
func (c *NotificationController) SendNotification(ctx *gin.Context) <span class="cov0" title="0">{
        user, err := middleware.GetUserFromContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                c.logError("get user from context", err)
                ctx.JSON(http.StatusUnauthorized, dto.ErrorResponse{
                        Error:   "unauthorized",
                        Message: "認証が必要です",
                })
                return
        }</span>

        <span class="cov0" title="0">notificationID, err := c.validateUUID(ctx.Param("id"), "notification ID")
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, dto.ErrorResponse{
                        Error:   "invalid_notification_id",
                        Message: "無効な通知IDです",
                })
                return
        }</span>

        <span class="cov0" title="0">err = c.notificationUseCase.SendNotification(ctx, notificationID.String())
        if err != nil </span><span class="cov0" title="0">{
                c.logError("send notification", err,
                        logger.Any("userID", user.ID),
                        logger.Any("notificationID", notificationID))
                ctx.JSON(http.StatusInternalServerError, dto.ErrorResponse{
                        Error:   "send_notification_failed",
                        Message: "通知の送信に失敗しました",
                })
                return
        }</span>

        <span class="cov0" title="0">c.logger.Info("Notification sent successfully",
                logger.Any("userID", user.ID),
                logger.Any("notificationID", notificationID))

        ctx.JSON(http.StatusOK, dto.SuccessResponse{
                Success: true,
                Message: "通知を送信しました",
        })</span>
}

// MarkNotificationAsRead 通知既読マーク
// @Summary      通知既読マーク
// @Description  指定された通知を既読としてマークします
// @Tags         notifications
// @Accept       json
// @Produce      json
// @Param        id path string true "通知ID" example:"123e4567-e89b-12d3-a456-426614174000"
// @Security     BearerAuth
// @Success      200 {object} MessageResponse "既読マーク成功"
// @Failure      400 {object} ErrorResponse "通知IDが必要"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      404 {object} ErrorResponse "通知が見つからない"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /notifications/{id}/read [put]
func (c *NotificationController) MarkNotificationAsRead(ctx *gin.Context) <span class="cov0" title="0">{
        user, err := middleware.GetUserFromContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                c.logError("get user from context", err)
                ctx.JSON(http.StatusUnauthorized, dto.ErrorResponse{
                        Error:   "unauthorized",
                        Message: "認証が必要です",
                })
                return
        }</span>

        <span class="cov0" title="0">notificationID, err := c.validateUUID(ctx.Param("id"), "notification ID")
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, dto.ErrorResponse{
                        Error:   "invalid_notification_id",
                        Message: "無効な通知IDです",
                })
                return
        }</span>

        <span class="cov0" title="0">err = c.notificationUseCase.MarkNotificationAsRead(ctx, notificationID.String())
        if err != nil </span><span class="cov0" title="0">{
                c.logError("mark notification as read", err,
                        logger.Any("userID", user.ID),
                        logger.Any("notificationID", notificationID))
                ctx.JSON(http.StatusInternalServerError, dto.ErrorResponse{
                        Error:   "mark_as_read_failed",
                        Message: "通知の既読マークに失敗しました",
                })
                return
        }</span>

        <span class="cov0" title="0">c.logger.Info("Notification marked as read successfully",
                logger.Any("userID", user.ID),
                logger.Any("notificationID", notificationID))

        ctx.JSON(http.StatusOK, dto.SuccessResponse{
                Success: true,
                Message: "通知を既読にしました",
        })</span>
}

// GetUnreadNotificationCount 未読通知数取得
// @Summary      未読通知数取得
// @Description  指定されたユーザーの未読通知数を取得します
// @Tags         notifications
// @Accept       json
// @Produce      json
// @Param        user_id path string true "ユーザーID" example:"123e4567-e89b-12d3-a456-426614174000"
// @Security     BearerAuth
// @Success      200 {object} UnreadCountResponse "未読通知数取得成功"
// @Failure      400 {object} ErrorResponse "ユーザーIDが必要"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /notifications/user/{user_id}/unread/count [get]
func (c *NotificationController) GetUnreadNotificationCount(ctx *gin.Context) <span class="cov0" title="0">{
        user, err := middleware.GetUserFromContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                c.logError("get user from context", err)
                ctx.JSON(http.StatusUnauthorized, dto.ErrorResponse{
                        Error:   "unauthorized",
                        Message: "認証が必要です",
                })
                return
        }</span>

        <span class="cov0" title="0">targetUserID, err := c.validateUUID(ctx.Param("user_id"), "user ID")
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, dto.ErrorResponse{
                        Error:   "invalid_user_id",
                        Message: "無効なユーザーIDです",
                })
                return
        }</span>

        // 権限チェック（自分の通知数のみ取得可能）
        <span class="cov0" title="0">if user.ID != targetUserID </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusForbidden, dto.ErrorResponse{
                        Error:   "access_denied",
                        Message: "他のユーザーの通知数を取得する権限がありません",
                })
                return
        }</span>

        <span class="cov0" title="0">count, err := c.notificationUseCase.GetUnreadNotificationCount(ctx, targetUserID.String())
        if err != nil </span><span class="cov0" title="0">{
                c.logError("get unread notification count", err,
                        logger.Any("userID", user.ID),
                        logger.Any("targetUserID", targetUserID))
                ctx.JSON(http.StatusInternalServerError, dto.ErrorResponse{
                        Error:   "get_unread_count_failed",
                        Message: "未読通知数の取得に失敗しました",
                })
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{
                "success": true,
                "count":   count,
        })</span>
}

// MarkAllNotificationsAsRead 全通知既読マーク
// @Summary      全通知既読マーク
// @Description  指定されたユーザーの全ての未読通知を既読としてマークします
// @Tags         notifications
// @Accept       json
// @Produce      json
// @Param        user_id path string true "ユーザーID" example:"123e4567-e89b-12d3-a456-426614174000"
// @Security     BearerAuth
// @Success      200 {object} MessageResponse "全既読マーク成功"
// @Failure      400 {object} ErrorResponse "ユーザーIDが必要"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      403 {object} ErrorResponse "権限がない"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /notifications/user/{user_id}/read-all [put]
func (c *NotificationController) MarkAllNotificationsAsRead(ctx *gin.Context) <span class="cov0" title="0">{
        user, err := middleware.GetUserFromContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                c.logError("get user from context", err)
                ctx.JSON(http.StatusUnauthorized, dto.ErrorResponse{
                        Error:   "unauthorized",
                        Message: "認証が必要です",
                })
                return
        }</span>

        <span class="cov0" title="0">targetUserID, err := c.validateUUID(ctx.Param("user_id"), "user ID")
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, dto.ErrorResponse{
                        Error:   "invalid_user_id",
                        Message: "無効なユーザーIDです",
                })
                return
        }</span>

        // 権限チェック（自分の通知のみ操作可能）
        <span class="cov0" title="0">if user.ID != targetUserID </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusForbidden, dto.ErrorResponse{
                        Error:   "access_denied",
                        Message: "他のユーザーの通知を操作する権限がありません",
                })
                return
        }</span>

        <span class="cov0" title="0">err = c.notificationUseCase.MarkNotificationAsRead(ctx, targetUserID.String())
        if err != nil </span><span class="cov0" title="0">{
                c.logError("mark all notifications as read", err,
                        logger.Any("userID", user.ID),
                        logger.Any("targetUserID", targetUserID))
                ctx.JSON(http.StatusInternalServerError, dto.ErrorResponse{
                        Error:   "mark_all_as_read_failed",
                        Message: "全通知の既読マークに失敗しました",
                })
                return
        }</span>

        <span class="cov0" title="0">c.logger.Info("All notifications marked as read successfully",
                logger.Any("userID", user.ID),
                logger.Any("targetUserID", targetUserID))

        ctx.JSON(http.StatusOK, dto.SuccessResponse{
                Success: true,
                Message: "全ての通知を既読にしました",
        })</span>
}

// WebhookHandler Webhook処理
// @Summary      Webhook処理
// @Description  外部サービスからのWebhookリクエストを処理します
// @Tags         notifications
// @Accept       json
// @Produce      json
// @Param        payload body object true "Webhookペイロード"
// @Success      200 {object} MessageResponse "Webhook受信成功"
// @Failure      400 {object} ErrorResponse "リクエストが無効"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /notifications/webhook [post]
func (c *NotificationController) WebhookHandler(ctx *gin.Context) <span class="cov0" title="0">{
        var payload map[string]interface{}
        if err := ctx.ShouldBindJSON(&amp;payload); err != nil </span><span class="cov0" title="0">{
                c.logError("bind webhook payload", err)
                ctx.JSON(http.StatusBadRequest, dto.ErrorResponse{
                        Error:   "invalid_payload",
                        Message: "Webhookペイロードが無効です",
                })
                return
        }</span>

        // Webhookの検証処理やビジネスロジックを実装
        <span class="cov0" title="0">c.logger.Info("Webhook received", logger.Any("payload", payload))

        ctx.JSON(http.StatusOK, dto.SuccessResponse{
                Success: true,
                Message: "Webhookを受信しました",
        })</span>
}

// === ヘルパーメソッド ===

func (c *NotificationController) validateUUID(id string, fieldName string) (uuid.UUID, error) <span class="cov0" title="0">{
        parsedID, err := uuid.Parse(id)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Invalid UUID format",
                        logger.String("field", fieldName),
                        logger.String("value", id),
                        logger.Error(err))
                return uuid.Nil, err
        }</span>
        <span class="cov0" title="0">return parsedID, nil</span>
}

func (c *NotificationController) logError(operation string, err error, fields ...zapcore.Field) <span class="cov0" title="0">{
        c.logger.Error("Operation failed",
                append([]zapcore.Field{
                        logger.String("operation", operation),
                        logger.Error(err),
                }, fields...)...)
}</span>

// RegisterNotificationRoutes は通知コントローラーのルートを登録する
func RegisterNotificationRoutes(router *gin.RouterGroup, controller *NotificationController) <span class="cov0" title="0">{
        notifications := router.Group("/notifications")
        </span><span class="cov0" title="0">{
                notifications.POST("", controller.CreateNotification)
                notifications.GET("/:id", controller.GetNotification)
                notifications.GET("/user/:user_id", controller.GetUserNotifications)
                notifications.POST("/:id/send", controller.SendNotification)
                notifications.PUT("/:id/read", controller.MarkNotificationAsRead)
                notifications.GET("/user/:user_id/unread/count", controller.GetUnreadNotificationCount)
                notifications.PUT("/user/:user_id/read-all", controller.MarkAllNotificationsAsRead)
                notifications.POST("/webhook", controller.WebhookHandler)
        }</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package database

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "time"

        "github.com/hryt430/Yotei+/internal/modules/notification/domain"
        "github.com/hryt430/Yotei+/pkg/logger"
)

// NotificationServiceRepository はSQLを使用した通知リポジトリの実装
type NotificationServiceRepository struct {
        SqlHandler
        Logger logger.Logger
}

// Save は通知を保存する
func (r *NotificationServiceRepository) Save(ctx context.Context, notification *domain.Notification) error <span class="cov0" title="0">{
        // メタデータをJSON文字列に変換
        metadataJSON, err := json.Marshal(notification.Metadata)
        if err != nil </span><span class="cov0" title="0">{
                r.Logger.Error("Failed to marshal metadata", logger.Error(err))
                return fmt.Errorf("failed to marshal metadata: %w", err)
        }</span>

        // 送信日時の処理
        <span class="cov0" title="0">var sentAt interface{}
        if notification.SentAt != nil </span><span class="cov0" title="0">{
                sentAt = *notification.SentAt
        }</span> else<span class="cov0" title="0"> {
                sentAt = nil
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO ` + "`Yotei-Plus`" + `.notifications (
                        id, user_id, title, message, type, status, metadata, created_at, updated_at, sent_at
                ) VALUES (
                        ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
                ) ON DUPLICATE KEY UPDATE
                        user_id = VALUES(user_id),
                        title = VALUES(title),
                        message = VALUES(message),
                        type = VALUES(type),
                        status = VALUES(status),
                        metadata = VALUES(metadata),
                        updated_at = VALUES(updated_at),
                        sent_at = VALUES(sent_at)
        `

        _, err = r.Execute(
                query,
                notification.ID,
                notification.UserID,
                notification.Title,
                notification.Message,
                notification.Type,
                notification.Status,
                metadataJSON,
                notification.CreatedAt,
                notification.UpdatedAt,
                sentAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                r.Logger.Error("Failed to save notification", logger.Any("id", notification.ID), logger.Error(err))
                return fmt.Errorf("failed to save notification: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// FindByID は指定されたIDの通知を取得する
func (r *NotificationServiceRepository) FindByID(ctx context.Context, id string) (*domain.Notification, error) <span class="cov0" title="0">{
        query := `
                SELECT 
                        id, user_id, title, message, type, status, metadata, created_at, updated_at, sent_at
                FROM 
                        ` + "`Yotei-Plus`" + `.notifications
                WHERE 
                        id = ?
        `

        row, err := r.Query(query, id)
        if err != nil </span><span class="cov0" title="0">{
                r.Logger.Error("Failed to query notification", logger.Any("id", id), logger.Error(err))
                return nil, fmt.Errorf("failed to query notification: %w", err)
        }</span>
        <span class="cov0" title="0">defer row.Close()

        if !row.Next() </span><span class="cov0" title="0">{
                return nil, nil // 通知が見つからない場合
        }</span>

        <span class="cov0" title="0">var (
                notification domain.Notification
                metadataJSON []byte
                sentAt       sql.NullTime
        )

        err = row.Scan(
                &amp;notification.ID,
                &amp;notification.UserID,
                &amp;notification.Title,
                &amp;notification.Message,
                &amp;notification.Type,
                &amp;notification.Status,
                &amp;metadataJSON,
                &amp;notification.CreatedAt,
                &amp;notification.UpdatedAt,
                &amp;sentAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                r.Logger.Error("Failed to scan notification", logger.Any("id", id), logger.Error(err))
                return nil, fmt.Errorf("failed to scan notification: %w", err)
        }</span>

        // メタデータのデコード
        <span class="cov0" title="0">if err := json.Unmarshal(metadataJSON, &amp;notification.Metadata); err != nil </span><span class="cov0" title="0">{
                r.Logger.Error("Failed to unmarshal metadata", logger.Error(err))
                return nil, fmt.Errorf("failed to unmarshal metadata: %w", err)
        }</span>

        // 送信日時の処理
        <span class="cov0" title="0">if sentAt.Valid </span><span class="cov0" title="0">{
                notification.SentAt = &amp;sentAt.Time
        }</span>

        <span class="cov0" title="0">return &amp;notification, nil</span>
}

// FindByUserID は指定されたユーザーIDの通知を取得する
func (r *NotificationServiceRepository) FindByUserID(ctx context.Context, userID string, limit, offset int) ([]*domain.Notification, error) <span class="cov0" title="0">{
        query := `
                SELECT 
                        id, user_id, title, message, type, status, metadata, created_at, updated_at, sent_at
                FROM 
                        ` + "`Yotei-Plus`" + `.notifications
                WHERE 
                        user_id = ?
                ORDER BY 
                        created_at DESC
                LIMIT ? OFFSET ?
        `

        rows, err := r.Query(query, userID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                r.Logger.Error("Failed to query notifications", logger.Any("userID", userID), logger.Error(err))
                return nil, fmt.Errorf("failed to query notifications: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        notifications := make([]*domain.Notification, 0)
        for rows.Next() </span><span class="cov0" title="0">{
                var (
                        notification domain.Notification
                        metadataJSON []byte
                        sentAt       sql.NullTime
                )

                err := rows.Scan(
                        &amp;notification.ID,
                        &amp;notification.UserID,
                        &amp;notification.Title,
                        &amp;notification.Message,
                        &amp;notification.Type,
                        &amp;notification.Status,
                        &amp;metadataJSON,
                        &amp;notification.CreatedAt,
                        &amp;notification.UpdatedAt,
                        &amp;sentAt,
                )

                if err != nil </span><span class="cov0" title="0">{
                        r.Logger.Error("Failed to scan notification row", logger.Error(err))
                        return nil, fmt.Errorf("failed to scan notification row: %w", err)
                }</span>

                // メタデータのデコード
                <span class="cov0" title="0">if err := json.Unmarshal(metadataJSON, &amp;notification.Metadata); err != nil </span><span class="cov0" title="0">{
                        r.Logger.Error("Failed to unmarshal metadata", logger.Error(err))
                        return nil, fmt.Errorf("failed to unmarshal metadata: %w", err)
                }</span>

                // 送信日時の処理
                <span class="cov0" title="0">if sentAt.Valid </span><span class="cov0" title="0">{
                        notification.SentAt = &amp;sentAt.Time
                }</span>

                <span class="cov0" title="0">notifications = append(notifications, &amp;notification)</span>
        }

        <span class="cov0" title="0">return notifications, nil</span>
}

// UpdateStatus は通知のステータスを更新する
func (r *NotificationServiceRepository) UpdateStatus(ctx context.Context, id string, status domain.NotificationStatus) error <span class="cov0" title="0">{
        now := time.Now()

        query := `
                UPDATE ` + "`Yotei-Plus`" + `.notifications
                SET 
                        status = ?,
                        updated_at = ?,
                        sent_at = CASE 
                                WHEN ? = 'SENT' THEN ?
                                ELSE sent_at
                        END
                WHERE 
                        id = ?
        `

        var sentAt interface{}
        if status == domain.StatusSent </span><span class="cov0" title="0">{
                sentAt = now
        }</span> else<span class="cov0" title="0"> {
                sentAt = nil
        }</span>

        <span class="cov0" title="0">result, err := r.Execute(query, status, now, status, sentAt, id)
        if err != nil </span><span class="cov0" title="0">{
                r.Logger.Error("Failed to update notification status", logger.Any("id", id), logger.Error(err))
                return fmt.Errorf("failed to update notification status: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                r.Logger.Error("Failed to get rows affected", logger.Error(err))
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("notification not found: %s", id)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CountByUserIDAndStatus はユーザーIDとステータスに基づいて通知数を取得する
func (r *NotificationServiceRepository) CountByUserIDAndStatus(ctx context.Context, userID string, status domain.NotificationStatus) (int, error) <span class="cov0" title="0">{
        query := `
                SELECT COUNT(*)
                FROM ` + "`Yotei-Plus`" + `.notifications
                WHERE user_id = ? AND status = ?
        `

        row, err := r.Query(query, userID, status)
        if err != nil </span><span class="cov0" title="0">{
                r.Logger.Error("Failed to query notification count", logger.Any("userID", userID), logger.Any("status", status), logger.Error(err))
                return 0, fmt.Errorf("failed to query notification count: %w", err)
        }</span>
        <span class="cov0" title="0">defer row.Close()

        var count int
        if row.Next() </span><span class="cov0" title="0">{
                if err := row.Scan(&amp;count); err != nil </span><span class="cov0" title="0">{
                        r.Logger.Error("Failed to scan count", logger.Error(err))
                        return 0, fmt.Errorf("failed to scan count: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return count, nil</span>
}

// FindPendingNotifications は保留中の通知を取得する
func (r *NotificationServiceRepository) FindPendingNotifications(ctx context.Context, limit int) ([]*domain.Notification, error) <span class="cov0" title="0">{
        query := `
                SELECT 
                        id, user_id, title, message, type, status, metadata, created_at, updated_at, sent_at
                FROM 
                        ` + "`Yotei-Plus`" + `.notifications
                WHERE 
                        status = ?
                ORDER BY 
                        created_at ASC
                LIMIT ?
        `

        rows, err := r.Query(query, domain.StatusPending, limit)
        if err != nil </span><span class="cov0" title="0">{
                r.Logger.Error("Failed to query pending notifications", logger.Error(err))
                return nil, fmt.Errorf("failed to query pending notifications: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        notifications := make([]*domain.Notification, 0)
        for rows.Next() </span><span class="cov0" title="0">{
                var (
                        notification domain.Notification
                        metadataJSON []byte
                        sentAt       sql.NullTime
                )

                err := rows.Scan(
                        &amp;notification.ID,
                        &amp;notification.UserID,
                        &amp;notification.Title,
                        &amp;notification.Message,
                        &amp;notification.Type,
                        &amp;notification.Status,
                        &amp;metadataJSON,
                        &amp;notification.CreatedAt,
                        &amp;notification.UpdatedAt,
                        &amp;sentAt,
                )

                if err != nil </span><span class="cov0" title="0">{
                        r.Logger.Error("Failed to scan notification row", logger.Error(err))
                        return nil, fmt.Errorf("failed to scan notification row: %w", err)
                }</span>

                // メタデータのデコード
                <span class="cov0" title="0">if err := json.Unmarshal(metadataJSON, &amp;notification.Metadata); err != nil </span><span class="cov0" title="0">{
                        r.Logger.Error("Failed to unmarshal metadata", logger.Error(err))
                        return nil, fmt.Errorf("failed to unmarshal metadata: %w", err)
                }</span>

                // 送信日時の処理
                <span class="cov0" title="0">if sentAt.Valid </span><span class="cov0" title="0">{
                        notification.SentAt = &amp;sentAt.Time
                }</span>

                <span class="cov0" title="0">notifications = append(notifications, &amp;notification)</span>
        }

        <span class="cov0" title="0">return notifications, nil</span>
}

// 通知を削除するメソッド
func (r *NotificationServiceRepository) Delete(ctx context.Context, id string) error <span class="cov0" title="0">{
        query := `DELETE FROM ` + "`Yotei-Plus`" + `.notifications WHERE id = ?`

        result, err := r.Execute(query, id)
        if err != nil </span><span class="cov0" title="0">{
                r.Logger.Error("Failed to delete notification", logger.Any("id", id), logger.Error(err))
                return fmt.Errorf("failed to delete notification: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                r.Logger.Error("Failed to get rows affected", logger.Error(err))
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("notification not found: %s", id)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *NotificationServiceRepository) MarkAsRead(ctx context.Context, id string) error <span class="cov0" title="0">{
        return r.UpdateStatus(ctx, id, domain.StatusRead)
}</span>

func (r *NotificationServiceRepository) MarkAsSent(ctx context.Context, id string) error <span class="cov0" title="0">{
        return r.UpdateStatus(ctx, id, domain.StatusSent)
}</span>

func (r *NotificationServiceRepository) MarkAsFailed(ctx context.Context, id string) error <span class="cov0" title="0">{
        return r.UpdateStatus(ctx, id, domain.StatusFailed)
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package dto

import (
        "time"

        "github.com/hryt430/Yotei+/internal/modules/notification/domain"
        "github.com/hryt430/Yotei+/internal/modules/notification/usecase/input"
)

// === リクエストDTO ===

type CreateNotificationRequest struct {
        UserID   string            `json:"user_id" binding:"required" example:"123e4567-e89b-12d3-a456-426614174000"`
        Type     string            `json:"type" binding:"required" example:"TASK_ASSIGNED"`
        Title    string            `json:"title" binding:"required" example:"新しいタスクが割り当てられました"`
        Message  string            `json:"message" binding:"required" example:"「重要なプロジェクト」タスクが割り当てられました"`
        Metadata map[string]string `json:"metadata,omitempty" example:"{\"task_id\":\"task-123\",\"priority\":\"HIGH\"}"`
        Channels []string          `json:"channels" binding:"required" example:"[\"app\",\"line\"]"`
} // @name CreateNotificationRequest

type SendNotificationRequest struct {
        NotificationID string `json:"notification_id" binding:"required" example:"123e4567-e89b-12d3-a456-426614174000"`
} // @name SendNotificationRequest

type MarkAsReadRequest struct {
        NotificationID string `json:"notification_id" binding:"required" example:"123e4567-e89b-12d3-a456-426614174000"`
} // @name MarkAsReadRequest

// === レスポンスDTO ===

type NotificationResponse struct {
        ID        string            `json:"id" example:"123e4567-e89b-12d3-a456-426614174000"`
        UserID    string            `json:"user_id" example:"123e4567-e89b-12d3-a456-426614174000"`
        Type      string            `json:"type" example:"TASK_ASSIGNED"`
        Title     string            `json:"title" example:"新しいタスクが割り当てられました"`
        Message   string            `json:"message" example:"「重要なプロジェクト」タスクが割り当てられました"`
        Status    string            `json:"status" example:"SENT"`
        Metadata  map[string]string `json:"metadata,omitempty" example:"{\"task_id\":\"task-123\",\"priority\":\"HIGH\"}"`
        CreatedAt time.Time         `json:"created_at" example:"2024-01-01T00:00:00Z"`
        UpdatedAt time.Time         `json:"updated_at" example:"2024-01-01T00:00:00Z"`
        SentAt    *time.Time        `json:"sent_at,omitempty" example:"2024-01-01T00:00:00Z"`
} // @name NotificationResponse

type NotificationListResponse struct {
        Notifications []NotificationResponse `json:"notifications"`
        Pagination    PaginationInfo         `json:"pagination"`
} // @name NotificationListResponse

type UnreadCountResponse struct {
        Count int `json:"count" example:"5"`
} // @name UnreadCountResponse

type PaginationInfo struct {
        Page       int `json:"page" example:"1"`
        PageSize   int `json:"page_size" example:"10"`
        Total      int `json:"total" example:"100"`
        TotalPages int `json:"total_pages" example:"10"`
} // @name PaginationInfo

// === 共通レスポンス ===

type SuccessResponse struct {
        Success bool   `json:"success" example:"true"`
        Message string `json:"message" example:"通知が正常に作成されました"`
} // @name SuccessResponse

type ErrorResponse struct {
        Error   string `json:"error" example:"VALIDATION_ERROR"`
        Message string `json:"message" example:"リクエストパラメータが不正です"`
} // @name ErrorResponse

// === 変換関数 ===

// ToNotificationResponse はdomain.NotificationをNotificationResponseに変換する
func ToNotificationResponse(notification *domain.Notification) *NotificationResponse <span class="cov0" title="0">{
        return &amp;NotificationResponse{
                ID:        notification.ID,
                UserID:    notification.UserID,
                Type:      string(notification.Type),
                Title:     notification.Title,
                Message:   notification.Message,
                Status:    string(notification.Status),
                Metadata:  notification.Metadata,
                CreatedAt: notification.CreatedAt,
                UpdatedAt: notification.UpdatedAt,
                SentAt:    notification.SentAt,
        }
}</span>

// ToNotificationListResponse は通知一覧をNotificationListResponseに変換する
func ToNotificationListResponse(notifications []*domain.Notification, total, page, pageSize int) *NotificationListResponse <span class="cov0" title="0">{
        notificationResponses := make([]NotificationResponse, len(notifications))
        for i, notification := range notifications </span><span class="cov0" title="0">{
                notificationResponses[i] = *ToNotificationResponse(notification)
        }</span>

        <span class="cov0" title="0">totalPages := total / pageSize
        if total%pageSize &gt; 0 </span><span class="cov0" title="0">{
                totalPages++
        }</span>

        <span class="cov0" title="0">return &amp;NotificationListResponse{
                Notifications: notificationResponses,
                Pagination: PaginationInfo{
                        Page:       page,
                        PageSize:   pageSize,
                        Total:      total,
                        TotalPages: totalPages,
                },
        }</span>
}

// ToCreateNotificationInput はCreateNotificationRequestをinput.CreateNotificationInputに変換する
func ToCreateNotificationInput(req *CreateNotificationRequest) *input.CreateNotificationInput <span class="cov0" title="0">{
        return &amp;input.CreateNotificationInput{
                UserID:   req.UserID,
                Type:     req.Type,
                Title:    req.Title,
                Message:  req.Message,
                Metadata: req.Metadata,
                Channels: req.Channels,
        }
}</span>

// ToGetNotificationsInput はパラメータからinput.GetNotificationsInputを作成する
func ToGetNotificationsInput(userID string, limit, offset int) *input.GetNotificationsInput <span class="cov0" title="0">{
        return &amp;input.GetNotificationsInput{
                UserID: userID,
                Limit:  limit,
                Offset: offset,
        }
}</pre>
		
		<pre class="file" id="file34" style="display: none">package websocket

import (
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/gorilla/websocket"
        "github.com/hryt430/Yotei+/pkg/logger"
        "go.uber.org/zap"
)

const (
        // クライアント→サーバーのメッセージ読み取りタイムアウト
        pongWait = 60 * time.Second

        // サーバー→クライアントのPing送信間隔
        pingPeriod = (pongWait * 9) / 10

        // メッセージの最大サイズ
        maxMessageSize = 1024
)

var upgrader = websocket.Upgrader{
        ReadBufferSize:  1024,
        WriteBufferSize: 1024,
        CheckOrigin: func(r *http.Request) bool <span class="cov0" title="0">{
                return true // 開発用に全てのオリジンを許可（本番環境では適切に制限すること）
        }</span>,
}

// Client はWebSocketクライアント（ロガー追加版）
type Client struct {
        hub         *Hub
        conn        *websocket.Conn
        send        chan []byte
        UserID      string
        remoteAddr  string
        logger      logger.Logger
        connectedAt time.Time
}

// NewClient は新しいWebSocketクライアントを作成（ロガー追加版）
func NewClient(hub *Hub, conn *websocket.Conn, userID string, logger logger.Logger) *Client <span class="cov0" title="0">{
        return &amp;Client{
                hub:         hub,
                conn:        conn,
                send:        make(chan []byte, 256),
                UserID:      userID,
                remoteAddr:  conn.RemoteAddr().String(),
                logger:      logger,
                connectedAt: time.Now(),
        }
}</span>

// ReadPump はクライアントからのメッセージ読み取りループ（ロガー追加版）
func (c *Client) ReadPump() <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                c.logger.Info("Read pump stopped, cleaning up",
                        zap.Any("userID", c.UserID),
                        zap.Any("remoteAddr", c.remoteAddr),
                        zap.Any("connectionDuration", time.Since(c.connectedAt)))
                c.hub.unregister &lt;- c
                c.conn.Close()
        }</span>()

        <span class="cov0" title="0">c.conn.SetReadLimit(maxMessageSize)
        c.conn.SetReadDeadline(time.Now().Add(pongWait))
        c.conn.SetPongHandler(func(string) error </span><span class="cov0" title="0">{
                c.logger.Debug("Pong received", zap.Any("userID", c.UserID))
                c.conn.SetReadDeadline(time.Now().Add(pongWait))
                return nil
        }</span>)

        <span class="cov0" title="0">c.logger.Info("Starting read pump",
                zap.Any("userID", c.UserID),
                zap.Any("remoteAddr", c.remoteAddr))

        // クライアント側からの切断を検知するための無限ループ
        for </span><span class="cov0" title="0">{
                messageType, message, err := c.conn.ReadMessage()
                if err != nil </span><span class="cov0" title="0">{
                        if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) </span><span class="cov0" title="0">{
                                c.logger.Error("WebSocket read error",
                                        zap.Any("userID", c.UserID),
                                        zap.Any("remoteAddr", c.remoteAddr),
                                        zap.Error(err))
                        }</span> else<span class="cov0" title="0"> {
                                c.logger.Info("Client disconnected normally",
                                        zap.Any("userID", c.UserID),
                                        zap.Any("remoteAddr", c.remoteAddr))
                        }</span>
                        <span class="cov0" title="0">break</span>
                }

                // メッセージを受信した場合のログ（デバッグ用）
                <span class="cov0" title="0">c.logger.Debug("Message received from client",
                        zap.Any("userID", c.UserID),
                        zap.Any("messageType", messageType),
                        zap.Any("messageSize", len(message)))</span>

                // 実際にはクライアントからのメッセージ処理は今回必要ないが、
                // 接続維持のためにReadMessageを呼び出す
        }
}

// WritePump はクライアントへのメッセージ送信ループ（ロガー追加版）
func (c *Client) WritePump() <span class="cov0" title="0">{
        ticker := time.NewTicker(pingPeriod)
        defer func() </span><span class="cov0" title="0">{
                ticker.Stop()
                c.logger.Info("Write pump stopped",
                        zap.Any("userID", c.UserID),
                        zap.Any("remoteAddr", c.remoteAddr))
                c.conn.Close()
        }</span>()

        <span class="cov0" title="0">c.logger.Info("Starting write pump",
                zap.Any("userID", c.UserID),
                zap.Any("remoteAddr", c.remoteAddr))

        for </span><span class="cov0" title="0">{
                select </span>{
                case message, ok := &lt;-c.send:<span class="cov0" title="0">
                        c.conn.SetWriteDeadline(time.Now().Add(10 * time.Second))
                        if !ok </span><span class="cov0" title="0">{
                                // ハブがチャネルを閉じた
                                c.logger.Info("Send channel closed by hub",
                                        zap.Any("userID", c.UserID))
                                c.conn.WriteMessage(websocket.CloseMessage, []byte{})
                                return
                        }</span>

                        <span class="cov0" title="0">w, err := c.conn.NextWriter(websocket.TextMessage)
                        if err != nil </span><span class="cov0" title="0">{
                                c.logger.Error("Failed to get next writer",
                                        zap.Any("userID", c.UserID),
                                        zap.Error(err))
                                return
                        }</span>
                        <span class="cov0" title="0">w.Write(message)

                        // キューに残っているメッセージがあれば、追加で送信
                        n := len(c.send)
                        for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                                w.Write([]byte{'\n'})
                                w.Write(&lt;-c.send)
                        }</span>

                        <span class="cov0" title="0">if err := w.Close(); err != nil </span><span class="cov0" title="0">{
                                c.logger.Error("Failed to close writer",
                                        zap.Any("userID", c.UserID),
                                        zap.Error(err))
                                return
                        }</span>

                        <span class="cov0" title="0">c.logger.Debug("Message sent to client",
                                zap.Any("userID", c.UserID),
                                zap.Any("messageSize", len(message)),
                                zap.Any("batchSize", n+1))</span>

                case &lt;-ticker.C:<span class="cov0" title="0">
                        c.conn.SetWriteDeadline(time.Now().Add(10 * time.Second))
                        if err := c.conn.WriteMessage(websocket.PingMessage, nil); err != nil </span><span class="cov0" title="0">{
                                c.logger.Error("Failed to send ping",
                                        zap.Any("userID", c.UserID),
                                        zap.Error(err))
                                return
                        }</span>
                        <span class="cov0" title="0">c.logger.Debug("Ping sent", zap.Any("userID", c.UserID))</span>
                }
        }
}

// ServeWs はWebSocket接続をハンドリングする（ロガー追加版）
func ServeWs(hub *Hub, logger logger.Logger) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // ミドルウェアで設定されたユーザーIDを取得
                userID, exists := c.Get("user_id")
                if !exists </span><span class="cov0" title="0">{
                        logger.Warn("WebSocket connection without user authentication",
                                zap.Any("remoteAddr", c.ClientIP()))
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "authentication required"})
                        return
                }</span>

                <span class="cov0" title="0">userIDStr := userID.(string)
                logger.Info("WebSocket upgrade request",
                        zap.Any("userID", userIDStr),
                        zap.Any("remoteAddr", c.ClientIP()))

                // WebSocketにアップグレード
                conn, err := upgrader.Upgrade(c.Writer, c.Request, nil)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to upgrade to WebSocket",
                                zap.Any("userID", userIDStr),
                                zap.Any("remoteAddr", c.ClientIP()),
                                zap.Error(err))
                        return
                }</span>

                <span class="cov0" title="0">logger.Info("WebSocket connection established",
                        zap.Any("userID", userIDStr),
                        zap.Any("remoteAddr", conn.RemoteAddr().String()))

                // クライアント作成
                client := NewClient(hub, conn, userIDStr, logger)
                client.hub.register &lt;- client

                // クライアントのループを開始
                go client.WritePump()
                go client.ReadPump()</span>
        }
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package websocket

import (
        "context"
        "encoding/json"
        "sync"

        "github.com/hryt430/Yotei+/internal/modules/notification/domain"
        "github.com/hryt430/Yotei+/pkg/logger"
)

// Hub はWebSocketクライアントを管理するハブ
type Hub struct {
        // クライアントマップ（キー：ユーザーID）
        clients   map[string]map[*Client]bool
        clientsMu sync.RWMutex

        // クライアント登録チャネル
        register chan *Client

        // クライアント登録解除チャネル
        unregister chan *Client

        // 通知送信チャネル
        broadcast chan *domain.Notification

        // ロガー
        logger logger.Logger
}

// NewHub はWebSocketハブを作成する
func NewHub(logger logger.Logger) *Hub <span class="cov0" title="0">{
        return &amp;Hub{
                clients:    make(map[string]map[*Client]bool),
                register:   make(chan *Client),
                unregister: make(chan *Client),
                broadcast:  make(chan *domain.Notification),
                logger:     logger,
        }
}</span>

// Run はWebSocketハブを起動する
func (h *Hub) Run(ctx context.Context) error <span class="cov0" title="0">{
        h.logger.Info("Starting WebSocket hub")

        // 停止時のクリーンアップ用
        defer h.cleanup()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        h.logger.Info("WebSocket hub stopping due to context cancellation")
                        return ctx.Err()</span>

                case client := &lt;-h.register:<span class="cov0" title="0">
                        h.clientsMu.Lock()
                        if _, ok := h.clients[client.UserID]; !ok </span><span class="cov0" title="0">{
                                h.clients[client.UserID] = make(map[*Client]bool)
                        }</span>
                        <span class="cov0" title="0">h.clients[client.UserID][client] = true
                        h.clientsMu.Unlock()

                        h.logger.Info("Client registered",
                                logger.Any("userID", client.UserID),
                                logger.Any("totalClients", len(h.clients)))</span>

                case client := &lt;-h.unregister:<span class="cov0" title="0">
                        h.clientsMu.Lock()
                        if _, ok := h.clients[client.UserID]; ok </span><span class="cov0" title="0">{
                                delete(h.clients[client.UserID], client)
                                close(client.send)

                                // ユーザーIDに対応するクライアントがなくなった場合、マップエントリを削除
                                if len(h.clients[client.UserID]) == 0 </span><span class="cov0" title="0">{
                                        delete(h.clients, client.UserID)
                                }</span>
                        }
                        <span class="cov0" title="0">h.clientsMu.Unlock()

                        h.logger.Info("Client unregistered",
                                logger.Any("userID", client.UserID),
                                logger.Any("totalClients", len(h.clients)))</span>

                case notification := &lt;-h.broadcast:<span class="cov0" title="0">
                        // context がキャンセルされている場合は処理をスキップ
                        if ctx.Err() != nil </span><span class="cov0" title="0">{
                                h.logger.Debug("Skipping notification broadcast due to context cancellation",
                                        logger.Any("notificationID", notification.ID))
                                continue</span>
                        }

                        // 通知対象ユーザーのクライアント全てに送信
                        <span class="cov0" title="0">h.clientsMu.RLock()
                        if clients, ok := h.clients[notification.UserID]; ok </span><span class="cov0" title="0">{
                                notificationJSON, err := json.Marshal(notification)
                                if err != nil </span><span class="cov0" title="0">{
                                        h.logger.Error("Failed to marshal notification",
                                                logger.Any("notificationID", notification.ID),
                                                logger.Error(err))
                                        h.clientsMu.RUnlock()
                                        continue</span>
                                }

                                <span class="cov0" title="0">sentCount := 0
                                failedCount := 0

                                for client := range clients </span><span class="cov0" title="0">{
                                        select </span>{
                                        case client.send &lt;- notificationJSON:<span class="cov0" title="0">
                                                sentCount++</span>
                                        default:<span class="cov0" title="0">
                                                h.logger.Warn("Client send channel full, closing connection",
                                                        logger.Any("userID", client.UserID))
                                                close(client.send)
                                                delete(clients, client)
                                                failedCount++</span>
                                        }
                                }

                                <span class="cov0" title="0">h.logger.Info("Notification sent",
                                        logger.Any("notificationID", notification.ID),
                                        logger.Any("userID", notification.UserID),
                                        logger.Any("sentCount", sentCount),
                                        logger.Any("failedCount", failedCount))</span>
                        } else<span class="cov0" title="0"> {
                                h.logger.Debug("No clients connected for notification",
                                        logger.Any("notificationID", notification.ID),
                                        logger.Any("userID", notification.UserID))
                        }</span>
                        <span class="cov0" title="0">h.clientsMu.RUnlock()</span>
                }
        }
}

// cleanup は停止時のクリーンアップ処理を行う
func (h *Hub) cleanup() <span class="cov0" title="0">{
        h.logger.Info("Cleaning up WebSocket hub")

        h.clientsMu.Lock()
        defer h.clientsMu.Unlock()

        // 全クライアントを閉じる
        totalClients := 0
        for userID, clients := range h.clients </span><span class="cov0" title="0">{
                for client := range clients </span><span class="cov0" title="0">{
                        close(client.send)
                        totalClients++
                }</span>
                <span class="cov0" title="0">delete(h.clients, userID)</span>
        }

        <span class="cov0" title="0">h.logger.Info("WebSocket hub cleanup completed",
                logger.Any("closedClients", totalClients))</span>
}

// SendNotification は指定ユーザーに通知を送信する
func (h *Hub) SendNotification(notification *domain.Notification) <span class="cov0" title="0">{
        h.logger.Debug("Queueing notification for broadcast",
                logger.Any("notificationID", notification.ID),
                logger.Any("userID", notification.UserID))

        // ノンブロッキングで送信を試行
        select </span>{
        case h.broadcast &lt;- notification:<span class="cov0" title="0"></span>
                // 正常に送信
        default:<span class="cov0" title="0">
                h.logger.Warn("Broadcast channel full, dropping notification",
                        logger.Any("notificationID", notification.ID),
                        logger.Any("userID", notification.UserID))</span>
        }
}
</pre>
		
		<pre class="file" id="file36" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: output/notification_output.go

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        output "github.com/hryt430/Yotei+/internal/modules/notification/usecase/output"
)

// MockNotificationGateway is a mock of NotificationGateway interface.
type MockNotificationGateway struct {
        ctrl     *gomock.Controller
        recorder *MockNotificationGatewayMockRecorder
}

// MockNotificationGatewayMockRecorder is the mock recorder for MockNotificationGateway.
type MockNotificationGatewayMockRecorder struct {
        mock *MockNotificationGateway
}

// NewMockNotificationGateway creates a new mock instance.
func NewMockNotificationGateway(ctrl *gomock.Controller) *MockNotificationGateway <span class="cov0" title="0">{
        mock := &amp;MockNotificationGateway{ctrl: ctrl}
        mock.recorder = &amp;MockNotificationGatewayMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockNotificationGateway) EXPECT() *MockNotificationGatewayMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// SendNotification mocks base method.
func (m *MockNotificationGateway) SendNotification(ctx context.Context, userID, title, message string, metadata map[string]string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SendNotification", ctx, userID, title, message, metadata)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// SendNotification indicates an expected call of SendNotification.
func (mr *MockNotificationGatewayMockRecorder) SendNotification(ctx, userID, title, message, metadata interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendNotification", reflect.TypeOf((*MockNotificationGateway)(nil).SendNotification), ctx, userID, title, message, metadata)
}</span>

// MockAppNotificationGateway is a mock of AppNotificationGateway interface.
type MockAppNotificationGateway struct {
        ctrl     *gomock.Controller
        recorder *MockAppNotificationGatewayMockRecorder
}

// MockAppNotificationGatewayMockRecorder is the mock recorder for MockAppNotificationGateway.
type MockAppNotificationGatewayMockRecorder struct {
        mock *MockAppNotificationGateway
}

// NewMockAppNotificationGateway creates a new mock instance.
func NewMockAppNotificationGateway(ctrl *gomock.Controller) *MockAppNotificationGateway <span class="cov0" title="0">{
        mock := &amp;MockAppNotificationGateway{ctrl: ctrl}
        mock.recorder = &amp;MockAppNotificationGatewayMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAppNotificationGateway) EXPECT() *MockAppNotificationGatewayMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetUnreadCount mocks base method.
func (m *MockAppNotificationGateway) GetUnreadCount(ctx context.Context, userID string) (int, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUnreadCount", ctx, userID)
        ret0, _ := ret[0].(int)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUnreadCount indicates an expected call of GetUnreadCount.
func (mr *MockAppNotificationGatewayMockRecorder) GetUnreadCount(ctx, userID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUnreadCount", reflect.TypeOf((*MockAppNotificationGateway)(nil).GetUnreadCount), ctx, userID)
}</span>

// MarkAsRead mocks base method.
func (m *MockAppNotificationGateway) MarkAsRead(ctx context.Context, notificationID string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "MarkAsRead", ctx, notificationID)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// MarkAsRead indicates an expected call of MarkAsRead.
func (mr *MockAppNotificationGatewayMockRecorder) MarkAsRead(ctx, notificationID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MarkAsRead", reflect.TypeOf((*MockAppNotificationGateway)(nil).MarkAsRead), ctx, notificationID)
}</span>

// SendNotification mocks base method.
func (m *MockAppNotificationGateway) SendNotification(ctx context.Context, userID, title, message string, metadata map[string]string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SendNotification", ctx, userID, title, message, metadata)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// SendNotification indicates an expected call of SendNotification.
func (mr *MockAppNotificationGatewayMockRecorder) SendNotification(ctx, userID, title, message, metadata interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendNotification", reflect.TypeOf((*MockAppNotificationGateway)(nil).SendNotification), ctx, userID, title, message, metadata)
}</span>

// MockLineNotificationGateway is a mock of LineNotificationGateway interface.
type MockLineNotificationGateway struct {
        ctrl     *gomock.Controller
        recorder *MockLineNotificationGatewayMockRecorder
}

// MockLineNotificationGatewayMockRecorder is the mock recorder for MockLineNotificationGateway.
type MockLineNotificationGatewayMockRecorder struct {
        mock *MockLineNotificationGateway
}

// NewMockLineNotificationGateway creates a new mock instance.
func NewMockLineNotificationGateway(ctrl *gomock.Controller) *MockLineNotificationGateway <span class="cov0" title="0">{
        mock := &amp;MockLineNotificationGateway{ctrl: ctrl}
        mock.recorder = &amp;MockLineNotificationGatewayMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockLineNotificationGateway) EXPECT() *MockLineNotificationGatewayMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// SendLineNotification mocks base method.
func (m *MockLineNotificationGateway) SendLineNotification(ctx context.Context, lineUserID, message string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SendLineNotification", ctx, lineUserID, message)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// SendLineNotification indicates an expected call of SendLineNotification.
func (mr *MockLineNotificationGatewayMockRecorder) SendLineNotification(ctx, lineUserID, message interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendLineNotification", reflect.TypeOf((*MockLineNotificationGateway)(nil).SendLineNotification), ctx, lineUserID, message)
}</span>

// SendNotification mocks base method.
func (m *MockLineNotificationGateway) SendNotification(ctx context.Context, userID, title, message string, metadata map[string]string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SendNotification", ctx, userID, title, message, metadata)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// SendNotification indicates an expected call of SendNotification.
func (mr *MockLineNotificationGatewayMockRecorder) SendNotification(ctx, userID, title, message, metadata interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendNotification", reflect.TypeOf((*MockLineNotificationGateway)(nil).SendNotification), ctx, userID, title, message, metadata)
}</span>

// MockWebhookOutput is a mock of WebhookOutput interface.
type MockWebhookOutput struct {
        ctrl     *gomock.Controller
        recorder *MockWebhookOutputMockRecorder
}

// MockWebhookOutputMockRecorder is the mock recorder for MockWebhookOutput.
type MockWebhookOutputMockRecorder struct {
        mock *MockWebhookOutput
}

// NewMockWebhookOutput creates a new mock instance.
func NewMockWebhookOutput(ctrl *gomock.Controller) *MockWebhookOutput <span class="cov0" title="0">{
        mock := &amp;MockWebhookOutput{ctrl: ctrl}
        mock.recorder = &amp;MockWebhookOutputMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWebhookOutput) EXPECT() *MockWebhookOutputMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// SendWebhook mocks base method.
func (m *MockWebhookOutput) SendWebhook(ctx context.Context, event output.WebhookEvent, payload interface{}) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SendWebhook", ctx, event, payload)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// SendWebhook indicates an expected call of SendWebhook.
func (mr *MockWebhookOutputMockRecorder) SendWebhook(ctx, event, payload interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendWebhook", reflect.TypeOf((*MockWebhookOutput)(nil).SendWebhook), ctx, event, payload)
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: persistence/notification_repository.go

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        domain "github.com/hryt430/Yotei+/internal/modules/notification/domain"
)

// MockNotificationRepository is a mock of NotificationRepository interface.
type MockNotificationRepository struct {
        ctrl     *gomock.Controller
        recorder *MockNotificationRepositoryMockRecorder
}

// MockNotificationRepositoryMockRecorder is the mock recorder for MockNotificationRepository.
type MockNotificationRepositoryMockRecorder struct {
        mock *MockNotificationRepository
}

// NewMockNotificationRepository creates a new mock instance.
func NewMockNotificationRepository(ctrl *gomock.Controller) *MockNotificationRepository <span class="cov0" title="0">{
        mock := &amp;MockNotificationRepository{ctrl: ctrl}
        mock.recorder = &amp;MockNotificationRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockNotificationRepository) EXPECT() *MockNotificationRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CountByUserIDAndStatus mocks base method.
func (m *MockNotificationRepository) CountByUserIDAndStatus(ctx context.Context, userID string, status domain.NotificationStatus) (int, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CountByUserIDAndStatus", ctx, userID, status)
        ret0, _ := ret[0].(int)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CountByUserIDAndStatus indicates an expected call of CountByUserIDAndStatus.
func (mr *MockNotificationRepositoryMockRecorder) CountByUserIDAndStatus(ctx, userID, status interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CountByUserIDAndStatus", reflect.TypeOf((*MockNotificationRepository)(nil).CountByUserIDAndStatus), ctx, userID, status)
}</span>

// FindByID mocks base method.
func (m *MockNotificationRepository) FindByID(ctx context.Context, id string) (*domain.Notification, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindByID", ctx, id)
        ret0, _ := ret[0].(*domain.Notification)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindByID indicates an expected call of FindByID.
func (mr *MockNotificationRepositoryMockRecorder) FindByID(ctx, id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByID", reflect.TypeOf((*MockNotificationRepository)(nil).FindByID), ctx, id)
}</span>

// FindByUserID mocks base method.
func (m *MockNotificationRepository) FindByUserID(ctx context.Context, userID string, limit, offset int) ([]*domain.Notification, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindByUserID", ctx, userID, limit, offset)
        ret0, _ := ret[0].([]*domain.Notification)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindByUserID indicates an expected call of FindByUserID.
func (mr *MockNotificationRepositoryMockRecorder) FindByUserID(ctx, userID, limit, offset interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByUserID", reflect.TypeOf((*MockNotificationRepository)(nil).FindByUserID), ctx, userID, limit, offset)
}</span>

// FindPendingNotifications mocks base method.
func (m *MockNotificationRepository) FindPendingNotifications(ctx context.Context, limit int) ([]*domain.Notification, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindPendingNotifications", ctx, limit)
        ret0, _ := ret[0].([]*domain.Notification)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindPendingNotifications indicates an expected call of FindPendingNotifications.
func (mr *MockNotificationRepositoryMockRecorder) FindPendingNotifications(ctx, limit interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindPendingNotifications", reflect.TypeOf((*MockNotificationRepository)(nil).FindPendingNotifications), ctx, limit)
}</span>

// Save mocks base method.
func (m *MockNotificationRepository) Save(ctx context.Context, notification *domain.Notification) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Save", ctx, notification)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Save indicates an expected call of Save.
func (mr *MockNotificationRepositoryMockRecorder) Save(ctx, notification interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Save", reflect.TypeOf((*MockNotificationRepository)(nil).Save), ctx, notification)
}</span>

// UpdateStatus mocks base method.
func (m *MockNotificationRepository) UpdateStatus(ctx context.Context, id string, status domain.NotificationStatus) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateStatus", ctx, id, status)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateStatus indicates an expected call of UpdateStatus.
func (mr *MockNotificationRepositoryMockRecorder) UpdateStatus(ctx, id, status interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateStatus", reflect.TypeOf((*MockNotificationRepository)(nil).UpdateStatus), ctx, id, status)
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/hryt430/Yotei+/internal/common/domain (interfaces: UserValidator)

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        domain "github.com/hryt430/Yotei+/internal/common/domain"
)

// MockUserValidator is a mock of UserValidator interface.
type MockUserValidator struct {
        ctrl     *gomock.Controller
        recorder *MockUserValidatorMockRecorder
}

// MockUserValidatorMockRecorder is the mock recorder for MockUserValidator.
type MockUserValidatorMockRecorder struct {
        mock *MockUserValidator
}

// NewMockUserValidator creates a new mock instance.
func NewMockUserValidator(ctrl *gomock.Controller) *MockUserValidator <span class="cov0" title="0">{
        mock := &amp;MockUserValidator{ctrl: ctrl}
        mock.recorder = &amp;MockUserValidatorMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserValidator) EXPECT() *MockUserValidatorMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetUserInfo mocks base method.
func (m *MockUserValidator) GetUserInfo(arg0 context.Context, arg1 string) (*domain.UserInfo, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUserInfo", arg0, arg1)
        ret0, _ := ret[0].(*domain.UserInfo)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUserInfo indicates an expected call of GetUserInfo.
func (mr *MockUserValidatorMockRecorder) GetUserInfo(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserInfo", reflect.TypeOf((*MockUserValidator)(nil).GetUserInfo), arg0, arg1)
}</span>

// GetUsersInfoBatch mocks base method.
func (m *MockUserValidator) GetUsersInfoBatch(arg0 context.Context, arg1 []string) (map[string]*domain.UserInfo, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUsersInfoBatch", arg0, arg1)
        ret0, _ := ret[0].(map[string]*domain.UserInfo)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUsersInfoBatch indicates an expected call of GetUsersInfoBatch.
func (mr *MockUserValidatorMockRecorder) GetUsersInfoBatch(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUsersInfoBatch", reflect.TypeOf((*MockUserValidator)(nil).GetUsersInfoBatch), arg0, arg1)
}</span>

// UserExists mocks base method.
func (m *MockUserValidator) UserExists(arg0 context.Context, arg1 string) (bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UserExists", arg0, arg1)
        ret0, _ := ret[0].(bool)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UserExists indicates an expected call of UserExists.
func (mr *MockUserValidatorMockRecorder) UserExists(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UserExists", reflect.TypeOf((*MockUserValidator)(nil).UserExists), arg0, arg1)
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package notification

import (
        "context"
        "errors"
        "fmt"
        "time"

        commonDomain "github.com/hryt430/Yotei+/internal/common/domain"
        "github.com/hryt430/Yotei+/internal/modules/notification/domain"
        "github.com/hryt430/Yotei+/internal/modules/notification/usecase/input"
        "github.com/hryt430/Yotei+/internal/modules/notification/usecase/output"
        "github.com/hryt430/Yotei+/internal/modules/notification/usecase/persistence"
        "github.com/hryt430/Yotei+/pkg/logger"
)

// UserInfo は通知モジュール用のユーザー情報（共通定義を使用）
type UserInfo = commonDomain.UserInfo

// UserValidator は通知モジュール用のユーザーバリデーター（共通定義を使用）
type UserValidator = commonDomain.UserValidator

type notificationUseCase struct {
        repository    persistence.NotificationRepository
        appGateway    output.AppNotificationGateway
        lineGateway   output.LineNotificationGateway
        userValidator UserValidator
        logger        logger.Logger
}

// NewNotificationUseCase は通知ユースケースのインスタンスを作成する
func NewNotificationUseCase(
        repository persistence.NotificationRepository,
        appGateway output.AppNotificationGateway,
        lineGateway output.LineNotificationGateway,
        userValidator UserValidator,
        logger logger.Logger,
) input.NotificationUseCase <span class="cov8" title="1">{
        return &amp;notificationUseCase{
                repository:    repository,
                appGateway:    appGateway,
                lineGateway:   lineGateway,
                userValidator: userValidator,
                logger:        logger,
        }
}</span>

// CreateNotification は新しい通知を作成する
func (uc *notificationUseCase) CreateNotification(ctx context.Context, input input.CreateNotificationInput) (*domain.Notification, error) <span class="cov8" title="1">{
        // 入力バリデーション
        if err := uc.validateCreateInput(input); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("validation failed: %w", err)
        }</span>

        // ユーザー存在確認（統一インターフェース使用）
        <span class="cov8" title="1">exists, err := uc.userValidator.UserExists(ctx, input.UserID)
        if err != nil </span><span class="cov8" title="1">{
                uc.logger.Error("Failed to validate user existence", logger.Any("userID", input.UserID), logger.Error(err))
                return nil, fmt.Errorf("failed to validate user: %w", err)
        }</span>
        <span class="cov8" title="1">if !exists </span><span class="cov8" title="1">{
                return nil, errors.New("user not found")
        }</span>

        // 通知タイプの変換
        <span class="cov8" title="1">notificationType := uc.convertNotificationType(input.Type)

        // 通知エンティティの作成
        notification := domain.NewNotification(
                input.UserID,
                notificationType,
                input.Title,
                input.Message,
                input.Metadata,
        )

        // チャネルの追加
        if err := uc.addChannelsToNotification(ctx, notification, input); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to add channels: %w", err)
        }</span>

        // 通知をデータベースに保存
        <span class="cov8" title="1">if err := uc.repository.Save(ctx, notification); err != nil </span><span class="cov8" title="1">{
                uc.logger.Error("Failed to save notification", logger.Any("notificationID", notification.ID), logger.Error(err))
                return nil, fmt.Errorf("failed to save notification: %w", err)
        }</span>

        <span class="cov8" title="1">uc.logger.Info("Notification created successfully", logger.Any("notificationID", notification.ID), logger.Any("userID", input.UserID))
        return notification, nil</span>
}

// CreateScheduledNotification はスケジュール通知を作成する
func (uc *notificationUseCase) CreateScheduledNotification(
        ctx context.Context,
        userID, title, message string,
        notificationType domain.NotificationType,
        scheduledTime time.Time,
        metadata map[string]string,
) error <span class="cov0" title="0">{
        // ユーザー存在確認
        exists, err := uc.userValidator.UserExists(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to validate user: %w", err)
        }</span>
        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                return errors.New("user not found")
        }</span>

        // スケジュール時刻が未来であることを確認
        <span class="cov0" title="0">if scheduledTime.Before(time.Now()) </span><span class="cov0" title="0">{
                return errors.New("scheduled time must be in the future")
        }</span>

        <span class="cov0" title="0">notification := domain.NewNotification(userID, notificationType, title, message, metadata)
        notification.AddMetadata("scheduled_time", scheduledTime.Format(time.RFC3339))
        notification.AddChannel(domain.NewAppChannel(userID))

        if err := uc.repository.Save(ctx, notification); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save scheduled notification: %w", err)
        }</span>

        <span class="cov0" title="0">uc.logger.Info("Scheduled notification created",
                logger.Any("notificationID", notification.ID),
                logger.Any("scheduledTime", scheduledTime))

        return nil</span>
}

// SendNotification は通知を送信する（エラーハンドリング強化）
func (uc *notificationUseCase) SendNotification(ctx context.Context, id string) error <span class="cov8" title="1">{
        notification, err := uc.repository.FindByID(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to find notification: %w", err)
        }</span>

        <span class="cov8" title="1">if notification == nil </span><span class="cov8" title="1">{
                return errors.New("notification not found")
        }</span>

        // 送信済みの場合はスキップ
        <span class="cov8" title="1">if notification.Status == domain.StatusSent </span><span class="cov8" title="1">{
                uc.logger.Warn("Notification already sent", logger.Any("notificationID", id))
                return nil
        }</span>

        // 各チャネルに通知を送信（並行処理で高速化）
        <span class="cov8" title="1">return uc.sendToAllChannels(ctx, notification)</span>
}

// sendToAllChannels は全チャネルに並行して通知を送信
func (uc *notificationUseCase) sendToAllChannels(ctx context.Context, notification *domain.Notification) error <span class="cov8" title="1">{
        if len(notification.Channels) == 0 </span><span class="cov0" title="0">{
                // デフォルトでアプリ内通知チャネルを追加
                notification.AddChannel(domain.NewAppChannel(notification.UserID))
        }</span>

        <span class="cov8" title="1">errorCh := make(chan error, len(notification.Channels))

        for _, channel := range notification.Channels </span><span class="cov8" title="1">{
                go func(ch domain.Channel) </span><span class="cov8" title="1">{
                        defer func() </span><span class="cov8" title="1">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        uc.logger.Error("Panic in notification sending", logger.Any("panic", r))
                                        errorCh &lt;- fmt.Errorf("panic occurred: %v", r)
                                }</span>
                        }()

                        <span class="cov8" title="1">err := uc.sendToChannel(ctx, notification, ch)
                        errorCh &lt;- err</span>
                }(channel)
        }

        // 全チャネルの送信結果を待機
        <span class="cov8" title="1">var errors []error
        for i := 0; i &lt; len(notification.Channels); i++ </span><span class="cov8" title="1">{
                if err := &lt;-errorCh; err != nil </span><span class="cov8" title="1">{
                        errors = append(errors, err)
                }</span>
        }

        <span class="cov8" title="1">if len(errors) &gt; 0 </span><span class="cov8" title="1">{
                // 一部でも失敗した場合は失敗とする
                notification.MarkAsFailed()
                uc.repository.Save(ctx, notification)
                return fmt.Errorf("failed to send to %d channels: %v", len(errors), errors[0])
        }</span>

        // 全て成功
        <span class="cov8" title="1">notification.MarkAsSent()
        if err := uc.repository.Save(ctx, notification); err != nil </span><span class="cov0" title="0">{
                uc.logger.Error("Failed to update notification status to sent", logger.Error(err))
                return fmt.Errorf("failed to update notification status: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// sendToChannel は個別チャネルに送信
func (uc *notificationUseCase) sendToChannel(ctx context.Context, notification *domain.Notification, channel domain.Channel) error <span class="cov8" title="1">{
        switch channel.GetType() </span>{
        case domain.AppInternal:<span class="cov8" title="1">
                appChannel := channel.(*domain.AppChannel)
                return uc.appGateway.SendNotification(
                        ctx,
                        appChannel.UserID,
                        notification.Title,
                        notification.Message,
                        notification.Metadata,
                )</span>
        case domain.LineMessage:<span class="cov0" title="0">
                lineChannel := channel.(*domain.LineChannel)
                return uc.lineGateway.SendLineNotification(
                        ctx,
                        lineChannel.LineUserID,
                        notification.Title+"\n"+notification.Message,
                )</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported channel type: %s", channel.GetType())</span>
        }
}

// ProcessPendingNotifications は保留中の通知を処理する
func (uc *notificationUseCase) ProcessPendingNotifications(ctx context.Context, batchSize int) error <span class="cov0" title="0">{
        notifications, err := uc.repository.FindPendingNotifications(ctx, batchSize)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to find pending notifications: %w", err)
        }</span>

        <span class="cov0" title="0">uc.logger.Info("Processing pending notifications", logger.Any("count", len(notifications)))

        for _, notification := range notifications </span><span class="cov0" title="0">{
                if err := uc.SendNotification(ctx, notification.ID); err != nil </span><span class="cov0" title="0">{
                        uc.logger.Error("Failed to send pending notification",
                                logger.Any("notificationID", notification.ID),
                                logger.Error(err))
                        continue</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// validateCreateInput は作成入力をバリデーション
func (uc *notificationUseCase) validateCreateInput(input input.CreateNotificationInput) error <span class="cov8" title="1">{
        if input.UserID == "" </span><span class="cov8" title="1">{
                return errors.New("user ID is required")
        }</span>
        <span class="cov8" title="1">if input.Title == "" </span><span class="cov8" title="1">{
                return errors.New("title is required")
        }</span>
        <span class="cov8" title="1">if input.Message == "" </span><span class="cov0" title="0">{
                return errors.New("message is required")
        }</span>
        <span class="cov8" title="1">if len(input.Channels) == 0 </span><span class="cov8" title="1">{
                return errors.New("at least one channel is required")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// convertNotificationType は文字列を通知タイプに変換
func (uc *notificationUseCase) convertNotificationType(typeStr string) domain.NotificationType <span class="cov8" title="1">{
        switch typeStr </span>{
        case "APP_NOTIFICATION":<span class="cov0" title="0">
                return domain.AppNotification</span>
        case "TASK_ASSIGNED":<span class="cov8" title="1">
                return domain.TaskAssigned</span>
        case "TASK_COMPLETED":<span class="cov0" title="0">
                return domain.TaskCompleted</span>
        case "TASK_DUE_SOON":<span class="cov8" title="1">
                return domain.TaskDueSoon</span>
        case "SYSTEM_NOTICE":<span class="cov0" title="0">
                return domain.SystemNotice</span>
        default:<span class="cov0" title="0">
                return domain.SystemNotice</span>
        }
}

// addChannelsToNotification は通知にチャネルを追加
func (uc *notificationUseCase) addChannelsToNotification(ctx context.Context, notification *domain.Notification, input input.CreateNotificationInput) error <span class="cov8" title="1">{
        for _, channelName := range input.Channels </span><span class="cov8" title="1">{
                switch channelName </span>{
                case "app":<span class="cov8" title="1">
                        notification.AddChannel(domain.NewAppChannel(input.UserID))</span>
                case "line":<span class="cov8" title="1">
                        lineUserID := input.UserID
                        if lineID, ok := input.Metadata["line_user_id"]; ok </span><span class="cov8" title="1">{
                                lineUserID = lineID
                        }</span>
                        <span class="cov8" title="1">notification.AddChannel(domain.NewLineChannel(input.UserID, lineUserID, ""))</span>
                default:<span class="cov0" title="0">
                        uc.logger.Warn("Unknown channel type", logger.Any("channel", channelName))</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// MarkNotificationAsRead は通知を既読としてマークする
func (uc *notificationUseCase) MarkNotificationAsRead(ctx context.Context, id string) error <span class="cov8" title="1">{
        if err := uc.repository.UpdateStatus(ctx, id, domain.StatusRead); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to mark notification as read: %w", err)
        }</span>

        <span class="cov8" title="1">if err := uc.appGateway.MarkAsRead(ctx, id); err != nil </span><span class="cov8" title="1">{
                uc.logger.Error("Failed to mark app notification as read", logger.Error(err))
                // アプリ内通知の既読更新失敗は致命的ではないので続行
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetNotification は通知を取得する
func (uc *notificationUseCase) GetNotification(ctx context.Context, id string) (*domain.Notification, error) <span class="cov8" title="1">{
        notification, err := uc.repository.FindByID(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to find notification: %w", err)
        }</span>
        <span class="cov8" title="1">return notification, nil</span>
}

// GetUserNotifications はユーザーの通知一覧を取得する
func (uc *notificationUseCase) GetUserNotifications(ctx context.Context, input input.GetNotificationsInput) ([]*domain.Notification, error) <span class="cov0" title="0">{
        notifications, err := uc.repository.FindByUserID(ctx, input.UserID, input.Limit, input.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find user notifications: %w", err)
        }</span>
        <span class="cov0" title="0">return notifications, nil</span>
}

// GetUnreadNotificationCount はユーザーの未読通知数を取得する
func (uc *notificationUseCase) GetUnreadNotificationCount(ctx context.Context, userID string) (int, error) <span class="cov0" title="0">{
        count, err := uc.appGateway.GetUnreadCount(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get unread notification count: %w", err)
        }</span>
        <span class="cov0" title="0">return count, nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package domain

import (
        "crypto/rand"
        "encoding/hex"
        "errors"
        "time"

        "github.com/google/uuid"
)

// FriendshipStatus は友達関係のステータス
type FriendshipStatus string

const (
        FriendshipStatusPending  FriendshipStatus = "PENDING"  // 承認待ち
        FriendshipStatusAccepted FriendshipStatus = "ACCEPTED" // 承認済み
        FriendshipStatusBlocked  FriendshipStatus = "BLOCKED"  // ブロック
)

// Friendship は友達関係を表すドメインエンティティ
type Friendship struct {
        ID          uuid.UUID        `json:"id"`
        RequesterID uuid.UUID        `json:"requester_id"` // 申請者
        AddresseeID uuid.UUID        `json:"addressee_id"` // 申請先
        Status      FriendshipStatus `json:"status"`
        CreatedAt   time.Time        `json:"created_at"`
        UpdatedAt   time.Time        `json:"updated_at"`
        AcceptedAt  *time.Time       `json:"accepted_at,omitempty"`
        BlockedAt   *time.Time       `json:"blocked_at,omitempty"`
}

// NewFriendship は新しい友達申請を作成する
func NewFriendship(requesterID, addresseeID uuid.UUID) *Friendship <span class="cov8" title="1">{
        now := time.Now()
        return &amp;Friendship{
                ID:          uuid.New(),
                RequesterID: requesterID,
                AddresseeID: addresseeID,
                Status:      FriendshipStatusPending,
                CreatedAt:   now,
                UpdatedAt:   now,
        }
}</span>

// Accept は友達申請を承認する
func (f *Friendship) Accept() <span class="cov8" title="1">{
        f.Status = FriendshipStatusAccepted
        now := time.Now()
        f.AcceptedAt = &amp;now
        f.UpdatedAt = now
}</span>

// Block はユーザーをブロックする
func (f *Friendship) Block() <span class="cov8" title="1">{
        f.Status = FriendshipStatusBlocked
        now := time.Now()
        f.BlockedAt = &amp;now
        f.UpdatedAt = now
}</span>

// IsFriend は友達関係が成立しているかチェック
func (f *Friendship) IsFriend() bool <span class="cov8" title="1">{
        return f.Status == FriendshipStatusAccepted
}</span>

// IsBlocked はブロックされているかチェック
func (f *Friendship) IsBlocked() bool <span class="cov8" title="1">{
        return f.Status == FriendshipStatusBlocked
}</span>

// InvitationType は招待の種類
type InvitationType string

const (
        InvitationTypeFriend InvitationType = "FRIEND" // 友達招待
        InvitationTypeGroup  InvitationType = "GROUP"  // グループ招待
)

// InvitationMethod は招待方法
type InvitationMethod string

const (
        MethodInApp InvitationMethod = "IN_APP" // アプリ内通知
        MethodCode  InvitationMethod = "CODE"   // 招待コード
        MethodURL   InvitationMethod = "URL"    // URL共有
)

// InvitationStatus は招待のステータス
type InvitationStatus string

const (
        InvitationStatusPending  InvitationStatus = "PENDING"  // 送信済み（未処理）
        InvitationStatusAccepted InvitationStatus = "ACCEPTED" // 承認済み
        InvitationStatusDeclined InvitationStatus = "DECLINED" // 拒否
        InvitationStatusExpired  InvitationStatus = "EXPIRED"  // 期限切れ
        InvitationStatusCanceled InvitationStatus = "CANCELED" // キャンセル
)

// Invitation は招待を表すドメインエンティティ
type Invitation struct {
        ID          uuid.UUID        `json:"id"`
        Type        InvitationType   `json:"type"`
        Method      InvitationMethod `json:"method"`
        Status      InvitationStatus `json:"status"`
        InviterID   uuid.UUID        `json:"inviter_id"`             // 招待者
        InviteeID   *uuid.UUID       `json:"invitee_id,omitempty"`   // 被招待者（登録済みの場合）
        InviteeInfo *InviteeInfo     `json:"invitee_info,omitempty"` // 被招待者情報（未登録の場合）

        // 招待対象（friend招待の場合は空、group招待の場合はgroupID）
        TargetID *uuid.UUID `json:"target_id,omitempty"`

        // 招待コード・URL用
        Code string `json:"code,omitempty"`
        URL  string `json:"url,omitempty"`

        // メタデータ
        Message  string            `json:"message"`
        Metadata map[string]string `json:"metadata,omitempty"`

        ExpiresAt  time.Time  `json:"expires_at"`
        CreatedAt  time.Time  `json:"created_at"`
        UpdatedAt  time.Time  `json:"updated_at"`
        AcceptedAt *time.Time `json:"accepted_at,omitempty"`
}

// InviteeInfo は未登録ユーザーの招待情報
type InviteeInfo struct {
        Email    string `json:"email,omitempty"`
        Username string `json:"username,omitempty"`
        Phone    string `json:"phone,omitempty"`
}

// NewInvitation は新しい招待を作成する
func NewInvitation(
        invitationType InvitationType,
        method InvitationMethod,
        inviterID uuid.UUID,
        message string,
        expirationHours int,
) *Invitation <span class="cov8" title="1">{
        now := time.Now()
        invitation := &amp;Invitation{
                ID:        uuid.New(),
                Type:      invitationType,
                Method:    method,
                Status:    InvitationStatusPending,
                InviterID: inviterID,
                Message:   message,
                Metadata:  make(map[string]string),
                ExpiresAt: now.Add(time.Duration(expirationHours) * time.Hour),
                CreatedAt: now,
                UpdatedAt: now,
        }

        // 招待コード・URLの生成
        if method == MethodCode || method == MethodURL </span><span class="cov8" title="1">{
                invitation.Code = generateInvitationCode()
                if method == MethodURL </span><span class="cov8" title="1">{
                        invitation.URL = generateInvitationURL(invitation)
                }</span>
        }

        <span class="cov8" title="1">return invitation</span>
}

// generateInvitationCode は招待コードを生成する
func generateInvitationCode() string <span class="cov8" title="1">{
        bytes := make([]byte, 8)
        rand.Read(bytes)
        return hex.EncodeToString(bytes)
}</span>

// generateInvitationURL は招待URL用データを生成する
func generateInvitationURL(invitation *Invitation) string <span class="cov8" title="1">{
        // 実際の実装では、フロントエンドのURLを使用
        return "https://yotei-plus.com/invite/" + invitation.Code
}</span>

// SetInvitee は被招待者を設定する（登録済みユーザー）
func (i *Invitation) SetInvitee(userID uuid.UUID) <span class="cov8" title="1">{
        i.InviteeID = &amp;userID
        i.UpdatedAt = time.Now()
}</span>

// SetInviteeInfo は被招待者情報を設定する（未登録ユーザー）
func (i *Invitation) SetInviteeInfo(info InviteeInfo) <span class="cov8" title="1">{
        i.InviteeInfo = &amp;info
        i.UpdatedAt = time.Now()
}</span>

// SetTarget は招待対象を設定する（グループ招待の場合）
func (i *Invitation) SetTarget(targetID uuid.UUID) <span class="cov8" title="1">{
        i.TargetID = &amp;targetID
        i.UpdatedAt = time.Now()
}</span>

// Accept は招待を承認する
func (i *Invitation) Accept() error <span class="cov8" title="1">{
        if i.IsExpired() </span><span class="cov8" title="1">{
                return ErrInvitationExpired
        }</span>
        <span class="cov8" title="1">if i.Status != InvitationStatusPending </span><span class="cov8" title="1">{
                return ErrInvalidInvitationStatus
        }</span>

        <span class="cov8" title="1">i.Status = InvitationStatusAccepted
        now := time.Now()
        i.AcceptedAt = &amp;now
        i.UpdatedAt = now
        return nil</span>
}

// Decline は招待を拒否する
func (i *Invitation) Decline() error <span class="cov8" title="1">{
        if i.Status != InvitationStatusPending </span><span class="cov8" title="1">{
                return ErrInvalidInvitationStatus
        }</span>

        <span class="cov8" title="1">i.Status = InvitationStatusDeclined
        i.UpdatedAt = time.Now()
        return nil</span>
}

// Cancel は招待をキャンセルする
func (i *Invitation) Cancel() error <span class="cov8" title="1">{
        if i.Status != InvitationStatusPending </span><span class="cov8" title="1">{
                return ErrInvalidInvitationStatus
        }</span>

        <span class="cov8" title="1">i.Status = InvitationStatusCanceled
        i.UpdatedAt = time.Now()
        return nil</span>
}

// MarkAsExpired は招待を期限切れにする
func (i *Invitation) MarkAsExpired() <span class="cov8" title="1">{
        i.Status = InvitationStatusExpired
        i.UpdatedAt = time.Now()
}</span>

// IsExpired は招待が期限切れかチェック
func (i *Invitation) IsExpired() bool <span class="cov8" title="1">{
        return time.Now().After(i.ExpiresAt)
}</span>

// IsValid は招待が有効かチェック
func (i *Invitation) IsValid() bool <span class="cov8" title="1">{
        return i.Status == InvitationStatusPending &amp;&amp; !i.IsExpired()
}</span>

// AddMetadata はメタデータを追加する
func (i *Invitation) AddMetadata(key, value string) <span class="cov8" title="1">{
        if i.Metadata == nil </span><span class="cov8" title="1">{
                i.Metadata = make(map[string]string)
        }</span>
        <span class="cov8" title="1">i.Metadata[key] = value
        i.UpdatedAt = time.Now()</span>
}

// IsFriend は友達招待かどうかをチェック
func (i *Invitation) IsFriend() bool <span class="cov8" title="1">{
        return i.Type == InvitationTypeFriend
}</span>

// エラー定義
var (
        ErrInvitationExpired       = errors.New("invitation has expired")
        ErrInvalidInvitationStatus = errors.New("invalid invitation status")
)
</pre>
		
		<pre class="file" id="file41" style="display: none">package database

import (
        "database/sql"
        "fmt"

        "github.com/hryt430/Yotei+/config"
        "github.com/hryt430/Yotei+/internal/common/infrastructure/database"
)

// SqlHandler はSocialモジュール用のSQLハンドラー
type SqlHandler struct {
        Conn *sql.DB
}

// NewSqlHandler は新しいSqlHandlerを作成する
func NewSqlHandler() SqlHandler <span class="cov0" title="0">{
        // 共通のMySQLコネクションを使用
        cfg, err := config.LoadConfig("")
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to load config: %v", err))</span>
        }
        <span class="cov0" title="0">conn, err := database.NewMySQLConnection(cfg)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to connect to database: %v", err))</span>
        }

        <span class="cov0" title="0">return SqlHandler{
                Conn: conn,
        }</span>
}

// Close はデータベース接続を閉じる
func (h *SqlHandler) Close() error <span class="cov0" title="0">{
        if h.Conn != nil </span><span class="cov0" title="0">{
                return h.Conn.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetConnection はデータベース接続を取得する
func (h *SqlHandler) GetConnection() *sql.DB <span class="cov0" title="0">{
        return h.Conn
}</span>

// Begin はトランザクションを開始する
func (h *SqlHandler) Begin() (*sql.Tx, error) <span class="cov0" title="0">{
        return h.Conn.Begin()
}</span>

// ExecInTransaction はトランザクション内でクエリを実行する
func (h *SqlHandler) ExecInTransaction(txFunc func(*sql.Tx) error) error <span class="cov0" title="0">{
        tx, err := h.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if p := recover(); p != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        panic(p)</span>
                } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                }</span> else<span class="cov0" title="0"> {
                        err = tx.Commit()
                }</span>
        }()

        <span class="cov0" title="0">err = txFunc(tx)
        return err</span>
}

// InitializeTables はSocialモジュール用のテーブルを初期化する
func (h *SqlHandler) InitializeTables() error <span class="cov0" title="0">{
        // 友達関係テーブル
        friendshipsTableSQL := `
        CREATE TABLE IF NOT EXISTS friendships (
                id CHAR(36) PRIMARY KEY,
                requester_id CHAR(36) NOT NULL,
                addressee_id CHAR(36) NOT NULL,
                status ENUM('PENDING', 'ACCEPTED', 'BLOCKED') NOT NULL DEFAULT 'PENDING',
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                accepted_at TIMESTAMP NULL,
                blocked_at TIMESTAMP NULL,
                INDEX idx_requester_id (requester_id),
                INDEX idx_addressee_id (addressee_id),
                INDEX idx_status (status),
                INDEX idx_created_at (created_at),
                UNIQUE KEY unique_friendship (requester_id, addressee_id)
        ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
        `

        // 招待テーブル
        invitationsTableSQL := `
        CREATE TABLE IF NOT EXISTS invitations (
                id CHAR(36) PRIMARY KEY,
                type ENUM('FRIEND', 'GROUP') NOT NULL,
                method ENUM('IN_APP', 'CODE', 'URL') NOT NULL,
                status ENUM('PENDING', 'ACCEPTED', 'DECLINED', 'EXPIRED', 'CANCELED') NOT NULL DEFAULT 'PENDING',
                inviter_id CHAR(36) NOT NULL,
                invitee_id CHAR(36) NULL,
                invitee_info JSON NULL COMMENT '未登録ユーザーの招待情報',
                target_id CHAR(36) NULL COMMENT 'グループ招待の場合のグループID',
                code VARCHAR(255) NULL COMMENT '招待コード',
                url TEXT NULL COMMENT '招待URL',
                message TEXT NOT NULL DEFAULT '',
                metadata JSON NULL COMMENT '追加のメタデータ',
                expires_at TIMESTAMP NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                accepted_at TIMESTAMP NULL,
                INDEX idx_inviter_id (inviter_id),
                INDEX idx_invitee_id (invitee_id),
                INDEX idx_type (type),
                INDEX idx_method (method),
                INDEX idx_status (status),
                INDEX idx_code (code),
                INDEX idx_expires_at (expires_at),
                INDEX idx_created_at (created_at)
        ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
        `

        // テーブル作成
        tables := []string{friendshipsTableSQL, invitationsTableSQL}

        for _, tableSQL := range tables </span><span class="cov0" title="0">{
                if _, err := h.Conn.Exec(tableSQL); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create table: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// CreateIndexes は必要なインデックスを作成する
func (h *SqlHandler) CreateIndexes() error <span class="cov0" title="0">{
        indexes := []string{
                // 友達関係の複合インデックス
                `CREATE INDEX IF NOT EXISTS idx_friendship_users ON friendships (requester_id, addressee_id, status)`,
                `CREATE INDEX IF NOT EXISTS idx_friendship_status_updated ON friendships (status, updated_at)`,

                // 招待の複合インデックス
                `CREATE INDEX IF NOT EXISTS idx_invitation_type_status ON invitations (type, status)`,
                `CREATE INDEX IF NOT EXISTS idx_invitation_expires_status ON invitations (expires_at, status)`,
                `CREATE INDEX IF NOT EXISTS idx_invitation_target ON invitations (target_id, type, status)`,
        }

        for _, indexSQL := range indexes </span><span class="cov0" title="0">{
                if _, err := h.Conn.Exec(indexSQL); err != nil </span><span class="cov0" title="0">{
                        // インデックス作成エラーは警告レベル（既に存在する場合など）
                        fmt.Printf("Warning: Failed to create index: %v\n", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// HealthCheck はデータベース接続の健全性をチェックする
func (h *SqlHandler) HealthCheck() error <span class="cov0" title="0">{
        return h.Conn.Ping()
}</span>

// GetStats はデータベース統計情報を取得する
func (h *SqlHandler) GetStats() sql.DBStats <span class="cov0" title="0">{
        return h.Conn.Stats()
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package messaging

import (
        "context"
        "fmt"

        "github.com/google/uuid"
        notificationInput "github.com/hryt430/Yotei+/internal/modules/notification/usecase/input"
        "github.com/hryt430/Yotei+/internal/modules/social/domain"
        "github.com/hryt430/Yotei+/pkg/logger"
)

// SocialNotificationAdapter はSocialモジュールから通知サービスへの連携を行う
type SocialNotificationAdapter struct {
        notificationUseCase notificationInput.NotificationUseCase
        logger              logger.Logger
}

// NewSocialNotificationAdapter は新しいSocialNotificationAdapterを作成する
func NewSocialNotificationAdapter(
        notificationUseCase notificationInput.NotificationUseCase,
        logger logger.Logger,
) *SocialNotificationAdapter <span class="cov0" title="0">{
        return &amp;SocialNotificationAdapter{
                notificationUseCase: notificationUseCase,
                logger:              logger,
        }
}</span>

// SendFriendRequestNotification は友達申請通知を送信する
func (a *SocialNotificationAdapter) SendFriendRequestNotification(ctx context.Context, requesterID, addresseeID uuid.UUID, message string) error <span class="cov0" title="0">{
        // 通知タイトルとメッセージを構築
        title := "新しい友達申請"
        notificationMessage := "友達申請が届きました"
        if message != "" </span><span class="cov0" title="0">{
                notificationMessage = fmt.Sprintf("友達申請が届きました: %s", message)
        }</span>

        // 通知作成
        <span class="cov0" title="0">input := notificationInput.CreateNotificationInput{
                UserID:  addresseeID.String(),
                Type:    "FRIEND_REQUEST",
                Title:   title,
                Message: notificationMessage,
                Metadata: map[string]string{
                        "requester_id": requesterID.String(),
                        "request_type": "friend_request",
                        "action_type":  "received",
                },
                Channels: []string{"app"}, // アプリ内通知
        }

        notification, err := a.notificationUseCase.CreateNotification(ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                a.logger.Error("Failed to create friend request notification",
                        logger.Any("requesterID", requesterID),
                        logger.Any("addresseeID", addresseeID),
                        logger.Error(err))
                return fmt.Errorf("failed to create friend request notification: %w", err)
        }</span>

        // 通知送信
        <span class="cov0" title="0">if err := a.notificationUseCase.SendNotification(ctx, notification.GetID()); err != nil </span><span class="cov0" title="0">{
                a.logger.Error("Failed to send friend request notification",
                        logger.Any("notificationID", notification.GetID()),
                        logger.Error(err))
                return fmt.Errorf("failed to send friend request notification: %w", err)
        }</span>

        <span class="cov0" title="0">a.logger.Info("Friend request notification sent successfully",
                logger.Any("requesterID", requesterID),
                logger.Any("addresseeID", addresseeID),
                logger.Any("notificationID", notification.GetID()))

        return nil</span>
}

// SendFriendAcceptedNotification は友達申請承認通知を送信する
func (a *SocialNotificationAdapter) SendFriendAcceptedNotification(ctx context.Context, requesterID, accepterID uuid.UUID) error <span class="cov0" title="0">{
        title := "友達申請が承認されました"
        notificationMessage := "友達申請が承認されました！"

        input := notificationInput.CreateNotificationInput{
                UserID:  requesterID.String(),
                Type:    "FRIEND_ACCEPTED",
                Title:   title,
                Message: notificationMessage,
                Metadata: map[string]string{
                        "accepter_id":  accepterID.String(),
                        "request_type": "friend_request",
                        "action_type":  "accepted",
                },
                Channels: []string{"app"},
        }

        notification, err := a.notificationUseCase.CreateNotification(ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                a.logger.Error("Failed to create friend accepted notification",
                        logger.Any("requesterID", requesterID),
                        logger.Any("accepterID", accepterID),
                        logger.Error(err))
                return fmt.Errorf("failed to create friend accepted notification: %w", err)
        }</span>

        <span class="cov0" title="0">if err := a.notificationUseCase.SendNotification(ctx, notification.GetID()); err != nil </span><span class="cov0" title="0">{
                a.logger.Error("Failed to send friend accepted notification",
                        logger.Any("notificationID", notification.GetID()),
                        logger.Error(err))
                return fmt.Errorf("failed to send friend accepted notification: %w", err)
        }</span>

        <span class="cov0" title="0">a.logger.Info("Friend accepted notification sent successfully",
                logger.Any("requesterID", requesterID),
                logger.Any("accepterID", accepterID))

        return nil</span>
}

// SendInvitationNotification は招待通知を送信する
func (a *SocialNotificationAdapter) SendInvitationNotification(ctx context.Context, invitation *domain.Invitation) error <span class="cov0" title="0">{
        // 招待タイプに応じてメッセージを構築
        var title, message string
        var channels []string

        switch invitation.Type </span>{
        case domain.InvitationTypeFriend:<span class="cov0" title="0">
                title = "友達招待"
                message = "友達になりませんか？"
                channels = []string{"app"}</span>
        case domain.InvitationTypeGroup:<span class="cov0" title="0">
                title = "グループ招待"
                message = "グループに招待されました"
                channels = []string{"app"}</span>
        default:<span class="cov0" title="0">
                title = "招待"
                message = "招待が届きました"
                channels = []string{"app"}</span>
        }

        <span class="cov0" title="0">if invitation.Message != "" </span><span class="cov0" title="0">{
                message = fmt.Sprintf("%s: %s", message, invitation.Message)
        }</span>

        // 招待方法に応じて通知チャネルを調整
        <span class="cov0" title="0">switch invitation.Method </span>{
        case domain.MethodInApp:<span class="cov0" title="0">
                channels = []string{"app"}</span>
        case domain.MethodCode, domain.MethodURL:<span class="cov0" title="0">
                channels = []string{"app"}</span>
                // URLや招待コードの場合、必要に応じて他のチャネルも追加
        }

        <span class="cov0" title="0">metadata := map[string]string{
                "invitation_id":     invitation.ID.String(),
                "invitation_type":   string(invitation.Type),
                "invitation_method": string(invitation.Method),
                "inviter_id":        invitation.InviterID.String(),
        }

        if invitation.Code != "" </span><span class="cov0" title="0">{
                metadata["invitation_code"] = invitation.Code
        }</span>

        <span class="cov0" title="0">if invitation.TargetID != nil </span><span class="cov0" title="0">{
                metadata["target_id"] = invitation.TargetID.String()
        }</span>

        // 被招待者が登録済みユーザーの場合
        <span class="cov0" title="0">if invitation.InviteeID != nil </span><span class="cov0" title="0">{
                input := notificationInput.CreateNotificationInput{
                        UserID:   invitation.InviteeID.String(),
                        Type:     "INVITATION_RECEIVED",
                        Title:    title,
                        Message:  message,
                        Metadata: metadata,
                        Channels: channels,
                }

                notification, err := a.notificationUseCase.CreateNotification(ctx, input)
                if err != nil </span><span class="cov0" title="0">{
                        a.logger.Error("Failed to create invitation notification",
                                logger.Any("invitationID", invitation.ID),
                                logger.Error(err))
                        return fmt.Errorf("failed to create invitation notification: %w", err)
                }</span>

                <span class="cov0" title="0">if err := a.notificationUseCase.SendNotification(ctx, notification.GetID()); err != nil </span><span class="cov0" title="0">{
                        a.logger.Error("Failed to send invitation notification",
                                logger.Any("notificationID", notification.GetID()),
                                logger.Error(err))
                        return fmt.Errorf("failed to send invitation notification: %w", err)
                }</span>

                <span class="cov0" title="0">a.logger.Info("Invitation notification sent successfully",
                        logger.Any("invitationID", invitation.ID),
                        logger.Any("inviteeID", invitation.InviteeID))</span>
        } else<span class="cov0" title="0"> {
                // 未登録ユーザーの場合は、メール通知などの外部通知を検討
                a.logger.Info("Invitation created for unregistered user",
                        logger.Any("invitationID", invitation.ID),
                        logger.Any("inviteeInfo", invitation.InviteeInfo))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// SendGroupInvitationNotification はグループ招待通知を送信する
func (a *SocialNotificationAdapter) SendGroupInvitationNotification(ctx context.Context, invitation *domain.Invitation, groupName string) error <span class="cov0" title="0">{
        if invitation.Type != domain.InvitationTypeGroup </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid invitation type for group invitation: %s", invitation.Type)
        }</span>

        <span class="cov0" title="0">title := fmt.Sprintf("「%s」への招待", groupName)
        message := fmt.Sprintf("グループ「%s」に招待されました", groupName)

        if invitation.Message != "" </span><span class="cov0" title="0">{
                message = fmt.Sprintf("%s: %s", message, invitation.Message)
        }</span>

        <span class="cov0" title="0">metadata := map[string]string{
                "invitation_id":   invitation.ID.String(),
                "invitation_type": string(invitation.Type),
                "inviter_id":      invitation.InviterID.String(),
                "group_name":      groupName,
        }

        if invitation.TargetID != nil </span><span class="cov0" title="0">{
                metadata["group_id"] = invitation.TargetID.String()
        }</span>

        <span class="cov0" title="0">if invitation.InviteeID != nil </span><span class="cov0" title="0">{
                input := notificationInput.CreateNotificationInput{
                        UserID:   invitation.InviteeID.String(),
                        Type:     "GROUP_INVITATION",
                        Title:    title,
                        Message:  message,
                        Metadata: metadata,
                        Channels: []string{"app"},
                }

                notification, err := a.notificationUseCase.CreateNotification(ctx, input)
                if err != nil </span><span class="cov0" title="0">{
                        a.logger.Error("Failed to create group invitation notification",
                                logger.Any("invitationID", invitation.ID),
                                logger.Error(err))
                        return fmt.Errorf("failed to create group invitation notification: %w", err)
                }</span>

                <span class="cov0" title="0">if err := a.notificationUseCase.SendNotification(ctx, notification.GetID()); err != nil </span><span class="cov0" title="0">{
                        a.logger.Error("Failed to send group invitation notification",
                                logger.Any("notificationID", notification.GetID()),
                                logger.Error(err))
                        return fmt.Errorf("failed to send group invitation notification: %w", err)
                }</span>

                <span class="cov0" title="0">a.logger.Info("Group invitation notification sent successfully",
                        logger.Any("invitationID", invitation.ID),
                        logger.Any("groupName", groupName))</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// SendBulkNotifications は一括通知を送信する（バッチ処理用）
func (a *SocialNotificationAdapter) SendBulkNotifications(ctx context.Context, notifications []notificationInput.CreateNotificationInput) error <span class="cov0" title="0">{
        for _, input := range notifications </span><span class="cov0" title="0">{
                notification, err := a.notificationUseCase.CreateNotification(ctx, input)
                if err != nil </span><span class="cov0" title="0">{
                        a.logger.Error("Failed to create bulk notification",
                                logger.Any("userID", input.UserID),
                                logger.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">if err := a.notificationUseCase.SendNotification(ctx, notification.GetID()); err != nil </span><span class="cov0" title="0">{
                        a.logger.Error("Failed to send bulk notification",
                                logger.Any("notificationID", notification.GetID()),
                                logger.Error(err))
                        continue</span>
                }
        }

        <span class="cov0" title="0">a.logger.Info("Bulk notifications processed",
                logger.Any("count", len(notifications)))

        return nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package messaging

import (
        "context"
        "fmt"
        "time"

        "github.com/google/uuid"
        "github.com/hryt430/Yotei+/internal/modules/social/domain"
        "github.com/hryt430/Yotei+/pkg/logger"
)

// SocialEventType はソーシャル関連のイベントタイプ
type SocialEventType string

const (
        EventFriendRequestSent     SocialEventType = "social.friend_request.sent"
        EventFriendRequestAccepted SocialEventType = "social.friend_request.accepted"
        EventFriendRequestDeclined SocialEventType = "social.friend_request.declined"
        EventFriendRemoved         SocialEventType = "social.friend.removed"
        EventUserBlocked           SocialEventType = "social.user.blocked"
        EventUserUnblocked         SocialEventType = "social.user.unblocked"
        EventInvitationCreated     SocialEventType = "social.invitation.created"
        EventInvitationAccepted    SocialEventType = "social.invitation.accepted"
        EventInvitationDeclined    SocialEventType = "social.invitation.declined"
        EventInvitationExpired     SocialEventType = "social.invitation.expired"
)

// SocialEvent はソーシャル関連のイベント
type SocialEvent struct {
        ID        string          `json:"id"`
        Type      SocialEventType `json:"type"`
        Payload   interface{}     `json:"payload"`
        UserID    uuid.UUID       `json:"user_id"`
        CreatedAt time.Time       `json:"created_at"`
}

// FriendRequestPayload は友達申請イベントのペイロード
type FriendRequestPayload struct {
        FriendshipID uuid.UUID `json:"friendship_id"`
        RequesterID  uuid.UUID `json:"requester_id"`
        AddresseeID  uuid.UUID `json:"addressee_id"`
        Message      string    `json:"message"`
        Status       string    `json:"status"`
        CreatedAt    time.Time `json:"created_at"`
}

// InvitationPayload は招待イベントのペイロード
type InvitationPayload struct {
        InvitationID uuid.UUID               `json:"invitation_id"`
        Type         domain.InvitationType   `json:"type"`
        Method       domain.InvitationMethod `json:"method"`
        InviterID    uuid.UUID               `json:"inviter_id"`
        InviteeID    *uuid.UUID              `json:"invitee_id,omitempty"`
        TargetID     *uuid.UUID              `json:"target_id,omitempty"`
        Code         string                  `json:"code,omitempty"`
        Message      string                  `json:"message"`
        Status       domain.InvitationStatus `json:"status"`
        CreatedAt    time.Time               `json:"created_at"`
}

// NotificationAdapter は通知サービスとの連携アダプター
type NotificationAdapter interface {
        SendFriendRequestNotification(ctx context.Context, requesterID, addresseeID uuid.UUID, message string) error
        SendFriendAcceptedNotification(ctx context.Context, requesterID, accepterID uuid.UUID) error
        SendInvitationNotification(ctx context.Context, invitation *domain.Invitation) error
}

// SocialEventPublisher はソーシャルイベントを発行する
type SocialEventPublisher struct {
        notificationAdapter NotificationAdapter
        logger              logger.Logger
}

// NewSocialEventPublisher は新しいSocialEventPublisherを作成する
func NewSocialEventPublisher(notificationAdapter NotificationAdapter, logger logger.Logger) *SocialEventPublisher <span class="cov0" title="0">{
        return &amp;SocialEventPublisher{
                notificationAdapter: notificationAdapter,
                logger:              logger,
        }
}</span>

// PublishFriendRequestSent は友達申請送信イベントを発行する
func (p *SocialEventPublisher) PublishFriendRequestSent(ctx context.Context, friendship *domain.Friendship, message string) error <span class="cov0" title="0">{
        payload := FriendRequestPayload{
                FriendshipID: friendship.ID,
                RequesterID:  friendship.RequesterID,
                AddresseeID:  friendship.AddresseeID,
                Message:      message,
                Status:       string(friendship.Status),
                CreatedAt:    friendship.CreatedAt,
        }

        event := &amp;SocialEvent{
                ID:        uuid.New().String(),
                Type:      EventFriendRequestSent,
                Payload:   payload,
                UserID:    friendship.AddresseeID, // 通知対象ユーザー
                CreatedAt: time.Now(),
        }

        p.logger.Info("Publishing friend request sent event",
                logger.Any("eventID", event.ID),
                logger.Any("requesterID", friendship.RequesterID),
                logger.Any("addresseeID", friendship.AddresseeID))

        // 通知サービスに送信
        if err := p.notificationAdapter.SendFriendRequestNotification(ctx, friendship.RequesterID, friendship.AddresseeID, message); err != nil </span><span class="cov0" title="0">{
                p.logger.Error("Failed to send friend request notification",
                        logger.Any("eventID", event.ID),
                        logger.Error(err))
                return fmt.Errorf("failed to send friend request notification: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// PublishFriendRequestAccepted は友達申請承認イベントを発行する
func (p *SocialEventPublisher) PublishFriendRequestAccepted(ctx context.Context, friendship *domain.Friendship) error <span class="cov0" title="0">{
        payload := FriendRequestPayload{
                FriendshipID: friendship.ID,
                RequesterID:  friendship.RequesterID,
                AddresseeID:  friendship.AddresseeID,
                Status:       string(friendship.Status),
                CreatedAt:    friendship.CreatedAt,
        }

        event := &amp;SocialEvent{
                ID:        uuid.New().String(),
                Type:      EventFriendRequestAccepted,
                Payload:   payload,
                UserID:    friendship.RequesterID, // 申請者に通知
                CreatedAt: time.Now(),
        }

        p.logger.Info("Publishing friend request accepted event",
                logger.Any("eventID", event.ID),
                logger.Any("requesterID", friendship.RequesterID),
                logger.Any("addresseeID", friendship.AddresseeID))

        // 通知サービスに送信
        if err := p.notificationAdapter.SendFriendAcceptedNotification(ctx, friendship.RequesterID, friendship.AddresseeID); err != nil </span><span class="cov0" title="0">{
                p.logger.Error("Failed to send friend accepted notification",
                        logger.Any("eventID", event.ID),
                        logger.Error(err))
                return fmt.Errorf("failed to send friend accepted notification: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// PublishFriendRequestDeclined は友達申請拒否イベントを発行する
func (p *SocialEventPublisher) PublishFriendRequestDeclined(ctx context.Context, friendship *domain.Friendship) error <span class="cov0" title="0">{
        payload := FriendRequestPayload{
                FriendshipID: friendship.ID,
                RequesterID:  friendship.RequesterID,
                AddresseeID:  friendship.AddresseeID,
                Status:       string(friendship.Status),
                CreatedAt:    friendship.CreatedAt,
        }

        event := &amp;SocialEvent{
                ID:        uuid.New().String(),
                Type:      EventFriendRequestDeclined,
                Payload:   payload,
                UserID:    friendship.RequesterID,
                CreatedAt: time.Now(),
        }

        p.logger.Info("Publishing friend request declined event",
                logger.Any("eventID", event.ID),
                logger.Any("requesterID", friendship.RequesterID),
                logger.Any("addresseeID", friendship.AddresseeID))

        // 拒否の場合は通知しない（プライバシー配慮）
        return nil
}</span>

// PublishFriendRemoved は友達削除イベントを発行する
func (p *SocialEventPublisher) PublishFriendRemoved(ctx context.Context, userID, friendID uuid.UUID) error <span class="cov0" title="0">{
        event := &amp;SocialEvent{
                ID:   uuid.New().String(),
                Type: EventFriendRemoved,
                Payload: map[string]interface{}{
                        "user_id":   userID,
                        "friend_id": friendID,
                },
                UserID:    userID,
                CreatedAt: time.Now(),
        }

        p.logger.Info("Publishing friend removed event",
                logger.Any("eventID", event.ID),
                logger.Any("userID", userID),
                logger.Any("friendID", friendID))

        return nil
}</span>

// PublishUserBlocked はユーザーブロックイベントを発行する
func (p *SocialEventPublisher) PublishUserBlocked(ctx context.Context, userID, targetID uuid.UUID) error <span class="cov0" title="0">{
        event := &amp;SocialEvent{
                ID:   uuid.New().String(),
                Type: EventUserBlocked,
                Payload: map[string]interface{}{
                        "user_id":   userID,
                        "target_id": targetID,
                },
                UserID:    userID,
                CreatedAt: time.Now(),
        }

        p.logger.Info("Publishing user blocked event",
                logger.Any("eventID", event.ID),
                logger.Any("userID", userID),
                logger.Any("targetID", targetID))

        return nil
}</span>

// PublishInvitationCreated は招待作成イベントを発行する
func (p *SocialEventPublisher) PublishInvitationCreated(ctx context.Context, invitation *domain.Invitation) error <span class="cov0" title="0">{
        payload := InvitationPayload{
                InvitationID: invitation.ID,
                Type:         invitation.Type,
                Method:       invitation.Method,
                InviterID:    invitation.InviterID,
                InviteeID:    invitation.InviteeID,
                TargetID:     invitation.TargetID,
                Code:         invitation.Code,
                Message:      invitation.Message,
                Status:       invitation.Status,
                CreatedAt:    invitation.CreatedAt,
        }

        event := &amp;SocialEvent{
                ID:        uuid.New().String(),
                Type:      EventInvitationCreated,
                Payload:   payload,
                UserID:    invitation.InviterID,
                CreatedAt: time.Now(),
        }

        p.logger.Info("Publishing invitation created event",
                logger.Any("eventID", event.ID),
                logger.Any("invitationID", invitation.ID),
                logger.Any("inviterID", invitation.InviterID))

        // 通知サービスに送信
        if err := p.notificationAdapter.SendInvitationNotification(ctx, invitation); err != nil </span><span class="cov0" title="0">{
                p.logger.Error("Failed to send invitation notification",
                        logger.Any("eventID", event.ID),
                        logger.Error(err))
                return fmt.Errorf("failed to send invitation notification: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// PublishInvitationAccepted は招待受諾イベントを発行する
func (p *SocialEventPublisher) PublishInvitationAccepted(ctx context.Context, invitation *domain.Invitation) error <span class="cov0" title="0">{
        payload := InvitationPayload{
                InvitationID: invitation.ID,
                Type:         invitation.Type,
                Method:       invitation.Method,
                InviterID:    invitation.InviterID,
                InviteeID:    invitation.InviteeID,
                TargetID:     invitation.TargetID,
                Status:       invitation.Status,
                CreatedAt:    invitation.CreatedAt,
        }

        event := &amp;SocialEvent{
                ID:        uuid.New().String(),
                Type:      EventInvitationAccepted,
                Payload:   payload,
                UserID:    invitation.InviterID, // 招待者に通知
                CreatedAt: time.Now(),
        }

        p.logger.Info("Publishing invitation accepted event",
                logger.Any("eventID", event.ID),
                logger.Any("invitationID", invitation.ID),
                logger.Any("inviterID", invitation.InviterID))

        return nil
}</span>

// PublishInvitationDeclined は招待拒否イベントを発行する
func (p *SocialEventPublisher) PublishInvitationDeclined(ctx context.Context, invitation *domain.Invitation) error <span class="cov0" title="0">{
        payload := InvitationPayload{
                InvitationID: invitation.ID,
                Type:         invitation.Type,
                Method:       invitation.Method,
                InviterID:    invitation.InviterID,
                InviteeID:    invitation.InviteeID,
                Status:       invitation.Status,
                CreatedAt:    invitation.CreatedAt,
        }

        event := &amp;SocialEvent{
                ID:        uuid.New().String(),
                Type:      EventInvitationDeclined,
                Payload:   payload,
                UserID:    invitation.InviterID,
                CreatedAt: time.Now(),
        }

        p.logger.Info("Publishing invitation declined event",
                logger.Any("eventID", event.ID),
                logger.Any("invitationID", invitation.ID))

        return nil
}</span>

// PublishBulkInvitationsExpired は期限切れ招待の一括処理イベントを発行する
func (p *SocialEventPublisher) PublishBulkInvitationsExpired(ctx context.Context, expiredCount int) error <span class="cov0" title="0">{
        event := &amp;SocialEvent{
                ID:   uuid.New().String(),
                Type: EventInvitationExpired,
                Payload: map[string]interface{}{
                        "expired_count": expiredCount,
                        "processed_at":  time.Now(),
                },
                UserID:    uuid.Nil, // システムイベント
                CreatedAt: time.Now(),
        }

        p.logger.Info("Publishing bulk invitations expired event",
                logger.Any("eventID", event.ID),
                logger.Any("expiredCount", expiredCount))

        return nil
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">package controller

import (
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        commonDomain "github.com/hryt430/Yotei+/internal/common/domain"
        "github.com/hryt430/Yotei+/internal/common/middleware"
        "github.com/hryt430/Yotei+/internal/modules/social/domain"
        "github.com/hryt430/Yotei+/internal/modules/social/interface/dto"
        "github.com/hryt430/Yotei+/internal/modules/social/usecase"
        "github.com/hryt430/Yotei+/pkg/logger"
        "go.uber.org/zap/zapcore"
)

type SocialController struct {
        socialService usecase.SocialService
        logger        logger.Logger
}

func NewSocialController(socialService usecase.SocialService, logger logger.Logger) *SocialController <span class="cov0" title="0">{
        return &amp;SocialController{
                socialService: socialService,
                logger:        logger,
        }
}</span>

// SendFriendRequestRequest は友達申請送信のリクエスト構造体
type SendFriendRequestRequest struct {
        AddresseeID string `json:"addressee_id" binding:"required" example:"123e4567-e89b-12d3-a456-426614174000"`
        Message     string `json:"message" binding:"max=500" example:"友達になりませんか？"`
} // @name SendFriendRequestRequest

// CreateInvitationRequest は招待作成のリクエスト構造体
type CreateInvitationRequest struct {
        Type         string  `json:"type" binding:"required" enums:"FRIEND,GROUP" example:"FRIEND"`
        Method       string  `json:"method" binding:"required" enums:"IN_APP,CODE,URL" example:"CODE"`
        Message      string  `json:"message" binding:"max=500" example:"一緒にYotei+を使いませんか？"`
        ExpiresHours int     `json:"expires_hours" binding:"min=1,max=168" example:"168"`
        InviteeEmail *string `json:"invitee_email,omitempty" binding:"omitempty,email" example:"friend@example.com"`
        TargetID     *string `json:"target_id,omitempty" example:"123e4567-e89b-12d3-a456-426614174000"`
} // @name CreateInvitationRequest

// FriendshipResponse は友達関係のレスポンス構造体
type FriendshipResponse struct {
        ID          uuid.UUID `json:"id" example:"123e4567-e89b-12d3-a456-426614174000"`
        RequesterID uuid.UUID `json:"requester_id" example:"123e4567-e89b-12d3-a456-426614174000"`
        AddresseeID uuid.UUID `json:"addressee_id" example:"123e4567-e89b-12d3-a456-426614174000"`
        Status      string    `json:"status" example:"PENDING"`
        CreatedAt   string    `json:"created_at" example:"2024-01-01T00:00:00Z"`
        UpdatedAt   string    `json:"updated_at" example:"2024-01-01T00:00:00Z"`
        AcceptedAt  *string   `json:"accepted_at,omitempty" example:"2024-01-01T01:00:00Z"`
        BlockedAt   *string   `json:"blocked_at,omitempty"`
} // @name FriendshipResponse

// UserInfo はユーザー基本情報
type UserInfo struct {
        ID       string `json:"id" example:"123e4567-e89b-12d3-a456-426614174000"`
        Username string `json:"username" example:"user123"`
        Email    string `json:"email" example:"user@example.com"`
} // @name UserInfo

// FriendWithUserInfoResponse はユーザー情報付き友達レスポンス
type FriendWithUserInfoResponse struct {
        Friendship FriendshipResponse `json:"friendship"`
        UserInfo   *UserInfo          `json:"user_info,omitempty"`
} // @name FriendWithUserInfoResponse

// InvitationResponse は招待のレスポンス構造体
type InvitationResponse struct {
        ID          uuid.UUID           `json:"id" example:"123e4567-e89b-12d3-a456-426614174000"`
        Type        string              `json:"type" example:"FRIEND"`
        Method      string              `json:"method" example:"CODE"`
        Status      string              `json:"status" example:"PENDING"`
        InviterID   uuid.UUID           `json:"inviter_id" example:"123e4567-e89b-12d3-a456-426614174000"`
        InviteeID   *uuid.UUID          `json:"invitee_id,omitempty" example:"123e4567-e89b-12d3-a456-426614174000"`
        InviteeInfo *domain.InviteeInfo `json:"invitee_info,omitempty"`
        TargetID    *uuid.UUID          `json:"target_id,omitempty" example:"123e4567-e89b-12d3-a456-426614174000"`
        Code        string              `json:"code,omitempty" example:"abc123def456"`
        URL         string              `json:"url,omitempty" example:"https://yotei-plus.com/invite/abc123def456"`
        Message     string              `json:"message" example:"一緒にYotei+を使いませんか？"`
        Metadata    map[string]string   `json:"metadata,omitempty"`
        ExpiresAt   string              `json:"expires_at" example:"2024-01-08T00:00:00Z"`
        CreatedAt   string              `json:"created_at" example:"2024-01-01T00:00:00Z"`
        UpdatedAt   string              `json:"updated_at" example:"2024-01-01T00:00:00Z"`
        AcceptedAt  *string             `json:"accepted_at,omitempty" example:"2024-01-01T01:00:00Z"`
} // @name InvitationResponse

// InvitationResultResponse は招待受諾結果のレスポンス構造体
type InvitationResultResponse struct {
        Success    bool                `json:"success" example:"true"`
        Message    string              `json:"message" example:"招待を受諾しました"`
        Friendship *FriendshipResponse `json:"friendship,omitempty"`
        GroupID    *uuid.UUID          `json:"group_id,omitempty" example:"123e4567-e89b-12d3-a456-426614174000"`
} // @name InvitationResultResponse

// UserRelationshipResponse はユーザー間関係のレスポンス構造体
type UserRelationshipResponse struct {
        IsFriend        bool `json:"is_friend" example:"true"`
        IsBlocked       bool `json:"is_blocked" example:"false"`
        RequestSent     bool `json:"request_sent" example:"false"`
        RequestReceived bool `json:"request_received" example:"false"`
} // @name UserRelationshipResponse

// FriendsListResponse は友達一覧のレスポンス構造体
type FriendsListResponse struct {
        Friends    []FriendWithUserInfoResponse `json:"friends"`
        Pagination PaginationInfo               `json:"pagination"`
} // @name FriendsListResponse

// InviteURLResponse は招待URL生成のレスポンス構造体
type InviteURLResponse struct {
        URL       string `json:"url" example:"https://yotei-plus.com/invite/abc123def456"`
        Code      string `json:"code" example:"abc123def456"`
        ExpiresAt string `json:"expires_at" example:"2024-01-08T00:00:00Z"`
} // @name InviteURLResponse

// PaginationInfo はページング情報
type PaginationInfo struct {
        Page       int `json:"page" example:"1"`
        PageSize   int `json:"page_size" example:"20"`
        Total      int `json:"total" example:"100"`
        TotalPages int `json:"total_pages" example:"5"`
} // @name PaginationInfo

// SuccessResponse は成功レスポンス
type SuccessResponse struct {
        Success bool   `json:"success" example:"true"`
        Message string `json:"message" example:"操作が正常に完了しました"`
} // @name SuccessResponse

// ErrorResponse はエラーレスポンス
type ErrorResponse struct {
        Error   string `json:"error" example:"INVALID_REQUEST"`
        Message string `json:"message" example:"リクエストが無効です"`
} // @name ErrorResponse

// === 友達関係管理 ===

// SendFriendRequest 友達申請送信
// @Summary      友達申請送信
// @Description  指定されたユーザーに友達申請を送信します
// @Tags         social
// @Accept       json
// @Produce      json
// @Param        request body SendFriendRequestRequest true "友達申請情報"
// @Security     BearerAuth
// @Success      201 {object} FriendshipResponse "友達申請送信成功"
// @Failure      400 {object} ErrorResponse "リクエストが無効（自分自身への申請など）"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      404 {object} ErrorResponse "ユーザーが見つからない"
// @Failure      409 {object} ErrorResponse "既に友達または申請済み"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /social/friends/requests [post]
func (sc *SocialController) SendFriendRequest(c *gin.Context) <span class="cov0" title="0">{
        user, err := middleware.GetUserFromContext(c)
        if err != nil </span><span class="cov0" title="0">{
                sc.logError("get user from context", err)
                c.JSON(http.StatusUnauthorized, dto.ErrorResponse{
                        Error:   "unauthorized",
                        Message: "認証が必要です",
                })
                return
        }</span>

        <span class="cov0" title="0">var req dto.SendFriendRequestRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                sc.logError("bind JSON", err)
                c.JSON(http.StatusBadRequest, dto.ErrorResponse{
                        Error:   "invalid_request",
                        Message: "リクエストの形式が正しくありません",
                })
                return
        }</span>

        <span class="cov0" title="0">addresseeID, err := sc.validateUUID(req.AddresseeID, "addressee ID")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, dto.ErrorResponse{
                        Error:   "invalid_user_id",
                        Message: "無効なユーザーIDです",
                })
                return
        }</span>

        // 自分自身への申請をチェック
        <span class="cov0" title="0">if user.ID == addresseeID </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, dto.ErrorResponse{
                        Error:   "self_request_not_allowed",
                        Message: "自分自身に友達申請はできません",
                })
                return
        }</span>

        <span class="cov0" title="0">friendship, err := sc.socialService.SendFriendRequest(c.Request.Context(), user.ID, addresseeID, req.Message)
        if err != nil </span><span class="cov0" title="0">{
                sc.logError("send friend request", err,
                        logger.Any("requesterID", user.ID),
                        logger.Any("addresseeID", addresseeID))
                c.JSON(http.StatusInternalServerError, dto.ErrorResponse{
                        Error:   "send_friend_request_failed",
                        Message: "友達申請の送信に失敗しました",
                })
                return
        }</span>

        <span class="cov0" title="0">sc.logger.Info("Friend request sent successfully",
                logger.Any("requesterID", user.ID),
                logger.Any("addresseeID", addresseeID))

        response := dto.ToFriendshipResponse(friendship)
        c.JSON(http.StatusCreated, response)</span>
}

// AcceptFriendRequest 友達申請承認
// @Summary      友達申請承認
// @Description  受信した友達申請を承認します
// @Tags         social
// @Accept       json
// @Produce      json
// @Param        friendshipId path string true "友達申請ID" example:"123e4567-e89b-12d3-a456-426614174000"
// @Security     BearerAuth
// @Success      200 {object} FriendshipResponse "友達申請承認成功"
// @Failure      400 {object} ErrorResponse "友達申請IDが無効"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      403 {object} ErrorResponse "この申請を承認する権限がない"
// @Failure      404 {object} ErrorResponse "友達申請が見つからない"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /social/friends/requests/{friendshipId}/accept [put]
func (sc *SocialController) AcceptFriendRequest(c *gin.Context) <span class="cov0" title="0">{
        user, err := middleware.GetUserFromContext(c)
        if err != nil </span><span class="cov0" title="0">{
                sc.logError("get user from context", err)
                c.JSON(http.StatusUnauthorized, dto.ErrorResponse{
                        Error:   "unauthorized",
                        Message: "認証が必要です",
                })
                return
        }</span>

        <span class="cov0" title="0">friendshipID, err := sc.validateUUID(c.Param("friendshipId"), "friendship ID")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, dto.ErrorResponse{
                        Error:   "invalid_friendship_id",
                        Message: "無効な友達申請IDです",
                })
                return
        }</span>

        <span class="cov0" title="0">friendship, err := sc.socialService.AcceptFriendRequest(c.Request.Context(), friendshipID, user.ID)
        if err != nil </span><span class="cov0" title="0">{
                sc.logError("accept friend request", err,
                        logger.Any("friendshipID", friendshipID),
                        logger.Any("userID", user.ID))
                c.JSON(http.StatusInternalServerError, dto.ErrorResponse{
                        Error:   "accept_friend_request_failed",
                        Message: "友達申請の承認に失敗しました",
                })
                return
        }</span>

        <span class="cov0" title="0">sc.logger.Info("Friend request accepted successfully",
                logger.Any("friendshipID", friendshipID),
                logger.Any("userID", user.ID))

        response := dto.ToFriendshipResponse(friendship)
        c.JSON(http.StatusOK, response)</span>
}

// DeclineFriendRequest 友達申請拒否
// @Summary      友達申請拒否
// @Description  受信した友達申請を拒否します
// @Tags         social
// @Accept       json
// @Produce      json
// @Param        friendshipId path string true "友達申請ID" example:"123e4567-e89b-12d3-a456-426614174000"
// @Security     BearerAuth
// @Success      200 {object} SuccessResponse "友達申請拒否成功"
// @Failure      400 {object} ErrorResponse "友達申請IDが無効"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      403 {object} ErrorResponse "この申請を拒否する権限がない"
// @Failure      404 {object} ErrorResponse "友達申請が見つからない"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /social/friends/requests/{friendshipId}/decline [put]
func (sc *SocialController) DeclineFriendRequest(c *gin.Context) <span class="cov0" title="0">{
        user, err := middleware.GetUserFromContext(c)
        if err != nil </span><span class="cov0" title="0">{
                sc.logError("get user from context", err)
                c.JSON(http.StatusUnauthorized, dto.ErrorResponse{
                        Error:   "unauthorized",
                        Message: "認証が必要です",
                })
                return
        }</span>

        <span class="cov0" title="0">friendshipID, err := sc.validateUUID(c.Param("friendshipId"), "friendship ID")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, dto.ErrorResponse{
                        Error:   "invalid_friendship_id",
                        Message: "無効な友達申請IDです",
                })
                return
        }</span>

        <span class="cov0" title="0">err = sc.socialService.DeclineFriendRequest(c.Request.Context(), friendshipID, user.ID)
        if err != nil </span><span class="cov0" title="0">{
                sc.logError("decline friend request", err,
                        logger.Any("friendshipID", friendshipID),
                        logger.Any("userID", user.ID))
                c.JSON(http.StatusInternalServerError, dto.ErrorResponse{
                        Error:   "decline_friend_request_failed",
                        Message: "友達申請の拒否に失敗しました",
                })
                return
        }</span>

        <span class="cov0" title="0">sc.logger.Info("Friend request declined successfully",
                logger.Any("friendshipID", friendshipID),
                logger.Any("userID", user.ID))

        c.JSON(http.StatusOK, dto.SuccessResponse{
                Success: true,
                Message: "友達申請を拒否しました",
        })</span>
}

// RemoveFriend 友達削除
// @Summary      友達削除
// @Description  友達関係を解除します
// @Tags         social
// @Accept       json
// @Produce      json
// @Param        userId path string true "削除する友達のユーザーID" example:"123e4567-e89b-12d3-a456-426614174000"
// @Security     BearerAuth
// @Success      200 {object} SuccessResponse "友達削除成功"
// @Failure      400 {object} ErrorResponse "ユーザーIDが無効"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      404 {object} ErrorResponse "友達関係が見つからない"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /social/friends/{userId} [delete]
func (sc *SocialController) RemoveFriend(c *gin.Context) <span class="cov0" title="0">{
        user, err := middleware.GetUserFromContext(c)
        if err != nil </span><span class="cov0" title="0">{
                sc.logError("get user from context", err)
                c.JSON(http.StatusUnauthorized, dto.ErrorResponse{
                        Error:   "unauthorized",
                        Message: "認証が必要です",
                })
                return
        }</span>

        <span class="cov0" title="0">friendID, err := sc.validateUUID(c.Param("userId"), "friend ID")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, dto.ErrorResponse{
                        Error:   "invalid_user_id",
                        Message: "無効なユーザーIDです",
                })
                return
        }</span>

        <span class="cov0" title="0">err = sc.socialService.RemoveFriend(c.Request.Context(), user.ID, friendID)
        if err != nil </span><span class="cov0" title="0">{
                sc.logError("remove friend", err,
                        logger.Any("userID", user.ID),
                        logger.Any("friendID", friendID))
                c.JSON(http.StatusInternalServerError, dto.ErrorResponse{
                        Error:   "remove_friend_failed",
                        Message: "友達の削除に失敗しました",
                })
                return
        }</span>

        <span class="cov0" title="0">sc.logger.Info("Friend removed successfully",
                logger.Any("userID", user.ID),
                logger.Any("friendID", friendID))

        c.JSON(http.StatusOK, dto.SuccessResponse{
                Success: true,
                Message: "友達を削除しました",
        })</span>
}

// === ブロック機能 ===

// BlockUser ユーザーブロック
// @Summary      ユーザーブロック
// @Description  指定されたユーザーをブロックします
// @Tags         social
// @Accept       json
// @Produce      json
// @Param        userId path string true "ブロックするユーザーID" example:"123e4567-e89b-12d3-a456-426614174000"
// @Security     BearerAuth
// @Success      200 {object} SuccessResponse "ユーザーブロック成功"
// @Failure      400 {object} ErrorResponse "ユーザーIDが無効"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      404 {object} ErrorResponse "ユーザーが見つからない"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /social/users/{userId}/block [post]
func (sc *SocialController) BlockUser(c *gin.Context) <span class="cov0" title="0">{
        user, err := middleware.GetUserFromContext(c)
        if err != nil </span><span class="cov0" title="0">{
                sc.logError("get user from context", err)
                c.JSON(http.StatusUnauthorized, dto.ErrorResponse{
                        Error:   "unauthorized",
                        Message: "認証が必要です",
                })
                return
        }</span>

        <span class="cov0" title="0">targetID, err := sc.validateUUID(c.Param("userId"), "target ID")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, dto.ErrorResponse{
                        Error:   "invalid_user_id",
                        Message: "無効なユーザーIDです",
                })
                return
        }</span>

        <span class="cov0" title="0">err = sc.socialService.BlockUser(c.Request.Context(), user.ID, targetID)
        if err != nil </span><span class="cov0" title="0">{
                sc.logError("block user", err,
                        logger.Any("userID", user.ID),
                        logger.Any("targetID", targetID))
                c.JSON(http.StatusInternalServerError, dto.ErrorResponse{
                        Error:   "block_user_failed",
                        Message: "ユーザーのブロックに失敗しました",
                })
                return
        }</span>

        <span class="cov0" title="0">sc.logger.Info("User blocked successfully",
                logger.Any("userID", user.ID),
                logger.Any("targetID", targetID))

        c.JSON(http.StatusOK, dto.SuccessResponse{
                Success: true,
                Message: "ユーザーをブロックしました",
        })</span>
}

// UnblockUser ブロック解除
// @Summary      ブロック解除
// @Description  指定されたユーザーのブロックを解除します
// @Tags         social
// @Accept       json
// @Produce      json
// @Param        userId path string true "ブロック解除するユーザーID" example:"123e4567-e89b-12d3-a456-426614174000"
// @Security     BearerAuth
// @Success      200 {object} SuccessResponse "ブロック解除成功"
// @Failure      400 {object} ErrorResponse "ユーザーIDが無効"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      404 {object} ErrorResponse "ブロック関係が見つからない"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /social/users/{userId}/block [delete]
func (sc *SocialController) UnblockUser(c *gin.Context) <span class="cov0" title="0">{
        user, err := middleware.GetUserFromContext(c)
        if err != nil </span><span class="cov0" title="0">{
                sc.logError("get user from context", err)
                c.JSON(http.StatusUnauthorized, dto.ErrorResponse{
                        Error:   "unauthorized",
                        Message: "認証が必要です",
                })
                return
        }</span>

        <span class="cov0" title="0">targetID, err := sc.validateUUID(c.Param("userId"), "target ID")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, dto.ErrorResponse{
                        Error:   "invalid_user_id",
                        Message: "無効なユーザーIDです",
                })
                return
        }</span>

        <span class="cov0" title="0">err = sc.socialService.UnblockUser(c.Request.Context(), user.ID, targetID)
        if err != nil </span><span class="cov0" title="0">{
                sc.logError("unblock user", err,
                        logger.Any("userID", user.ID),
                        logger.Any("targetID", targetID))
                c.JSON(http.StatusInternalServerError, dto.ErrorResponse{
                        Error:   "unblock_user_failed",
                        Message: "ブロック解除に失敗しました",
                })
                return
        }</span>

        <span class="cov0" title="0">sc.logger.Info("User unblocked successfully",
                logger.Any("userID", user.ID),
                logger.Any("targetID", targetID))

        c.JSON(http.StatusOK, dto.SuccessResponse{
                Success: true,
                Message: "ブロックを解除しました",
        })</span>
}

// === 友達一覧・検索 ===

// GetFriends 友達一覧取得
// @Summary      友達一覧取得
// @Description  自分の友達一覧を取得します（ページング対応）
// @Tags         social
// @Accept       json
// @Produce      json
// @Param        page query int false "ページ番号" default(1) minimum(1)
// @Param        page_size query int false "ページサイズ" default(20) minimum(1) maximum(100)
// @Security     BearerAuth
// @Success      200 {object} FriendsListResponse "友達一覧取得成功"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /social/friends [get]
func (sc *SocialController) GetFriends(c *gin.Context) <span class="cov0" title="0">{
        user, err := middleware.GetUserFromContext(c)
        if err != nil </span><span class="cov0" title="0">{
                sc.logError("get user from context", err)
                c.JSON(http.StatusUnauthorized, dto.ErrorResponse{
                        Error:   "unauthorized",
                        Message: "認証が必要です",
                })
                return
        }</span>

        <span class="cov0" title="0">pagination := sc.getPaginationFromQuery(c)
        friends, err := sc.socialService.GetFriends(c.Request.Context(), user.ID, pagination)
        if err != nil </span><span class="cov0" title="0">{
                sc.logError("get friends", err, logger.Any("userID", user.ID))
                c.JSON(http.StatusInternalServerError, dto.ErrorResponse{
                        Error:   "get_friends_failed",
                        Message: "友達一覧の取得に失敗しました",
                })
                return
        }</span>

        // TODO: 総数を取得する実装が必要
        <span class="cov0" title="0">total := len(friends)
        response := dto.ToFriendsListResponse(friends, total, pagination.Page, pagination.PageSize)
        c.JSON(http.StatusOK, response)</span>
}

// GetPendingRequests 受信した友達申請取得
// @Summary      受信した友達申請取得
// @Description  自分宛の友達申請一覧を取得します（ページング対応）
// @Tags         social
// @Accept       json
// @Produce      json
// @Param        page query int false "ページ番号" default(1) minimum(1)
// @Param        page_size query int false "ページサイズ" default(20) minimum(1) maximum(100)
// @Security     BearerAuth
// @Success      200 {object} dto.PendingRequestsResponse "友達申請一覧取得成功"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /social/friends/requests/received [get]
func (sc *SocialController) GetPendingRequests(c *gin.Context) <span class="cov0" title="0">{
        user, err := middleware.GetUserFromContext(c)
        if err != nil </span><span class="cov0" title="0">{
                sc.logError("get user from context", err)
                c.JSON(http.StatusUnauthorized, dto.ErrorResponse{
                        Error:   "unauthorized",
                        Message: "認証が必要です",
                })
                return
        }</span>

        <span class="cov0" title="0">pagination := sc.getPaginationFromQuery(c)
        requests, err := sc.socialService.GetPendingRequests(c.Request.Context(), user.ID, pagination)
        if err != nil </span><span class="cov0" title="0">{
                sc.logError("get pending requests", err, logger.Any("userID", user.ID))
                c.JSON(http.StatusInternalServerError, dto.ErrorResponse{
                        Error:   "get_pending_requests_failed",
                        Message: "友達申請一覧の取得に失敗しました",
                })
                return
        }</span>

        // TODO: 総数を取得する実装が必要
        <span class="cov0" title="0">total := len(requests)
        response := dto.ToPendingRequestsResponse(requests, total, pagination.Page, pagination.PageSize)
        c.JSON(http.StatusOK, response)</span>
}

// GetSentRequests 送信した友達申請取得
// @Summary      送信した友達申請取得
// @Description  自分が送信した友達申請一覧を取得します（ページング対応）
// @Tags         social
// @Accept       json
// @Produce      json
// @Param        page query int false "ページ番号" default(1) minimum(1)
// @Param        page_size query int false "ページサイズ" default(20) minimum(1) maximum(100)
// @Security     BearerAuth
// @Success      200 {object} dto.SentRequestsResponse "送信済み申請一覧取得成功"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /social/friends/requests/sent [get]
func (sc *SocialController) GetSentRequests(c *gin.Context) <span class="cov0" title="0">{
        user, err := middleware.GetUserFromContext(c)
        if err != nil </span><span class="cov0" title="0">{
                sc.logError("get user from context", err)
                c.JSON(http.StatusUnauthorized, dto.ErrorResponse{
                        Error:   "unauthorized",
                        Message: "認証が必要です",
                })
                return
        }</span>

        <span class="cov0" title="0">pagination := sc.getPaginationFromQuery(c)
        requests, err := sc.socialService.GetSentRequests(c.Request.Context(), user.ID, pagination)
        if err != nil </span><span class="cov0" title="0">{
                sc.logError("get sent requests", err, logger.Any("userID", user.ID))
                c.JSON(http.StatusInternalServerError, dto.ErrorResponse{
                        Error:   "get_sent_requests_failed",
                        Message: "送信済み申請一覧の取得に失敗しました",
                })
                return
        }</span>

        // TODO: 総数を取得する実装が必要
        <span class="cov0" title="0">total := len(requests)
        response := dto.ToPendingRequestsResponse(requests, total, pagination.Page, pagination.PageSize)
        c.JSON(http.StatusOK, response)</span>
}

// GetMutualFriends 共通の友達取得
// @Summary      共通の友達取得
// @Description  指定されたユーザーとの共通の友達を取得します
// @Tags         social
// @Accept       json
// @Produce      json
// @Param        userId path string true "対象ユーザーID" example:"123e4567-e89b-12d3-a456-426614174000"
// @Security     BearerAuth
// @Success      200 {object} object{data=[]FriendWithUserInfoResponse} "共通の友達取得成功"
// @Failure      400 {object} ErrorResponse "ユーザーIDが無効"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      404 {object} ErrorResponse "ユーザーが見つからない"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /social/friends/{userId}/mutual [get]
func (sc *SocialController) GetMutualFriends(c *gin.Context) <span class="cov0" title="0">{
        user, err := middleware.GetUserFromContext(c)
        if err != nil </span><span class="cov0" title="0">{
                sc.logError("get user from context", err)
                c.JSON(http.StatusUnauthorized, dto.ErrorResponse{
                        Error:   "unauthorized",
                        Message: "認証が必要です",
                })
                return
        }</span>

        <span class="cov0" title="0">targetID, err := sc.validateUUID(c.Param("userId"), "target ID")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, dto.ErrorResponse{
                        Error:   "invalid_user_id",
                        Message: "無効なユーザーIDです",
                })
                return
        }</span>

        <span class="cov0" title="0">mutualFriends, err := sc.socialService.GetMutualFriends(c.Request.Context(), user.ID, targetID)
        if err != nil </span><span class="cov0" title="0">{
                sc.logError("get mutual friends", err,
                        logger.Any("userID", user.ID),
                        logger.Any("targetID", targetID))
                c.JSON(http.StatusInternalServerError, dto.ErrorResponse{
                        Error:   "get_mutual_friends_failed",
                        Message: "共通の友達の取得に失敗しました",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "data": mutualFriends,
        })</span>
}

// === 招待管理 ===

// CreateInvitation 招待作成
// @Summary      招待作成
// @Description  友達招待またはグループ招待を作成します
// @Tags         social
// @Accept       json
// @Produce      json
// @Param        request body CreateInvitationRequest true "招待作成情報"
// @Security     BearerAuth
// @Success      201 {object} InvitationResponse "招待作成成功"
// @Failure      400 {object} ErrorResponse "リクエストが無効"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /social/invitations [post]
func (sc *SocialController) CreateInvitation(c *gin.Context) <span class="cov0" title="0">{
        user, err := middleware.GetUserFromContext(c)
        if err != nil </span><span class="cov0" title="0">{
                sc.logError("get user from context", err)
                c.JSON(http.StatusUnauthorized, dto.ErrorResponse{
                        Error:   "unauthorized",
                        Message: "認証が必要です",
                })
                return
        }</span>

        <span class="cov0" title="0">var req dto.CreateInvitationRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                sc.logError("bind JSON", err)
                c.JSON(http.StatusBadRequest, dto.ErrorResponse{
                        Error:   "invalid_request",
                        Message: "リクエストの形式が正しくありません",
                })
                return
        }</span>

        // 招待タイプのバリデーション
        <span class="cov0" title="0">invitationType := domain.InvitationType(req.Type)
        if invitationType != domain.InvitationTypeFriend &amp;&amp; invitationType != domain.InvitationTypeGroup </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, dto.ErrorResponse{
                        Error:   "invalid_invitation_type",
                        Message: "無効な招待タイプです",
                })
                return
        }</span>

        // 招待方法のバリデーション
        <span class="cov0" title="0">invitationMethod := domain.InvitationMethod(req.Method)
        if invitationMethod != domain.MethodInApp &amp;&amp; invitationMethod != domain.MethodCode &amp;&amp; invitationMethod != domain.MethodURL </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, dto.ErrorResponse{
                        Error:   "invalid_invitation_method",
                        Message: "無効な招待方法です",
                })
                return
        }</span>

        <span class="cov0" title="0">input := usecase.CreateInvitationInput{
                Type:         invitationType,
                Method:       invitationMethod,
                InviterID:    user.ID,
                Message:      req.Message,
                ExpiresHours: req.ExpiresHours,
                InviteeEmail: req.InviteeEmail,
        }

        if req.TargetID != nil </span><span class="cov0" title="0">{
                targetID, err := sc.validateUUID(*req.TargetID, "target ID")
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, dto.ErrorResponse{
                                Error:   "invalid_target_id",
                                Message: "無効なターゲットIDです",
                        })
                        return
                }</span>
                <span class="cov0" title="0">input.TargetID = &amp;targetID</span>
        }

        // グループ招待の場合、TargetIDが必要
        <span class="cov0" title="0">if invitationType == domain.InvitationTypeGroup &amp;&amp; input.TargetID == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, dto.ErrorResponse{
                        Error:   "target_id_required",
                        Message: "グループ招待にはグループIDが必要です",
                })
                return
        }</span>

        // デフォルト値設定
        <span class="cov0" title="0">if input.ExpiresHours == 0 </span><span class="cov0" title="0">{
                input.ExpiresHours = 168 // 1週間
        }</span>

        <span class="cov0" title="0">invitation, err := sc.socialService.CreateInvitation(c.Request.Context(), input)
        if err != nil </span><span class="cov0" title="0">{
                sc.logError("create invitation", err, logger.Any("inviterID", user.ID))
                c.JSON(http.StatusInternalServerError, dto.ErrorResponse{
                        Error:   "create_invitation_failed",
                        Message: "招待の作成に失敗しました",
                })
                return
        }</span>

        <span class="cov0" title="0">sc.logger.Info("Invitation created successfully",
                logger.Any("inviterID", user.ID),
                logger.Any("invitationID", invitation.ID))

        response := dto.ToInvitationResponse(invitation)
        c.JSON(http.StatusCreated, response)</span>
}

// GetInvitation 招待詳細取得
// @Summary      招待詳細取得
// @Description  招待の詳細情報を取得します（権限チェック付き）
// @Tags         social
// @Accept       json
// @Produce      json
// @Param        invitationId path string true "招待ID" example:"123e4567-e89b-12d3-a456-426614174000"
// @Security     BearerAuth
// @Success      200 {object} InvitationResponse "招待詳細取得成功"
// @Failure      400 {object} ErrorResponse "招待IDが無効"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      403 {object} ErrorResponse "この招待を閲覧する権限がない"
// @Failure      404 {object} ErrorResponse "招待が見つからない"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /social/invitations/{invitationId} [get]
func (sc *SocialController) GetInvitation(c *gin.Context) <span class="cov0" title="0">{
        user, err := middleware.GetUserFromContext(c)
        if err != nil </span><span class="cov0" title="0">{
                sc.logError("get user from context", err)
                c.JSON(http.StatusUnauthorized, dto.ErrorResponse{
                        Error:   "unauthorized",
                        Message: "認証が必要です",
                })
                return
        }</span>

        <span class="cov0" title="0">invitationID, err := sc.validateUUID(c.Param("invitationId"), "invitation ID")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, dto.ErrorResponse{
                        Error:   "invalid_invitation_id",
                        Message: "無効な招待IDです",
                })
                return
        }</span>

        <span class="cov0" title="0">invitation, err := sc.socialService.GetInvitation(c.Request.Context(), invitationID)
        if err != nil </span><span class="cov0" title="0">{
                sc.logError("get invitation", err, logger.Any("invitationID", invitationID))
                c.JSON(http.StatusInternalServerError, dto.ErrorResponse{
                        Error:   "get_invitation_failed",
                        Message: "招待情報の取得に失敗しました",
                })
                return
        }</span>

        <span class="cov0" title="0">if invitation == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, dto.ErrorResponse{
                        Error:   "invitation_not_found",
                        Message: "招待が見つかりません",
                })
                return
        }</span>

        // 権限チェック（招待者または被招待者のみ閲覧可能）
        <span class="cov0" title="0">if invitation.InviterID != user.ID &amp;&amp;
                (invitation.InviteeID == nil || *invitation.InviteeID != user.ID) </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, dto.ErrorResponse{
                        Error:   "access_denied",
                        Message: "この招待を閲覧する権限がありません",
                })
                return
        }</span>

        <span class="cov0" title="0">response := dto.ToInvitationResponse(invitation)
        c.JSON(http.StatusOK, response)</span>
}

// GetInvitationByCode 招待コードから招待取得
// @Summary      招待コードから招待取得
// @Description  招待コードを使用して招待情報を取得します（パブリック情報のみ）
// @Tags         social
// @Accept       json
// @Produce      json
// @Param        code path string true "招待コード" example:"abc123def456"
// @Success      200 {object} object{data=object{id=string,type=string,method=string,status=string,message=string,expires_at=string,created_at=string}} "招待情報取得成功"
// @Failure      400 {object} ErrorResponse "招待コードが必要"
// @Failure      404 {object} ErrorResponse "有効な招待が見つからない"
// @Failure      410 {object} ErrorResponse "招待の有効期限が切れている"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /social/invitations/code/{code} [get]
func (sc *SocialController) GetInvitationByCode(c *gin.Context) <span class="cov0" title="0">{
        code := c.Param("code")
        if code == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, dto.ErrorResponse{
                        Error:   "code_required",
                        Message: "招待コードが必要です",
                })
                return
        }</span>

        <span class="cov0" title="0">invitation, err := sc.socialService.GetInvitationByCode(c.Request.Context(), code)
        if err != nil </span><span class="cov0" title="0">{
                sc.logError("get invitation by code", err, logger.Any("code", code))
                c.JSON(http.StatusInternalServerError, dto.ErrorResponse{
                        Error:   "get_invitation_failed",
                        Message: "招待情報の取得に失敗しました",
                })
                return
        }</span>

        <span class="cov0" title="0">if invitation == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, dto.ErrorResponse{
                        Error:   "invitation_not_found",
                        Message: "有効な招待が見つかりません",
                })
                return
        }</span>

        // 期限切れチェック
        <span class="cov0" title="0">if invitation.IsExpired() </span><span class="cov0" title="0">{
                c.JSON(http.StatusGone, dto.ErrorResponse{
                        Error:   "invitation_expired",
                        Message: "招待の有効期限が切れています",
                })
                return
        }</span>

        // プライベート情報を除外した公開情報のみ返す
        <span class="cov0" title="0">publicInvitation := struct {
                ID        uuid.UUID               `json:"id"`
                Type      domain.InvitationType   `json:"type"`
                Method    domain.InvitationMethod `json:"method"`
                Status    domain.InvitationStatus `json:"status"`
                Message   string                  `json:"message"`
                ExpiresAt string                  `json:"expires_at"`
                CreatedAt string                  `json:"created_at"`
        }{
                ID:        invitation.ID,
                Type:      invitation.Type,
                Method:    invitation.Method,
                Status:    invitation.Status,
                Message:   invitation.Message,
                ExpiresAt: invitation.ExpiresAt.Format("2006-01-02T15:04:05Z07:00"),
                CreatedAt: invitation.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
        }

        c.JSON(http.StatusOK, gin.H{
                "data": publicInvitation,
        })</span>
}

// AcceptInvitation 招待受諾
// @Summary      招待受諾
// @Description  招待コードを使用して招待を受諾します
// @Tags         social
// @Accept       json
// @Produce      json
// @Param        code path string true "招待コード" example:"abc123def456"
// @Security     BearerAuth
// @Success      200 {object} InvitationResultResponse "招待受諾成功"
// @Failure      400 {object} ErrorResponse "招待コードが必要"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      404 {object} ErrorResponse "有効な招待が見つからない"
// @Failure      410 {object} ErrorResponse "招待の有効期限が切れている"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /social/invitations/{code}/accept [post]
func (sc *SocialController) AcceptInvitation(c *gin.Context) <span class="cov0" title="0">{
        user, err := middleware.GetUserFromContext(c)
        if err != nil </span><span class="cov0" title="0">{
                sc.logError("get user from context", err)
                c.JSON(http.StatusUnauthorized, dto.ErrorResponse{
                        Error:   "unauthorized",
                        Message: "認証が必要です",
                })
                return
        }</span>

        <span class="cov0" title="0">code := c.Param("code")
        if code == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, dto.ErrorResponse{
                        Error:   "code_required",
                        Message: "招待コードが必要です",
                })
                return
        }</span>

        <span class="cov0" title="0">result, err := sc.socialService.AcceptInvitation(c.Request.Context(), code, user.ID)
        if err != nil </span><span class="cov0" title="0">{
                sc.logError("accept invitation", err,
                        logger.Any("code", code),
                        logger.Any("userID", user.ID))
                c.JSON(http.StatusInternalServerError, dto.ErrorResponse{
                        Error:   "accept_invitation_failed",
                        Message: "招待の受諾に失敗しました",
                })
                return
        }</span>

        <span class="cov0" title="0">sc.logger.Info("Invitation accepted successfully",
                logger.Any("code", code),
                logger.Any("userID", user.ID))

        response := dto.ToInvitationResultResponse(result)
        c.JSON(http.StatusOK, response)</span>
}

// DeclineInvitation 招待拒否
// @Summary      招待拒否
// @Description  受信した招待を拒否します
// @Tags         social
// @Accept       json
// @Produce      json
// @Param        invitationId path string true "招待ID" example:"123e4567-e89b-12d3-a456-426614174000"
// @Security     BearerAuth
// @Success      200 {object} SuccessResponse "招待拒否成功"
// @Failure      400 {object} ErrorResponse "招待IDが無効"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      403 {object} ErrorResponse "この招待を拒否する権限がない"
// @Failure      404 {object} ErrorResponse "招待が見つからない"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /social/invitations/{invitationId}/decline [put]
func (sc *SocialController) DeclineInvitation(c *gin.Context) <span class="cov0" title="0">{
        user, err := middleware.GetUserFromContext(c)
        if err != nil </span><span class="cov0" title="0">{
                sc.logError("get user from context", err)
                c.JSON(http.StatusUnauthorized, dto.ErrorResponse{
                        Error:   "unauthorized",
                        Message: "認証が必要です",
                })
                return
        }</span>

        <span class="cov0" title="0">invitationID, err := sc.validateUUID(c.Param("invitationId"), "invitation ID")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, dto.ErrorResponse{
                        Error:   "invalid_invitation_id",
                        Message: "無効な招待IDです",
                })
                return
        }</span>

        <span class="cov0" title="0">err = sc.socialService.DeclineInvitation(c.Request.Context(), invitationID, user.ID)
        if err != nil </span><span class="cov0" title="0">{
                sc.logError("decline invitation", err,
                        logger.Any("invitationID", invitationID),
                        logger.Any("userID", user.ID))
                c.JSON(http.StatusInternalServerError, dto.ErrorResponse{
                        Error:   "decline_invitation_failed",
                        Message: "招待の拒否に失敗しました",
                })
                return
        }</span>

        <span class="cov0" title="0">sc.logger.Info("Invitation declined successfully",
                logger.Any("invitationID", invitationID),
                logger.Any("userID", user.ID))

        c.JSON(http.StatusOK, dto.SuccessResponse{
                Success: true,
                Message: "招待を拒否しました",
        })</span>
}

// CancelInvitation 招待キャンセル
// @Summary      招待キャンセル
// @Description  送信した招待をキャンセルします
// @Tags         social
// @Accept       json
// @Produce      json
// @Param        invitationId path string true "招待ID" example:"123e4567-e89b-12d3-a456-426614174000"
// @Security     BearerAuth
// @Success      200 {object} SuccessResponse "招待キャンセル成功"
// @Failure      400 {object} ErrorResponse "招待IDが無効"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      403 {object} ErrorResponse "この招待をキャンセルする権限がない"
// @Failure      404 {object} ErrorResponse "招待が見つからない"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /social/invitations/{invitationId} [delete]
func (sc *SocialController) CancelInvitation(c *gin.Context) <span class="cov0" title="0">{
        user, err := middleware.GetUserFromContext(c)
        if err != nil </span><span class="cov0" title="0">{
                sc.logError("get user from context", err)
                c.JSON(http.StatusUnauthorized, dto.ErrorResponse{
                        Error:   "unauthorized",
                        Message: "認証が必要です",
                })
                return
        }</span>

        <span class="cov0" title="0">invitationID, err := sc.validateUUID(c.Param("invitationId"), "invitation ID")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, dto.ErrorResponse{
                        Error:   "invalid_invitation_id",
                        Message: "無効な招待IDです",
                })
                return
        }</span>

        <span class="cov0" title="0">err = sc.socialService.CancelInvitation(c.Request.Context(), invitationID, user.ID)
        if err != nil </span><span class="cov0" title="0">{
                sc.logError("cancel invitation", err,
                        logger.Any("invitationID", invitationID),
                        logger.Any("userID", user.ID))
                c.JSON(http.StatusInternalServerError, dto.ErrorResponse{
                        Error:   "cancel_invitation_failed",
                        Message: "招待のキャンセルに失敗しました",
                })
                return
        }</span>

        <span class="cov0" title="0">sc.logger.Info("Invitation cancelled successfully",
                logger.Any("invitationID", invitationID),
                logger.Any("userID", user.ID))

        c.JSON(http.StatusOK, dto.SuccessResponse{
                Success: true,
                Message: "招待をキャンセルしました",
        })</span>
}

// GetSentInvitations 送信した招待一覧取得
// @Summary      送信した招待一覧取得
// @Description  自分が送信した招待一覧を取得します（ページング対応）
// @Tags         social
// @Accept       json
// @Produce      json
// @Param        page query int false "ページ番号" default(1) minimum(1)
// @Param        page_size query int false "ページサイズ" default(20) minimum(1) maximum(100)
// @Security     BearerAuth
// @Success      200 {object} dto.InvitationsListResponse "送信済み招待一覧取得成功"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /social/invitations/sent [get]
func (sc *SocialController) GetSentInvitations(c *gin.Context) <span class="cov0" title="0">{
        user, err := middleware.GetUserFromContext(c)
        if err != nil </span><span class="cov0" title="0">{
                sc.logError("get user from context", err)
                c.JSON(http.StatusUnauthorized, dto.ErrorResponse{
                        Error:   "unauthorized",
                        Message: "認証が必要です",
                })
                return
        }</span>

        <span class="cov0" title="0">pagination := sc.getPaginationFromQuery(c)
        invitations, err := sc.socialService.GetSentInvitations(c.Request.Context(), user.ID, pagination)
        if err != nil </span><span class="cov0" title="0">{
                sc.logError("get sent invitations", err, logger.Any("userID", user.ID))
                c.JSON(http.StatusInternalServerError, dto.ErrorResponse{
                        Error:   "get_sent_invitations_failed",
                        Message: "送信済み招待の取得に失敗しました",
                })
                return
        }</span>

        // TODO: 総数を取得する実装が必要
        <span class="cov0" title="0">total := len(invitations)
        response := dto.ToInvitationsListResponse(invitations, total, pagination.Page, pagination.PageSize)
        c.JSON(http.StatusOK, response)</span>
}

// GetReceivedInvitations 受信した招待一覧取得
// @Summary      受信した招待一覧取得
// @Description  自分が受信した招待一覧を取得します（ページング対応）
// @Tags         social
// @Accept       json
// @Produce      json
// @Param        page query int false "ページ番号" default(1) minimum(1)
// @Param        page_size query int false "ページサイズ" default(20) minimum(1) maximum(100)
// @Security     BearerAuth
// @Success      200 {object} dto.InvitationsListResponse "受信済み招待一覧取得成功"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /social/invitations/received [get]
func (sc *SocialController) GetReceivedInvitations(c *gin.Context) <span class="cov0" title="0">{
        user, err := middleware.GetUserFromContext(c)
        if err != nil </span><span class="cov0" title="0">{
                sc.logError("get user from context", err)
                c.JSON(http.StatusUnauthorized, dto.ErrorResponse{
                        Error:   "unauthorized",
                        Message: "認証が必要です",
                })
                return
        }</span>

        <span class="cov0" title="0">pagination := sc.getPaginationFromQuery(c)
        invitations, err := sc.socialService.GetReceivedInvitations(c.Request.Context(), user.ID, pagination)
        if err != nil </span><span class="cov0" title="0">{
                sc.logError("get received invitations", err, logger.Any("userID", user.ID))
                c.JSON(http.StatusInternalServerError, dto.ErrorResponse{
                        Error:   "get_received_invitations_failed",
                        Message: "受信済み招待の取得に失敗しました",
                })
                return
        }</span>

        // TODO: 総数を取得する実装が必要
        <span class="cov0" title="0">total := len(invitations)
        response := dto.ToInvitationsListResponse(invitations, total, pagination.Page, pagination.PageSize)
        c.JSON(http.StatusOK, response)</span>
}

// GenerateInviteURL 招待URL生成
// @Summary      招待URL生成
// @Description  指定された招待のURLを生成します
// @Tags         social
// @Accept       json
// @Produce      json
// @Param        invitationId path string true "招待ID" example:"123e4567-e89b-12d3-a456-426614174000"
// @Security     BearerAuth
// @Success      200 {object} InviteURLResponse "招待URL生成成功"
// @Failure      400 {object} ErrorResponse "招待IDが無効"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      403 {object} ErrorResponse "この招待のURLを生成する権限がない"
// @Failure      404 {object} ErrorResponse "招待が見つからない"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /social/invitations/{invitationId}/url [get]
func (sc *SocialController) GenerateInviteURL(c *gin.Context) <span class="cov0" title="0">{
        user, err := middleware.GetUserFromContext(c)
        if err != nil </span><span class="cov0" title="0">{
                sc.logError("get user from context", err)
                c.JSON(http.StatusUnauthorized, dto.ErrorResponse{
                        Error:   "unauthorized",
                        Message: "認証が必要です",
                })
                return
        }</span>

        <span class="cov0" title="0">invitationID, err := sc.validateUUID(c.Param("invitationId"), "invitation ID")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, dto.ErrorResponse{
                        Error:   "invalid_invitation_id",
                        Message: "無効な招待IDです",
                })
                return
        }</span>

        <span class="cov0" title="0">url, err := sc.socialService.GenerateInviteURL(c.Request.Context(), invitationID)
        if err != nil </span><span class="cov0" title="0">{
                sc.logError("generate invite URL", err,
                        logger.Any("userID", user.ID),
                        logger.Any("invitationID", invitationID))
                c.JSON(http.StatusInternalServerError, dto.ErrorResponse{
                        Error:   "generate_url_failed",
                        Message: "招待URLの生成に失敗しました",
                })
                return
        }</span>

        // 招待情報も取得してレスポンスに含める
        <span class="cov0" title="0">invitation, err := sc.socialService.GetInvitation(c.Request.Context(), invitationID)
        if err != nil </span><span class="cov0" title="0">{
                sc.logError("get invitation details", err)
                c.JSON(http.StatusInternalServerError, dto.ErrorResponse{
                        Error:   "get_invitation_failed",
                        Message: "招待情報の取得に失敗しました",
                })
                return
        }</span>

        <span class="cov0" title="0">response := dto.InviteURLResponse{
                URL:       url,
                Code:      invitation.Code,
                ExpiresAt: invitation.ExpiresAt,
        }

        c.JSON(http.StatusOK, response)</span>
}

// GetRelationship ユーザー間関係取得
// @Summary      ユーザー間関係取得
// @Description  指定されたユーザーとの関係性（友達、ブロック、申請状況）を取得します
// @Tags         social
// @Accept       json
// @Produce      json
// @Param        userId path string true "対象ユーザーID" example:"123e4567-e89b-12d3-a456-426614174000"
// @Security     BearerAuth
// @Success      200 {object} UserRelationshipResponse "関係性取得成功"
// @Failure      400 {object} ErrorResponse "ユーザーIDが無効"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      404 {object} ErrorResponse "ユーザーが見つからない"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /social/relationships/{userId} [get]
func (sc *SocialController) GetRelationship(c *gin.Context) <span class="cov0" title="0">{
        user, err := middleware.GetUserFromContext(c)
        if err != nil </span><span class="cov0" title="0">{
                sc.logError("get user from context", err)
                c.JSON(http.StatusUnauthorized, dto.ErrorResponse{
                        Error:   "unauthorized",
                        Message: "認証が必要です",
                })
                return
        }</span>

        <span class="cov0" title="0">targetUserID, err := sc.validateUUID(c.Param("userId"), "user ID")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, dto.ErrorResponse{
                        Error:   "invalid_user_id",
                        Message: "無効なユーザーIDです",
                })
                return
        }</span>

        <span class="cov0" title="0">relationship, err := sc.socialService.GetRelationship(c.Request.Context(), user.ID, targetUserID)
        if err != nil </span><span class="cov0" title="0">{
                sc.logError("get relationship", err,
                        logger.Any("userID", user.ID),
                        logger.Any("targetUserID", targetUserID))
                c.JSON(http.StatusInternalServerError, dto.ErrorResponse{
                        Error:   "get_relationship_failed",
                        Message: "関係性の取得に失敗しました",
                })
                return
        }</span>

        <span class="cov0" title="0">response := dto.ToUserRelationshipResponse(relationship)
        c.JSON(http.StatusOK, response)</span>
}

// === ヘルパーメソッド ===

func (sc *SocialController) validateUUID(id string, fieldName string) (uuid.UUID, error) <span class="cov0" title="0">{
        parsedID, err := uuid.Parse(id)
        if err != nil </span><span class="cov0" title="0">{
                sc.logger.Error("Invalid UUID format",
                        logger.String("field", fieldName),
                        logger.String("value", id),
                        logger.Error(err))
                return uuid.Nil, err
        }</span>
        <span class="cov0" title="0">return parsedID, nil</span>
}

func (sc *SocialController) logError(operation string, err error, fields ...zapcore.Field) <span class="cov0" title="0">{
        sc.logger.Error("Operation failed",
                append([]zapcore.Field{
                        logger.String("operation", operation),
                        logger.Error(err),
                }, fields...)...)
}</span>

func (sc *SocialController) getPaginationFromQuery(c *gin.Context) commonDomain.Pagination <span class="cov0" title="0">{
        page := 1
        pageSize := 20

        if pageStr := c.Query("page"); pageStr != "" </span><span class="cov0" title="0">{
                if p, err := strconv.Atoi(pageStr); err == nil &amp;&amp; p &gt; 0 </span><span class="cov0" title="0">{
                        page = p
                }</span>
        }

        <span class="cov0" title="0">if pageSizeStr := c.Query("page_size"); pageSizeStr != "" </span><span class="cov0" title="0">{
                if ps, err := strconv.Atoi(pageSizeStr); err == nil &amp;&amp; ps &gt; 0 &amp;&amp; ps &lt;= 100 </span><span class="cov0" title="0">{
                        pageSize = ps
                }</span>
        }

        <span class="cov0" title="0">return commonDomain.Pagination{
                Page:     page,
                PageSize: pageSize,
        }</span>
}

// RegisterSocialRoutes はソーシャル関連のルートを登録する
func RegisterSocialRoutes(router *gin.RouterGroup, controller *SocialController) <span class="cov0" title="0">{
        social := router.Group("/social")
        </span><span class="cov0" title="0">{
                // 友達関係管理
                social.POST("/friends/requests", controller.SendFriendRequest)
                social.PUT("/friends/requests/:friendshipId/accept", controller.AcceptFriendRequest)
                social.PUT("/friends/requests/:friendshipId/decline", controller.DeclineFriendRequest)
                social.DELETE("/friends/:userId", controller.RemoveFriend)

                // ブロック機能
                social.POST("/users/:userId/block", controller.BlockUser)
                social.DELETE("/users/:userId/block", controller.UnblockUser)

                // 友達一覧・検索
                social.GET("/friends", controller.GetFriends)
                social.GET("/friends/:userId/mutual", controller.GetMutualFriends)
                social.GET("/friends/requests/received", controller.GetPendingRequests)
                social.GET("/friends/requests/sent", controller.GetSentRequests)

                // 招待管理
                social.POST("/invitations", controller.CreateInvitation)
                social.GET("/invitations/:invitationId", controller.GetInvitation)
                social.GET("/invitations/code/:code", controller.GetInvitationByCode)
                social.POST("/invitations/:code/accept", controller.AcceptInvitation)
                social.PUT("/invitations/:invitationId/decline", controller.DeclineInvitation)
                social.DELETE("/invitations/:invitationId", controller.CancelInvitation)
                social.GET("/invitations/sent", controller.GetSentInvitations)
                social.GET("/invitations/received", controller.GetReceivedInvitations)
                social.GET("/invitations/:invitationId/url", controller.GenerateInviteURL)

                // 関係性チェック
                social.GET("/relationships/:userId", controller.GetRelationship)
        }</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package database

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/google/uuid"
        commonDomain "github.com/hryt430/Yotei+/internal/common/domain"
        "github.com/hryt430/Yotei+/internal/modules/social/domain"
        "github.com/hryt430/Yotei+/internal/modules/social/usecase"
        "github.com/hryt430/Yotei+/pkg/logger"
)

type FriendshipRepository struct {
        db     *sql.DB
        logger logger.Logger
}

func NewFriendshipRepository(db *sql.DB, logger logger.Logger) usecase.FriendshipRepository <span class="cov0" title="0">{
        return &amp;FriendshipRepository{
                db:     db,
                logger: logger,
        }
}</span>

// CreateFriendship は友達関係を作成する
func (r *FriendshipRepository) CreateFriendship(ctx context.Context, friendship *domain.Friendship) error <span class="cov0" title="0">{
        query := `
                INSERT INTO friendships (id, requester_id, addressee_id, status, created_at, updated_at)
                VALUES (?, ?, ?, ?, ?, ?)
        `

        _, err := r.db.ExecContext(ctx, query,
                friendship.ID,
                friendship.RequesterID,
                friendship.AddresseeID,
                friendship.Status,
                friendship.CreatedAt,
                friendship.UpdatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to create friendship",
                        logger.Any("friendship", friendship),
                        logger.Error(err))
                return fmt.Errorf("failed to create friendship: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetFriendship は友達関係を取得する
func (r *FriendshipRepository) GetFriendship(ctx context.Context, requesterID, addresseeID uuid.UUID) (*domain.Friendship, error) <span class="cov0" title="0">{
        query := `
                SELECT id, requester_id, addressee_id, status, created_at, updated_at, accepted_at, blocked_at
                FROM friendships
                WHERE (requester_id = ? AND addressee_id = ?) OR (requester_id = ? AND addressee_id = ?)
        `

        var friendship domain.Friendship
        var acceptedAt, blockedAt sql.NullTime

        err := r.db.QueryRowContext(ctx, query, requesterID, addresseeID, addresseeID, requesterID).Scan(
                &amp;friendship.ID,
                &amp;friendship.RequesterID,
                &amp;friendship.AddresseeID,
                &amp;friendship.Status,
                &amp;friendship.CreatedAt,
                &amp;friendship.UpdatedAt,
                &amp;acceptedAt,
                &amp;blockedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">r.logger.Error("Failed to get friendship",
                        logger.Any("requesterID", requesterID),
                        logger.Any("addresseeID", addresseeID),
                        logger.Error(err))
                return nil, fmt.Errorf("failed to get friendship: %w", err)</span>
        }

        <span class="cov0" title="0">if acceptedAt.Valid </span><span class="cov0" title="0">{
                friendship.AcceptedAt = &amp;acceptedAt.Time
        }</span>
        <span class="cov0" title="0">if blockedAt.Valid </span><span class="cov0" title="0">{
                friendship.BlockedAt = &amp;blockedAt.Time
        }</span>

        <span class="cov0" title="0">return &amp;friendship, nil</span>
}

// GetFriendshipByID はIDで友達関係を取得する
func (r *FriendshipRepository) GetFriendshipByID(ctx context.Context, friendshipID uuid.UUID) (*domain.Friendship, error) <span class="cov0" title="0">{
        query := `
                SELECT id, requester_id, addressee_id, status, created_at, updated_at, accepted_at, blocked_at
                FROM friendships
                WHERE id = ?
        `

        var friendship domain.Friendship
        var acceptedAt, blockedAt sql.NullTime

        err := r.db.QueryRowContext(ctx, query, friendshipID).Scan(
                &amp;friendship.ID,
                &amp;friendship.RequesterID,
                &amp;friendship.AddresseeID,
                &amp;friendship.Status,
                &amp;friendship.CreatedAt,
                &amp;friendship.UpdatedAt,
                &amp;acceptedAt,
                &amp;blockedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">r.logger.Error("Failed to get friendship by ID",
                        logger.Any("friendshipID", friendshipID),
                        logger.Error(err))
                return nil, fmt.Errorf("failed to get friendship by ID: %w", err)</span>
        }

        <span class="cov0" title="0">if acceptedAt.Valid </span><span class="cov0" title="0">{
                friendship.AcceptedAt = &amp;acceptedAt.Time
        }</span>
        <span class="cov0" title="0">if blockedAt.Valid </span><span class="cov0" title="0">{
                friendship.BlockedAt = &amp;blockedAt.Time
        }</span>

        <span class="cov0" title="0">return &amp;friendship, nil</span>
}

// UpdateFriendship は友達関係を更新する
func (r *FriendshipRepository) UpdateFriendship(ctx context.Context, friendship *domain.Friendship) error <span class="cov0" title="0">{
        query := `
                UPDATE friendships 
                SET status = ?, updated_at = ?, accepted_at = ?, blocked_at = ?
                WHERE id = ?
        `

        _, err := r.db.ExecContext(ctx, query,
                friendship.Status,
                friendship.UpdatedAt,
                friendship.AcceptedAt,
                friendship.BlockedAt,
                friendship.ID,
        )

        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to update friendship",
                        logger.Any("friendship", friendship),
                        logger.Error(err))
                return fmt.Errorf("failed to update friendship: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteFriendship は友達関係を削除する
func (r *FriendshipRepository) DeleteFriendship(ctx context.Context, requesterID, addresseeID uuid.UUID) error <span class="cov0" title="0">{
        query := `
                DELETE FROM friendships 
                WHERE (requester_id = ? AND addressee_id = ?) OR (requester_id = ? AND addressee_id = ?)
        `

        _, err := r.db.ExecContext(ctx, query, requesterID, addresseeID, addresseeID, requesterID)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to delete friendship",
                        logger.Any("requesterID", requesterID),
                        logger.Any("addresseeID", addresseeID),
                        logger.Error(err))
                return fmt.Errorf("failed to delete friendship: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetFriends は友達一覧を取得する
func (r *FriendshipRepository) GetFriends(ctx context.Context, userID uuid.UUID, pagination commonDomain.Pagination) ([]*domain.Friendship, error) <span class="cov0" title="0">{
        offset := (pagination.Page - 1) * pagination.PageSize

        query := `
                SELECT id, requester_id, addressee_id, status, created_at, updated_at, accepted_at, blocked_at
                FROM friendships
                WHERE (requester_id = ? OR addressee_id = ?) AND status = ?
                ORDER BY updated_at DESC
                LIMIT ? OFFSET ?
        `

        rows, err := r.db.QueryContext(ctx, query, userID, userID, domain.FriendshipStatusAccepted, pagination.PageSize, offset)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to get friends",
                        logger.Any("userID", userID),
                        logger.Error(err))
                return nil, fmt.Errorf("failed to get friends: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var friendships []*domain.Friendship
        for rows.Next() </span><span class="cov0" title="0">{
                var friendship domain.Friendship
                var acceptedAt, blockedAt sql.NullTime

                err := rows.Scan(
                        &amp;friendship.ID,
                        &amp;friendship.RequesterID,
                        &amp;friendship.AddresseeID,
                        &amp;friendship.Status,
                        &amp;friendship.CreatedAt,
                        &amp;friendship.UpdatedAt,
                        &amp;acceptedAt,
                        &amp;blockedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to scan friendship", logger.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">if acceptedAt.Valid </span><span class="cov0" title="0">{
                        friendship.AcceptedAt = &amp;acceptedAt.Time
                }</span>
                <span class="cov0" title="0">if blockedAt.Valid </span><span class="cov0" title="0">{
                        friendship.BlockedAt = &amp;blockedAt.Time
                }</span>

                <span class="cov0" title="0">friendships = append(friendships, &amp;friendship)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Error iterating friendship rows", logger.Error(err))
                return nil, fmt.Errorf("error iterating friendship rows: %w", err)
        }</span>

        <span class="cov0" title="0">return friendships, nil</span>
}

// GetPendingRequests は受信した友達申請を取得する
func (r *FriendshipRepository) GetPendingRequests(ctx context.Context, userID uuid.UUID, pagination commonDomain.Pagination) ([]*domain.Friendship, error) <span class="cov0" title="0">{
        offset := (pagination.Page - 1) * pagination.PageSize

        query := `
                SELECT id, requester_id, addressee_id, status, created_at, updated_at, accepted_at, blocked_at
                FROM friendships
                WHERE addressee_id = ? AND status = ?
                ORDER BY created_at DESC
                LIMIT ? OFFSET ?
        `

        rows, err := r.db.QueryContext(ctx, query, userID, domain.FriendshipStatusPending, pagination.PageSize, offset)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to get pending requests",
                        logger.Any("userID", userID),
                        logger.Error(err))
                return nil, fmt.Errorf("failed to get pending requests: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var friendships []*domain.Friendship
        for rows.Next() </span><span class="cov0" title="0">{
                var friendship domain.Friendship
                var acceptedAt, blockedAt sql.NullTime

                err := rows.Scan(
                        &amp;friendship.ID,
                        &amp;friendship.RequesterID,
                        &amp;friendship.AddresseeID,
                        &amp;friendship.Status,
                        &amp;friendship.CreatedAt,
                        &amp;friendship.UpdatedAt,
                        &amp;acceptedAt,
                        &amp;blockedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to scan pending request", logger.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">if acceptedAt.Valid </span><span class="cov0" title="0">{
                        friendship.AcceptedAt = &amp;acceptedAt.Time
                }</span>
                <span class="cov0" title="0">if blockedAt.Valid </span><span class="cov0" title="0">{
                        friendship.BlockedAt = &amp;blockedAt.Time
                }</span>

                <span class="cov0" title="0">friendships = append(friendships, &amp;friendship)</span>
        }

        <span class="cov0" title="0">return friendships, nil</span>
}

// GetSentRequests は送信した友達申請を取得する
func (r *FriendshipRepository) GetSentRequests(ctx context.Context, userID uuid.UUID, pagination commonDomain.Pagination) ([]*domain.Friendship, error) <span class="cov0" title="0">{
        offset := (pagination.Page - 1) * pagination.PageSize

        query := `
                SELECT id, requester_id, addressee_id, status, created_at, updated_at, accepted_at, blocked_at
                FROM friendships
                WHERE requester_id = ? AND status = ?
                ORDER BY created_at DESC
                LIMIT ? OFFSET ?
        `

        rows, err := r.db.QueryContext(ctx, query, userID, domain.FriendshipStatusPending, pagination.PageSize, offset)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to get sent requests",
                        logger.Any("userID", userID),
                        logger.Error(err))
                return nil, fmt.Errorf("failed to get sent requests: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var friendships []*domain.Friendship
        for rows.Next() </span><span class="cov0" title="0">{
                var friendship domain.Friendship
                var acceptedAt, blockedAt sql.NullTime

                err := rows.Scan(
                        &amp;friendship.ID,
                        &amp;friendship.RequesterID,
                        &amp;friendship.AddresseeID,
                        &amp;friendship.Status,
                        &amp;friendship.CreatedAt,
                        &amp;friendship.UpdatedAt,
                        &amp;acceptedAt,
                        &amp;blockedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to scan sent request", logger.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">if acceptedAt.Valid </span><span class="cov0" title="0">{
                        friendship.AcceptedAt = &amp;acceptedAt.Time
                }</span>
                <span class="cov0" title="0">if blockedAt.Valid </span><span class="cov0" title="0">{
                        friendship.BlockedAt = &amp;blockedAt.Time
                }</span>

                <span class="cov0" title="0">friendships = append(friendships, &amp;friendship)</span>
        }

        <span class="cov0" title="0">return friendships, nil</span>
}

// AreFriends は友達関係が成立しているかチェックする
func (r *FriendshipRepository) AreFriends(ctx context.Context, userID1, userID2 uuid.UUID) (bool, error) <span class="cov0" title="0">{
        query := `
                SELECT COUNT(*) FROM friendships
                WHERE ((requester_id = ? AND addressee_id = ?) OR (requester_id = ? AND addressee_id = ?))
                AND status = ?
        `

        var count int
        err := r.db.QueryRowContext(ctx, query, userID1, userID2, userID2, userID1, domain.FriendshipStatusAccepted).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to check if users are friends",
                        logger.Any("userID1", userID1),
                        logger.Any("userID2", userID2),
                        logger.Error(err))
                return false, fmt.Errorf("failed to check if users are friends: %w", err)
        }</span>

        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

// IsBlocked はブロック関係があるかチェックする
func (r *FriendshipRepository) IsBlocked(ctx context.Context, userID1, userID2 uuid.UUID) (bool, error) <span class="cov0" title="0">{
        query := `
                SELECT COUNT(*) FROM friendships
                WHERE ((requester_id = ? AND addressee_id = ?) OR (requester_id = ? AND addressee_id = ?))
                AND status = ?
        `

        var count int
        err := r.db.QueryRowContext(ctx, query, userID1, userID2, userID2, userID1, domain.FriendshipStatusBlocked).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to check if user is blocked",
                        logger.Any("userID1", userID1),
                        logger.Any("userID2", userID2),
                        logger.Error(err))
                return false, fmt.Errorf("failed to check if user is blocked: %w", err)
        }</span>

        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

// GetFriendCount は友達数を取得する
func (r *FriendshipRepository) GetFriendCount(ctx context.Context, userID uuid.UUID) (int, error) <span class="cov0" title="0">{
        query := `
                SELECT COUNT(*) FROM friendships
                WHERE (requester_id = ? OR addressee_id = ?) AND status = ?
        `

        var count int
        err := r.db.QueryRowContext(ctx, query, userID, userID, domain.FriendshipStatusAccepted).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to get friend count",
                        logger.Any("userID", userID),
                        logger.Error(err))
                return 0, fmt.Errorf("failed to get friend count: %w", err)
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}

// GetMutualFriends は共通の友達を取得する
func (r *FriendshipRepository) GetMutualFriends(ctx context.Context, userID1, userID2 uuid.UUID) ([]*domain.Friendship, error) <span class="cov0" title="0">{
        query := `
                SELECT DISTINCT f1.id, f1.requester_id, f1.addressee_id, f1.status, f1.created_at, f1.updated_at, f1.accepted_at, f1.blocked_at
                FROM friendships f1
                JOIN friendships f2 ON (
                        (f1.requester_id = f2.requester_id OR f1.requester_id = f2.addressee_id OR 
                         f1.addressee_id = f2.requester_id OR f1.addressee_id = f2.addressee_id)
                        AND f1.id != f2.id
                )
                WHERE f1.status = ? AND f2.status = ?
                AND ((f1.requester_id = ? OR f1.addressee_id = ?) AND (f2.requester_id = ? OR f2.addressee_id = ?))
                AND f1.requester_id != ? AND f1.addressee_id != ? AND f2.requester_id != ? AND f2.addressee_id != ?
        `

        rows, err := r.db.QueryContext(ctx, query,
                domain.FriendshipStatusAccepted, domain.FriendshipStatusAccepted,
                userID1, userID1, userID2, userID2,
                userID1, userID1, userID2, userID2)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to get mutual friends",
                        logger.Any("userID1", userID1),
                        logger.Any("userID2", userID2),
                        logger.Error(err))
                return nil, fmt.Errorf("failed to get mutual friends: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var friendships []*domain.Friendship
        for rows.Next() </span><span class="cov0" title="0">{
                var friendship domain.Friendship
                var acceptedAt, blockedAt sql.NullTime

                err := rows.Scan(
                        &amp;friendship.ID,
                        &amp;friendship.RequesterID,
                        &amp;friendship.AddresseeID,
                        &amp;friendship.Status,
                        &amp;friendship.CreatedAt,
                        &amp;friendship.UpdatedAt,
                        &amp;acceptedAt,
                        &amp;blockedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to scan mutual friend", logger.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">if acceptedAt.Valid </span><span class="cov0" title="0">{
                        friendship.AcceptedAt = &amp;acceptedAt.Time
                }</span>
                <span class="cov0" title="0">if blockedAt.Valid </span><span class="cov0" title="0">{
                        friendship.BlockedAt = &amp;blockedAt.Time
                }</span>

                <span class="cov0" title="0">friendships = append(friendships, &amp;friendship)</span>
        }

        <span class="cov0" title="0">return friendships, nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package database

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "time"

        "github.com/google/uuid"
        commonDomain "github.com/hryt430/Yotei+/internal/common/domain"
        "github.com/hryt430/Yotei+/internal/modules/social/domain"
        "github.com/hryt430/Yotei+/internal/modules/social/usecase"
        "github.com/hryt430/Yotei+/pkg/logger"
)

type InvitationRepository struct {
        db     *sql.DB
        logger logger.Logger
}

func NewInvitationRepository(db *sql.DB, logger logger.Logger) usecase.InvitationRepository <span class="cov0" title="0">{
        return &amp;InvitationRepository{
                db:     db,
                logger: logger,
        }
}</span>

// CreateInvitation は招待を作成する
func (r *InvitationRepository) CreateInvitation(ctx context.Context, invitation *domain.Invitation) error <span class="cov0" title="0">{
        query := `
                INSERT INTO invitations (
                        id, type, method, status, inviter_id, invitee_id, invitee_email, invitee_username, invitee_phone,
                        target_id, code, url, message, metadata, expires_at, created_at, updated_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        var metadataJSON []byte
        var err error
        if invitation.Metadata != nil </span><span class="cov0" title="0">{
                metadataJSON, err = json.Marshal(invitation.Metadata)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to marshal metadata: %w", err)
                }</span>
        }

        <span class="cov0" title="0">var inviteeEmail, inviteeUsername, inviteePhone *string
        if invitation.InviteeInfo != nil </span><span class="cov0" title="0">{
                if invitation.InviteeInfo.Email != "" </span><span class="cov0" title="0">{
                        inviteeEmail = &amp;invitation.InviteeInfo.Email
                }</span>
                <span class="cov0" title="0">if invitation.InviteeInfo.Username != "" </span><span class="cov0" title="0">{
                        inviteeUsername = &amp;invitation.InviteeInfo.Username
                }</span>
                <span class="cov0" title="0">if invitation.InviteeInfo.Phone != "" </span><span class="cov0" title="0">{
                        inviteePhone = &amp;invitation.InviteeInfo.Phone
                }</span>
        }

        <span class="cov0" title="0">_, err = r.db.ExecContext(ctx, query,
                invitation.ID,
                invitation.Type,
                invitation.Method,
                invitation.Status,
                invitation.InviterID,
                invitation.InviteeID,
                inviteeEmail,
                inviteeUsername,
                inviteePhone,
                invitation.TargetID,
                invitation.Code,
                invitation.URL,
                invitation.Message,
                metadataJSON,
                invitation.ExpiresAt,
                invitation.CreatedAt,
                invitation.UpdatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to create invitation",
                        logger.Any("invitation", invitation),
                        logger.Error(err))
                return fmt.Errorf("failed to create invitation: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetInvitationByID はIDで招待を取得する
func (r *InvitationRepository) GetInvitationByID(ctx context.Context, id uuid.UUID) (*domain.Invitation, error) <span class="cov0" title="0">{
        query := `
                SELECT id, type, method, status, inviter_id, invitee_id, invitee_email, invitee_username, invitee_phone,
                           target_id, code, url, message, metadata, expires_at, created_at, updated_at, accepted_at
                FROM invitations
                WHERE id = ?
        `

        invitation, err := r.scanInvitation(r.db.QueryRowContext(ctx, query, id))
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">r.logger.Error("Failed to get invitation by ID",
                        logger.Any("id", id),
                        logger.Error(err))
                return nil, fmt.Errorf("failed to get invitation by ID: %w", err)</span>
        }

        <span class="cov0" title="0">return invitation, nil</span>
}

// GetInvitationByCode はコードで招待を取得する
func (r *InvitationRepository) GetInvitationByCode(ctx context.Context, code string) (*domain.Invitation, error) <span class="cov0" title="0">{
        query := `
                SELECT id, type, method, status, inviter_id, invitee_id, invitee_email, invitee_username, invitee_phone,
                           target_id, code, url, message, metadata, expires_at, created_at, updated_at, accepted_at
                FROM invitations
                WHERE code = ?
        `

        invitation, err := r.scanInvitation(r.db.QueryRowContext(ctx, query, code))
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">r.logger.Error("Failed to get invitation by code",
                        logger.Any("code", code),
                        logger.Error(err))
                return nil, fmt.Errorf("failed to get invitation by code: %w", err)</span>
        }

        <span class="cov0" title="0">return invitation, nil</span>
}

// UpdateInvitation は招待を更新する
func (r *InvitationRepository) UpdateInvitation(ctx context.Context, invitation *domain.Invitation) error <span class="cov0" title="0">{
        query := `
                UPDATE invitations 
                SET status = ?, invitee_id = ?, updated_at = ?, accepted_at = ?
                WHERE id = ?
        `

        _, err := r.db.ExecContext(ctx, query,
                invitation.Status,
                invitation.InviteeID,
                invitation.UpdatedAt,
                invitation.AcceptedAt,
                invitation.ID,
        )

        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to update invitation",
                        logger.Any("invitation", invitation),
                        logger.Error(err))
                return fmt.Errorf("failed to update invitation: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteInvitation は招待を削除する
func (r *InvitationRepository) DeleteInvitation(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        query := `DELETE FROM invitations WHERE id = ?`

        _, err := r.db.ExecContext(ctx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to delete invitation",
                        logger.Any("id", id),
                        logger.Error(err))
                return fmt.Errorf("failed to delete invitation: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetSentInvitations は送信した招待一覧を取得する
func (r *InvitationRepository) GetSentInvitations(ctx context.Context, inviterID uuid.UUID, pagination commonDomain.Pagination) ([]*domain.Invitation, error) <span class="cov0" title="0">{
        offset := (pagination.Page - 1) * pagination.PageSize

        query := `
                SELECT id, type, method, status, inviter_id, invitee_id, invitee_email, invitee_username, invitee_phone,
                           target_id, code, url, message, metadata, expires_at, created_at, updated_at, accepted_at
                FROM invitations
                WHERE inviter_id = ?
                ORDER BY created_at DESC
                LIMIT ? OFFSET ?
        `

        rows, err := r.db.QueryContext(ctx, query, inviterID, pagination.PageSize, offset)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to get sent invitations",
                        logger.Any("inviterID", inviterID),
                        logger.Error(err))
                return nil, fmt.Errorf("failed to get sent invitations: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var invitations []*domain.Invitation
        for rows.Next() </span><span class="cov0" title="0">{
                invitation, err := r.scanInvitationFromRows(rows)
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to scan invitation", logger.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">invitations = append(invitations, invitation)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Error iterating invitation rows", logger.Error(err))
                return nil, fmt.Errorf("error iterating invitation rows: %w", err)
        }</span>

        <span class="cov0" title="0">return invitations, nil</span>
}

// GetReceivedInvitations は受信した招待一覧を取得する
func (r *InvitationRepository) GetReceivedInvitations(ctx context.Context, inviteeID uuid.UUID, pagination commonDomain.Pagination) ([]*domain.Invitation, error) <span class="cov0" title="0">{
        offset := (pagination.Page - 1) * pagination.PageSize

        query := `
                SELECT id, type, method, status, inviter_id, invitee_id, invitee_email, invitee_username, invitee_phone,
                           target_id, code, url, message, metadata, expires_at, created_at, updated_at, accepted_at
                FROM invitations
                WHERE invitee_id = ?
                ORDER BY created_at DESC
                LIMIT ? OFFSET ?
        `

        rows, err := r.db.QueryContext(ctx, query, inviteeID, pagination.PageSize, offset)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to get received invitations",
                        logger.Any("inviteeID", inviteeID),
                        logger.Error(err))
                return nil, fmt.Errorf("failed to get received invitations: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var invitations []*domain.Invitation
        for rows.Next() </span><span class="cov0" title="0">{
                invitation, err := r.scanInvitationFromRows(rows)
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to scan invitation", logger.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">invitations = append(invitations, invitation)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Error iterating invitation rows", logger.Error(err))
                return nil, fmt.Errorf("error iterating invitation rows: %w", err)
        }</span>

        <span class="cov0" title="0">return invitations, nil</span>
}

// MarkExpiredInvitations は期限切れ招待をマークする
func (r *InvitationRepository) MarkExpiredInvitations(ctx context.Context) error <span class="cov0" title="0">{
        query := `
                UPDATE invitations 
                SET status = ? 
                WHERE status = ? AND expires_at &lt; NOW()
        `

        _, err := r.db.ExecContext(ctx, query, domain.InvitationStatusExpired, domain.InvitationStatusPending)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to mark expired invitations", logger.Error(err))
                return fmt.Errorf("failed to mark expired invitations: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteExpiredInvitations は期限切れ招待を削除する
func (r *InvitationRepository) DeleteExpiredInvitations(ctx context.Context, beforeDate time.Time) error <span class="cov0" title="0">{
        query := `
                DELETE FROM invitations 
                WHERE status = ? AND expires_at &lt; ?
        `

        _, err := r.db.ExecContext(ctx, query, domain.InvitationStatusExpired, beforeDate)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to delete expired invitations", logger.Error(err))
                return fmt.Errorf("failed to delete expired invitations: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// IsValidInvitation は招待コードの妥当性を確認する
func (r *InvitationRepository) IsValidInvitation(ctx context.Context, code string) (bool, error) <span class="cov0" title="0">{
        query := `
                SELECT COUNT(*) FROM invitations
                WHERE code = ? AND status = ? AND expires_at &gt; NOW()
        `

        var count int
        err := r.db.QueryRowContext(ctx, query, code, domain.InvitationStatusPending).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to validate invitation code",
                        logger.Any("code", code),
                        logger.Error(err))
                return false, fmt.Errorf("failed to validate invitation code: %w", err)
        }</span>

        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

// scanInvitation はsql.Rowから招待をスキャンする
func (r *InvitationRepository) scanInvitation(row *sql.Row) (*domain.Invitation, error) <span class="cov0" title="0">{
        var invitation domain.Invitation
        var inviteeEmail, inviteeUsername, inviteePhone sql.NullString
        var metadataJSON sql.NullString
        var acceptedAt sql.NullTime

        err := row.Scan(
                &amp;invitation.ID,
                &amp;invitation.Type,
                &amp;invitation.Method,
                &amp;invitation.Status,
                &amp;invitation.InviterID,
                &amp;invitation.InviteeID,
                &amp;inviteeEmail,
                &amp;inviteeUsername,
                &amp;inviteePhone,
                &amp;invitation.TargetID,
                &amp;invitation.Code,
                &amp;invitation.URL,
                &amp;invitation.Message,
                &amp;metadataJSON,
                &amp;invitation.ExpiresAt,
                &amp;invitation.CreatedAt,
                &amp;invitation.UpdatedAt,
                &amp;acceptedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // InviteeInfoの構築
        <span class="cov0" title="0">if inviteeEmail.Valid || inviteeUsername.Valid || inviteePhone.Valid </span><span class="cov0" title="0">{
                invitation.InviteeInfo = &amp;domain.InviteeInfo{
                        Email:    inviteeEmail.String,
                        Username: inviteeUsername.String,
                        Phone:    inviteePhone.String,
                }
        }</span>

        // Metadataの解析
        <span class="cov0" title="0">if metadataJSON.Valid </span><span class="cov0" title="0">{
                err = json.Unmarshal([]byte(metadataJSON.String), &amp;invitation.Metadata)
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Warn("Failed to unmarshal metadata", logger.Error(err))
                }</span>
        }

        // AcceptedAtの設定
        <span class="cov0" title="0">if acceptedAt.Valid </span><span class="cov0" title="0">{
                invitation.AcceptedAt = &amp;acceptedAt.Time
        }</span>

        <span class="cov0" title="0">return &amp;invitation, nil</span>
}

// scanInvitationFromRows はsql.Rowsから招待をスキャンする
func (r *InvitationRepository) scanInvitationFromRows(rows *sql.Rows) (*domain.Invitation, error) <span class="cov0" title="0">{
        var invitation domain.Invitation
        var inviteeEmail, inviteeUsername, inviteePhone sql.NullString
        var metadataJSON sql.NullString
        var acceptedAt sql.NullTime

        err := rows.Scan(
                &amp;invitation.ID,
                &amp;invitation.Type,
                &amp;invitation.Method,
                &amp;invitation.Status,
                &amp;invitation.InviterID,
                &amp;invitation.InviteeID,
                &amp;inviteeEmail,
                &amp;inviteeUsername,
                &amp;inviteePhone,
                &amp;invitation.TargetID,
                &amp;invitation.Code,
                &amp;invitation.URL,
                &amp;invitation.Message,
                &amp;metadataJSON,
                &amp;invitation.ExpiresAt,
                &amp;invitation.CreatedAt,
                &amp;invitation.UpdatedAt,
                &amp;acceptedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // InviteeInfoの構築
        <span class="cov0" title="0">if inviteeEmail.Valid || inviteeUsername.Valid || inviteePhone.Valid </span><span class="cov0" title="0">{
                invitation.InviteeInfo = &amp;domain.InviteeInfo{
                        Email:    inviteeEmail.String,
                        Username: inviteeUsername.String,
                        Phone:    inviteePhone.String,
                }
        }</span>

        // Metadataの解析
        <span class="cov0" title="0">if metadataJSON.Valid </span><span class="cov0" title="0">{
                err = json.Unmarshal([]byte(metadataJSON.String), &amp;invitation.Metadata)
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Warn("Failed to unmarshal metadata", logger.Error(err))
                }</span>
        }

        // AcceptedAtの設定
        <span class="cov0" title="0">if acceptedAt.Valid </span><span class="cov0" title="0">{
                invitation.AcceptedAt = &amp;acceptedAt.Time
        }</span>

        <span class="cov0" title="0">return &amp;invitation, nil</span>
}</pre>
		
		<pre class="file" id="file47" style="display: none">package dto

import (
        "time"

        "github.com/google/uuid"
        "github.com/hryt430/Yotei+/internal/modules/social/domain"
        socialUsecase "github.com/hryt430/Yotei+/internal/modules/social/usecase"
)

// === リクエストDTO ===

type SendFriendRequestRequest struct {
        AddresseeID string `json:"addressee_id" binding:"required"`
        Message     string `json:"message" binding:"max=500"`
}

type AcceptFriendRequestRequest struct {
        RequesterID string `json:"requester_id" binding:"required"`
}

type DeclineFriendRequestRequest struct {
        RequesterID string `json:"requester_id" binding:"required"`
}

type BlockUserRequest struct {
        TargetID string `json:"target_id" binding:"required"`
}

type UnblockUserRequest struct {
        TargetID string `json:"target_id" binding:"required"`
}

type CreateInvitationRequest struct {
        Type         string  `json:"type" binding:"required,oneof=FRIEND GROUP"`
        Method       string  `json:"method" binding:"required,oneof=IN_APP CODE URL"`
        Message      string  `json:"message" binding:"max=500"`
        ExpiresHours int     `json:"expires_hours" binding:"min=1,max=168"` // 1-168時間（1週間）
        InviteeEmail *string `json:"invitee_email,omitempty" binding:"omitempty,email"`
        TargetID     *string `json:"target_id,omitempty"` // Group IDなど
}

type AcceptInvitationRequest struct {
        Code string `json:"code" binding:"required"`
}

type DeclineInvitationRequest struct {
        InvitationID string `json:"invitation_id" binding:"required"`
}

// === レスポンスDTO ===

type FriendshipResponse struct {
        ID          uuid.UUID  `json:"id"`
        RequesterID uuid.UUID  `json:"requester_id"`
        AddresseeID uuid.UUID  `json:"addressee_id"`
        Status      string     `json:"status"`
        CreatedAt   time.Time  `json:"created_at"`
        UpdatedAt   time.Time  `json:"updated_at"`
        AcceptedAt  *time.Time `json:"accepted_at,omitempty"`
        BlockedAt   *time.Time `json:"blocked_at,omitempty"`
}

type FriendWithUserInfoResponse struct {
        Friendship FriendshipResponse `json:"friendship"`
        UserInfo   *UserInfo          `json:"user_info,omitempty"`
}

type FriendshipWithUserInfoResponse struct {
        Friendship FriendshipResponse `json:"friendship"`
        UserInfo   *UserInfo          `json:"user_info,omitempty"`
}

type InvitationResponse struct {
        ID          uuid.UUID           `json:"id"`
        Type        string              `json:"type"`
        Method      string              `json:"method"`
        Status      string              `json:"status"`
        InviterID   uuid.UUID           `json:"inviter_id"`
        InviteeID   *uuid.UUID          `json:"invitee_id,omitempty"`
        InviteeInfo *domain.InviteeInfo `json:"invitee_info,omitempty"`
        TargetID    *uuid.UUID          `json:"target_id,omitempty"`
        Code        string              `json:"code,omitempty"`
        URL         string              `json:"url,omitempty"`
        Message     string              `json:"message"`
        Metadata    map[string]string   `json:"metadata,omitempty"`
        ExpiresAt   time.Time           `json:"expires_at"`
        CreatedAt   time.Time           `json:"created_at"`
        UpdatedAt   time.Time           `json:"updated_at"`
        AcceptedAt  *time.Time          `json:"accepted_at,omitempty"`
}

type InvitationResultResponse struct {
        Success    bool                `json:"success"`
        Message    string              `json:"message"`
        Friendship *FriendshipResponse `json:"friendship,omitempty"`
        GroupID    *uuid.UUID          `json:"group_id,omitempty"`
}

type UserRelationshipResponse struct {
        IsFriend        bool `json:"is_friend"`
        IsBlocked       bool `json:"is_blocked"`
        RequestSent     bool `json:"request_sent"`
        RequestReceived bool `json:"request_received"`
}

type FriendsListResponse struct {
        Friends    []FriendWithUserInfoResponse `json:"friends"`
        Pagination PaginationInfo               `json:"pagination"`
}

type PendingRequestsResponse struct {
        Requests   []FriendshipWithUserInfoResponse `json:"requests"`
        Pagination PaginationInfo                   `json:"pagination"`
}

type SentRequestsResponse struct {
        Requests   []FriendshipWithUserInfoResponse `json:"requests"`
        Pagination PaginationInfo                   `json:"pagination"`
}

type InvitationsListResponse struct {
        Invitations []InvitationResponse `json:"invitations"`
        Pagination  PaginationInfo       `json:"pagination"`
}

type InviteURLResponse struct {
        URL       string    `json:"url"`
        Code      string    `json:"code"`
        ExpiresAt time.Time `json:"expires_at"`
}

type PaginationInfo struct {
        Page       int `json:"page"`
        PageSize   int `json:"page_size"`
        Total      int `json:"total"`
        TotalPages int `json:"total_pages"`
}

// UserInfo はユーザー基本情報
type UserInfo struct {
        ID       string `json:"id" example:"123e4567-e89b-12d3-a456-426614174000"`
        Username string `json:"username" example:"user123"`
        Email    string `json:"email" example:"user@example.com"`
} // @name UserInfo

// === 共通レスポンス ===

type SuccessResponse struct {
        Success bool   `json:"success"`
        Message string `json:"message"`
}

type ErrorResponse struct {
        Error   string `json:"error"`
        Message string `json:"message"`
}

// === 変換関数 ===

func ToFriendshipResponse(friendship *domain.Friendship) *FriendshipResponse <span class="cov0" title="0">{
        return &amp;FriendshipResponse{
                ID:          friendship.ID,
                RequesterID: friendship.RequesterID,
                AddresseeID: friendship.AddresseeID,
                Status:      string(friendship.Status),
                CreatedAt:   friendship.CreatedAt,
                UpdatedAt:   friendship.UpdatedAt,
                AcceptedAt:  friendship.AcceptedAt,
                BlockedAt:   friendship.BlockedAt,
        }
}</span>

func ToFriendWithUserInfoResponse(friend *socialUsecase.FriendWithUserInfo) *FriendWithUserInfoResponse <span class="cov0" title="0">{
        var userInfo *UserInfo
        if friend.UserInfo != nil </span><span class="cov0" title="0">{
                userInfo = &amp;UserInfo{
                        ID:       friend.UserInfo.ID,
                        Username: friend.UserInfo.Username,
                        Email:    friend.UserInfo.Email,
                }
        }</span>
        <span class="cov0" title="0">return &amp;FriendWithUserInfoResponse{
                Friendship: *ToFriendshipResponse(friend.Friendship),
                UserInfo:   userInfo,
        }</span>
}

func ToFriendshipWithUserInfoResponse(friendship *socialUsecase.FriendshipWithUserInfo) *FriendshipWithUserInfoResponse <span class="cov0" title="0">{
        var userInfo *UserInfo
        if friendship.UserInfo != nil </span><span class="cov0" title="0">{
                userInfo = &amp;UserInfo{
                        ID:       friendship.UserInfo.ID,
                        Username: friendship.UserInfo.Username,
                        Email:    friendship.UserInfo.Email,
                }
        }</span>
        <span class="cov0" title="0">return &amp;FriendshipWithUserInfoResponse{
                Friendship: *ToFriendshipResponse(friendship.Friendship),
                UserInfo:   userInfo,
        }</span>
}

func ToInvitationResponse(invitation *domain.Invitation) *InvitationResponse <span class="cov0" title="0">{
        return &amp;InvitationResponse{
                ID:          invitation.ID,
                Type:        string(invitation.Type),
                Method:      string(invitation.Method),
                Status:      string(invitation.Status),
                InviterID:   invitation.InviterID,
                InviteeID:   invitation.InviteeID,
                InviteeInfo: invitation.InviteeInfo,
                TargetID:    invitation.TargetID,
                Code:        invitation.Code,
                URL:         invitation.URL,
                Message:     invitation.Message,
                Metadata:    invitation.Metadata,
                ExpiresAt:   invitation.ExpiresAt,
                CreatedAt:   invitation.CreatedAt,
                UpdatedAt:   invitation.UpdatedAt,
                AcceptedAt:  invitation.AcceptedAt,
        }
}</span>

func ToInvitationResultResponse(result *socialUsecase.InvitationResult) *InvitationResultResponse <span class="cov0" title="0">{
        response := &amp;InvitationResultResponse{
                Success: result.Success,
                Message: result.Message,
        }

        if result.Friendship != nil </span><span class="cov0" title="0">{
                response.Friendship = ToFriendshipResponse(result.Friendship)
        }</span>

        <span class="cov0" title="0">if result.GroupID != nil </span><span class="cov0" title="0">{
                response.GroupID = result.GroupID
        }</span>

        <span class="cov0" title="0">return response</span>
}

func ToUserRelationshipResponse(relationship *socialUsecase.UserRelationship) *UserRelationshipResponse <span class="cov0" title="0">{
        return &amp;UserRelationshipResponse{
                IsFriend:        relationship.IsFriend,
                IsBlocked:       relationship.IsBlocked,
                RequestSent:     relationship.RequestSent,
                RequestReceived: relationship.RequestReceived,
        }
}</span>

func ToFriendsListResponse(friends []*socialUsecase.FriendWithUserInfo, total, page, pageSize int) *FriendsListResponse <span class="cov0" title="0">{
        friendResponses := make([]FriendWithUserInfoResponse, len(friends))
        for i, friend := range friends </span><span class="cov0" title="0">{
                friendResponses[i] = *ToFriendWithUserInfoResponse(friend)
        }</span>

        <span class="cov0" title="0">totalPages := total / pageSize
        if total%pageSize &gt; 0 </span><span class="cov0" title="0">{
                totalPages++
        }</span>

        <span class="cov0" title="0">return &amp;FriendsListResponse{
                Friends: friendResponses,
                Pagination: PaginationInfo{
                        Page:       page,
                        PageSize:   pageSize,
                        Total:      total,
                        TotalPages: totalPages,
                },
        }</span>
}

func ToPendingRequestsResponse(requests []*socialUsecase.FriendshipWithUserInfo, total, page, pageSize int) *PendingRequestsResponse <span class="cov0" title="0">{
        requestResponses := make([]FriendshipWithUserInfoResponse, len(requests))
        for i, request := range requests </span><span class="cov0" title="0">{
                requestResponses[i] = *ToFriendshipWithUserInfoResponse(request)
        }</span>

        <span class="cov0" title="0">totalPages := total / pageSize
        if total%pageSize &gt; 0 </span><span class="cov0" title="0">{
                totalPages++
        }</span>

        <span class="cov0" title="0">return &amp;PendingRequestsResponse{
                Requests: requestResponses,
                Pagination: PaginationInfo{
                        Page:       page,
                        PageSize:   pageSize,
                        Total:      total,
                        TotalPages: totalPages,
                },
        }</span>
}

func ToInvitationsListResponse(invitations []*domain.Invitation, total, page, pageSize int) *InvitationsListResponse <span class="cov0" title="0">{
        invitationResponses := make([]InvitationResponse, len(invitations))
        for i, invitation := range invitations </span><span class="cov0" title="0">{
                invitationResponses[i] = *ToInvitationResponse(invitation)
        }</span>

        <span class="cov0" title="0">totalPages := total / pageSize
        if total%pageSize &gt; 0 </span><span class="cov0" title="0">{
                totalPages++
        }</span>

        <span class="cov0" title="0">return &amp;InvitationsListResponse{
                Invitations: invitationResponses,
                Pagination: PaginationInfo{
                        Page:       page,
                        PageSize:   pageSize,
                        Total:      total,
                        TotalPages: totalPages,
                },
        }</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/hryt430/Yotei+/internal/common/domain (interfaces: UserValidator)

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        domain "github.com/hryt430/Yotei+/internal/common/domain"
)

// MockUserValidator is a mock of UserValidator interface.
type MockUserValidator struct {
        ctrl     *gomock.Controller
        recorder *MockUserValidatorMockRecorder
}

// MockUserValidatorMockRecorder is the mock recorder for MockUserValidator.
type MockUserValidatorMockRecorder struct {
        mock *MockUserValidator
}

// NewMockUserValidator creates a new mock instance.
func NewMockUserValidator(ctrl *gomock.Controller) *MockUserValidator <span class="cov0" title="0">{
        mock := &amp;MockUserValidator{ctrl: ctrl}
        mock.recorder = &amp;MockUserValidatorMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserValidator) EXPECT() *MockUserValidatorMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetUserInfo mocks base method.
func (m *MockUserValidator) GetUserInfo(arg0 context.Context, arg1 string) (*domain.UserInfo, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUserInfo", arg0, arg1)
        ret0, _ := ret[0].(*domain.UserInfo)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUserInfo indicates an expected call of GetUserInfo.
func (mr *MockUserValidatorMockRecorder) GetUserInfo(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserInfo", reflect.TypeOf((*MockUserValidator)(nil).GetUserInfo), arg0, arg1)
}</span>

// GetUsersInfoBatch mocks base method.
func (m *MockUserValidator) GetUsersInfoBatch(arg0 context.Context, arg1 []string) (map[string]*domain.UserInfo, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUsersInfoBatch", arg0, arg1)
        ret0, _ := ret[0].(map[string]*domain.UserInfo)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUsersInfoBatch indicates an expected call of GetUsersInfoBatch.
func (mr *MockUserValidatorMockRecorder) GetUsersInfoBatch(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUsersInfoBatch", reflect.TypeOf((*MockUserValidator)(nil).GetUsersInfoBatch), arg0, arg1)
}</span>

// UserExists mocks base method.
func (m *MockUserValidator) UserExists(arg0 context.Context, arg1 string) (bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UserExists", arg0, arg1)
        ret0, _ := ret[0].(bool)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UserExists indicates an expected call of UserExists.
func (mr *MockUserValidatorMockRecorder) UserExists(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UserExists", reflect.TypeOf((*MockUserValidator)(nil).UserExists), arg0, arg1)
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/hryt430/Yotei+/internal/modules/social/usecase (interfaces: FriendshipRepository,InvitationRepository)

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"
        time "time"

        gomock "github.com/golang/mock/gomock"
        uuid "github.com/google/uuid"
        domain "github.com/hryt430/Yotei+/internal/common/domain"
        domain0 "github.com/hryt430/Yotei+/internal/modules/social/domain"
)

// MockFriendshipRepository is a mock of FriendshipRepository interface.
type MockFriendshipRepository struct {
        ctrl     *gomock.Controller
        recorder *MockFriendshipRepositoryMockRecorder
}

// MockFriendshipRepositoryMockRecorder is the mock recorder for MockFriendshipRepository.
type MockFriendshipRepositoryMockRecorder struct {
        mock *MockFriendshipRepository
}

// NewMockFriendshipRepository creates a new mock instance.
func NewMockFriendshipRepository(ctrl *gomock.Controller) *MockFriendshipRepository <span class="cov0" title="0">{
        mock := &amp;MockFriendshipRepository{ctrl: ctrl}
        mock.recorder = &amp;MockFriendshipRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockFriendshipRepository) EXPECT() *MockFriendshipRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// AreFriends mocks base method.
func (m *MockFriendshipRepository) AreFriends(arg0 context.Context, arg1, arg2 uuid.UUID) (bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AreFriends", arg0, arg1, arg2)
        ret0, _ := ret[0].(bool)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// AreFriends indicates an expected call of AreFriends.
func (mr *MockFriendshipRepositoryMockRecorder) AreFriends(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AreFriends", reflect.TypeOf((*MockFriendshipRepository)(nil).AreFriends), arg0, arg1, arg2)
}</span>

// CreateFriendship mocks base method.
func (m *MockFriendshipRepository) CreateFriendship(arg0 context.Context, arg1 *domain0.Friendship) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateFriendship", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CreateFriendship indicates an expected call of CreateFriendship.
func (mr *MockFriendshipRepositoryMockRecorder) CreateFriendship(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateFriendship", reflect.TypeOf((*MockFriendshipRepository)(nil).CreateFriendship), arg0, arg1)
}</span>

// DeleteFriendship mocks base method.
func (m *MockFriendshipRepository) DeleteFriendship(arg0 context.Context, arg1, arg2 uuid.UUID) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteFriendship", arg0, arg1, arg2)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteFriendship indicates an expected call of DeleteFriendship.
func (mr *MockFriendshipRepositoryMockRecorder) DeleteFriendship(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteFriendship", reflect.TypeOf((*MockFriendshipRepository)(nil).DeleteFriendship), arg0, arg1, arg2)
}</span>

// GetFriendCount mocks base method.
func (m *MockFriendshipRepository) GetFriendCount(arg0 context.Context, arg1 uuid.UUID) (int, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetFriendCount", arg0, arg1)
        ret0, _ := ret[0].(int)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetFriendCount indicates an expected call of GetFriendCount.
func (mr *MockFriendshipRepositoryMockRecorder) GetFriendCount(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetFriendCount", reflect.TypeOf((*MockFriendshipRepository)(nil).GetFriendCount), arg0, arg1)
}</span>

// GetFriends mocks base method.
func (m *MockFriendshipRepository) GetFriends(arg0 context.Context, arg1 uuid.UUID, arg2 domain.Pagination) ([]*domain0.Friendship, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetFriends", arg0, arg1, arg2)
        ret0, _ := ret[0].([]*domain0.Friendship)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetFriends indicates an expected call of GetFriends.
func (mr *MockFriendshipRepositoryMockRecorder) GetFriends(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetFriends", reflect.TypeOf((*MockFriendshipRepository)(nil).GetFriends), arg0, arg1, arg2)
}</span>

// GetFriendship mocks base method.
func (m *MockFriendshipRepository) GetFriendship(arg0 context.Context, arg1, arg2 uuid.UUID) (*domain0.Friendship, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetFriendship", arg0, arg1, arg2)
        ret0, _ := ret[0].(*domain0.Friendship)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetFriendship indicates an expected call of GetFriendship.
func (mr *MockFriendshipRepositoryMockRecorder) GetFriendship(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetFriendship", reflect.TypeOf((*MockFriendshipRepository)(nil).GetFriendship), arg0, arg1, arg2)
}</span>

// GetMutualFriends mocks base method.
func (m *MockFriendshipRepository) GetMutualFriends(arg0 context.Context, arg1, arg2 uuid.UUID) ([]*domain0.Friendship, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetMutualFriends", arg0, arg1, arg2)
        ret0, _ := ret[0].([]*domain0.Friendship)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetMutualFriends indicates an expected call of GetMutualFriends.
func (mr *MockFriendshipRepositoryMockRecorder) GetMutualFriends(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMutualFriends", reflect.TypeOf((*MockFriendshipRepository)(nil).GetMutualFriends), arg0, arg1, arg2)
}</span>

// GetPendingRequests mocks base method.
func (m *MockFriendshipRepository) GetPendingRequests(arg0 context.Context, arg1 uuid.UUID, arg2 domain.Pagination) ([]*domain0.Friendship, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetPendingRequests", arg0, arg1, arg2)
        ret0, _ := ret[0].([]*domain0.Friendship)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetPendingRequests indicates an expected call of GetPendingRequests.
func (mr *MockFriendshipRepositoryMockRecorder) GetPendingRequests(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPendingRequests", reflect.TypeOf((*MockFriendshipRepository)(nil).GetPendingRequests), arg0, arg1, arg2)
}</span>

// GetSentRequests mocks base method.
func (m *MockFriendshipRepository) GetSentRequests(arg0 context.Context, arg1 uuid.UUID, arg2 domain.Pagination) ([]*domain0.Friendship, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetSentRequests", arg0, arg1, arg2)
        ret0, _ := ret[0].([]*domain0.Friendship)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetSentRequests indicates an expected call of GetSentRequests.
func (mr *MockFriendshipRepositoryMockRecorder) GetSentRequests(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSentRequests", reflect.TypeOf((*MockFriendshipRepository)(nil).GetSentRequests), arg0, arg1, arg2)
}</span>

// IsBlocked mocks base method.
func (m *MockFriendshipRepository) IsBlocked(arg0 context.Context, arg1, arg2 uuid.UUID) (bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "IsBlocked", arg0, arg1, arg2)
        ret0, _ := ret[0].(bool)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// IsBlocked indicates an expected call of IsBlocked.
func (mr *MockFriendshipRepositoryMockRecorder) IsBlocked(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsBlocked", reflect.TypeOf((*MockFriendshipRepository)(nil).IsBlocked), arg0, arg1, arg2)
}</span>

// UpdateFriendship mocks base method.
func (m *MockFriendshipRepository) UpdateFriendship(arg0 context.Context, arg1 *domain0.Friendship) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateFriendship", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateFriendship indicates an expected call of UpdateFriendship.
func (mr *MockFriendshipRepositoryMockRecorder) UpdateFriendship(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateFriendship", reflect.TypeOf((*MockFriendshipRepository)(nil).UpdateFriendship), arg0, arg1)
}</span>

// MockInvitationRepository is a mock of InvitationRepository interface.
type MockInvitationRepository struct {
        ctrl     *gomock.Controller
        recorder *MockInvitationRepositoryMockRecorder
}

// MockInvitationRepositoryMockRecorder is the mock recorder for MockInvitationRepository.
type MockInvitationRepositoryMockRecorder struct {
        mock *MockInvitationRepository
}

// NewMockInvitationRepository creates a new mock instance.
func NewMockInvitationRepository(ctrl *gomock.Controller) *MockInvitationRepository <span class="cov0" title="0">{
        mock := &amp;MockInvitationRepository{ctrl: ctrl}
        mock.recorder = &amp;MockInvitationRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockInvitationRepository) EXPECT() *MockInvitationRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateInvitation mocks base method.
func (m *MockInvitationRepository) CreateInvitation(arg0 context.Context, arg1 *domain0.Invitation) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateInvitation", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CreateInvitation indicates an expected call of CreateInvitation.
func (mr *MockInvitationRepositoryMockRecorder) CreateInvitation(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateInvitation", reflect.TypeOf((*MockInvitationRepository)(nil).CreateInvitation), arg0, arg1)
}</span>

// DeleteExpiredInvitations mocks base method.
func (m *MockInvitationRepository) DeleteExpiredInvitations(arg0 context.Context, arg1 time.Time) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteExpiredInvitations", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteExpiredInvitations indicates an expected call of DeleteExpiredInvitations.
func (mr *MockInvitationRepositoryMockRecorder) DeleteExpiredInvitations(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteExpiredInvitations", reflect.TypeOf((*MockInvitationRepository)(nil).DeleteExpiredInvitations), arg0, arg1)
}</span>

// DeleteInvitation mocks base method.
func (m *MockInvitationRepository) DeleteInvitation(arg0 context.Context, arg1 uuid.UUID) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteInvitation", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteInvitation indicates an expected call of DeleteInvitation.
func (mr *MockInvitationRepositoryMockRecorder) DeleteInvitation(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteInvitation", reflect.TypeOf((*MockInvitationRepository)(nil).DeleteInvitation), arg0, arg1)
}</span>

// GetInvitationByCode mocks base method.
func (m *MockInvitationRepository) GetInvitationByCode(arg0 context.Context, arg1 string) (*domain0.Invitation, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetInvitationByCode", arg0, arg1)
        ret0, _ := ret[0].(*domain0.Invitation)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetInvitationByCode indicates an expected call of GetInvitationByCode.
func (mr *MockInvitationRepositoryMockRecorder) GetInvitationByCode(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetInvitationByCode", reflect.TypeOf((*MockInvitationRepository)(nil).GetInvitationByCode), arg0, arg1)
}</span>

// GetInvitationByID mocks base method.
func (m *MockInvitationRepository) GetInvitationByID(arg0 context.Context, arg1 uuid.UUID) (*domain0.Invitation, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetInvitationByID", arg0, arg1)
        ret0, _ := ret[0].(*domain0.Invitation)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetInvitationByID indicates an expected call of GetInvitationByID.
func (mr *MockInvitationRepositoryMockRecorder) GetInvitationByID(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetInvitationByID", reflect.TypeOf((*MockInvitationRepository)(nil).GetInvitationByID), arg0, arg1)
}</span>

// GetReceivedInvitations mocks base method.
func (m *MockInvitationRepository) GetReceivedInvitations(arg0 context.Context, arg1 uuid.UUID, arg2 domain.Pagination) ([]*domain0.Invitation, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetReceivedInvitations", arg0, arg1, arg2)
        ret0, _ := ret[0].([]*domain0.Invitation)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetReceivedInvitations indicates an expected call of GetReceivedInvitations.
func (mr *MockInvitationRepositoryMockRecorder) GetReceivedInvitations(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetReceivedInvitations", reflect.TypeOf((*MockInvitationRepository)(nil).GetReceivedInvitations), arg0, arg1, arg2)
}</span>

// GetSentInvitations mocks base method.
func (m *MockInvitationRepository) GetSentInvitations(arg0 context.Context, arg1 uuid.UUID, arg2 domain.Pagination) ([]*domain0.Invitation, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetSentInvitations", arg0, arg1, arg2)
        ret0, _ := ret[0].([]*domain0.Invitation)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetSentInvitations indicates an expected call of GetSentInvitations.
func (mr *MockInvitationRepositoryMockRecorder) GetSentInvitations(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSentInvitations", reflect.TypeOf((*MockInvitationRepository)(nil).GetSentInvitations), arg0, arg1, arg2)
}</span>

// IsValidInvitation mocks base method.
func (m *MockInvitationRepository) IsValidInvitation(arg0 context.Context, arg1 string) (bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "IsValidInvitation", arg0, arg1)
        ret0, _ := ret[0].(bool)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// IsValidInvitation indicates an expected call of IsValidInvitation.
func (mr *MockInvitationRepositoryMockRecorder) IsValidInvitation(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsValidInvitation", reflect.TypeOf((*MockInvitationRepository)(nil).IsValidInvitation), arg0, arg1)
}</span>

// MarkExpiredInvitations mocks base method.
func (m *MockInvitationRepository) MarkExpiredInvitations(arg0 context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "MarkExpiredInvitations", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// MarkExpiredInvitations indicates an expected call of MarkExpiredInvitations.
func (mr *MockInvitationRepositoryMockRecorder) MarkExpiredInvitations(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MarkExpiredInvitations", reflect.TypeOf((*MockInvitationRepository)(nil).MarkExpiredInvitations), arg0)
}</span>

// UpdateInvitation mocks base method.
func (m *MockInvitationRepository) UpdateInvitation(arg0 context.Context, arg1 *domain0.Invitation) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateInvitation", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateInvitation indicates an expected call of UpdateInvitation.
func (mr *MockInvitationRepositoryMockRecorder) UpdateInvitation(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateInvitation", reflect.TypeOf((*MockInvitationRepository)(nil).UpdateInvitation), arg0, arg1)
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/hryt430/Yotei+/internal/modules/social/usecase (interfaces: SocialEventPublisher,URLGateway)

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        uuid "github.com/google/uuid"
        domain "github.com/hryt430/Yotei+/internal/modules/social/domain"
)

// MockSocialEventPublisher is a mock of SocialEventPublisher interface.
type MockSocialEventPublisher struct {
        ctrl     *gomock.Controller
        recorder *MockSocialEventPublisherMockRecorder
}

// MockSocialEventPublisherMockRecorder is the mock recorder for MockSocialEventPublisher.
type MockSocialEventPublisherMockRecorder struct {
        mock *MockSocialEventPublisher
}

// NewMockSocialEventPublisher creates a new mock instance.
func NewMockSocialEventPublisher(ctrl *gomock.Controller) *MockSocialEventPublisher <span class="cov0" title="0">{
        mock := &amp;MockSocialEventPublisher{ctrl: ctrl}
        mock.recorder = &amp;MockSocialEventPublisherMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSocialEventPublisher) EXPECT() *MockSocialEventPublisherMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// PublishFriendRemoved mocks base method.
func (m *MockSocialEventPublisher) PublishFriendRemoved(arg0 context.Context, arg1, arg2 uuid.UUID) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "PublishFriendRemoved", arg0, arg1, arg2)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// PublishFriendRemoved indicates an expected call of PublishFriendRemoved.
func (mr *MockSocialEventPublisherMockRecorder) PublishFriendRemoved(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PublishFriendRemoved", reflect.TypeOf((*MockSocialEventPublisher)(nil).PublishFriendRemoved), arg0, arg1, arg2)
}</span>

// PublishFriendRequestAccepted mocks base method.
func (m *MockSocialEventPublisher) PublishFriendRequestAccepted(arg0 context.Context, arg1 *domain.Friendship) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "PublishFriendRequestAccepted", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// PublishFriendRequestAccepted indicates an expected call of PublishFriendRequestAccepted.
func (mr *MockSocialEventPublisherMockRecorder) PublishFriendRequestAccepted(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PublishFriendRequestAccepted", reflect.TypeOf((*MockSocialEventPublisher)(nil).PublishFriendRequestAccepted), arg0, arg1)
}</span>

// PublishFriendRequestDeclined mocks base method.
func (m *MockSocialEventPublisher) PublishFriendRequestDeclined(arg0 context.Context, arg1 *domain.Friendship) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "PublishFriendRequestDeclined", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// PublishFriendRequestDeclined indicates an expected call of PublishFriendRequestDeclined.
func (mr *MockSocialEventPublisherMockRecorder) PublishFriendRequestDeclined(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PublishFriendRequestDeclined", reflect.TypeOf((*MockSocialEventPublisher)(nil).PublishFriendRequestDeclined), arg0, arg1)
}</span>

// PublishFriendRequestSent mocks base method.
func (m *MockSocialEventPublisher) PublishFriendRequestSent(arg0 context.Context, arg1 *domain.Friendship, arg2 string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "PublishFriendRequestSent", arg0, arg1, arg2)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// PublishFriendRequestSent indicates an expected call of PublishFriendRequestSent.
func (mr *MockSocialEventPublisherMockRecorder) PublishFriendRequestSent(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PublishFriendRequestSent", reflect.TypeOf((*MockSocialEventPublisher)(nil).PublishFriendRequestSent), arg0, arg1, arg2)
}</span>

// PublishInvitationAccepted mocks base method.
func (m *MockSocialEventPublisher) PublishInvitationAccepted(arg0 context.Context, arg1 *domain.Invitation) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "PublishInvitationAccepted", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// PublishInvitationAccepted indicates an expected call of PublishInvitationAccepted.
func (mr *MockSocialEventPublisherMockRecorder) PublishInvitationAccepted(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PublishInvitationAccepted", reflect.TypeOf((*MockSocialEventPublisher)(nil).PublishInvitationAccepted), arg0, arg1)
}</span>

// PublishInvitationCreated mocks base method.
func (m *MockSocialEventPublisher) PublishInvitationCreated(arg0 context.Context, arg1 *domain.Invitation) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "PublishInvitationCreated", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// PublishInvitationCreated indicates an expected call of PublishInvitationCreated.
func (mr *MockSocialEventPublisherMockRecorder) PublishInvitationCreated(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PublishInvitationCreated", reflect.TypeOf((*MockSocialEventPublisher)(nil).PublishInvitationCreated), arg0, arg1)
}</span>

// PublishInvitationDeclined mocks base method.
func (m *MockSocialEventPublisher) PublishInvitationDeclined(arg0 context.Context, arg1 *domain.Invitation) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "PublishInvitationDeclined", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// PublishInvitationDeclined indicates an expected call of PublishInvitationDeclined.
func (mr *MockSocialEventPublisherMockRecorder) PublishInvitationDeclined(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PublishInvitationDeclined", reflect.TypeOf((*MockSocialEventPublisher)(nil).PublishInvitationDeclined), arg0, arg1)
}</span>

// PublishUserBlocked mocks base method.
func (m *MockSocialEventPublisher) PublishUserBlocked(arg0 context.Context, arg1, arg2 uuid.UUID) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "PublishUserBlocked", arg0, arg1, arg2)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// PublishUserBlocked indicates an expected call of PublishUserBlocked.
func (mr *MockSocialEventPublisherMockRecorder) PublishUserBlocked(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PublishUserBlocked", reflect.TypeOf((*MockSocialEventPublisher)(nil).PublishUserBlocked), arg0, arg1, arg2)
}</span>

// MockURLGateway is a mock of URLGateway interface.
type MockURLGateway struct {
        ctrl     *gomock.Controller
        recorder *MockURLGatewayMockRecorder
}

// MockURLGatewayMockRecorder is the mock recorder for MockURLGateway.
type MockURLGatewayMockRecorder struct {
        mock *MockURLGateway
}

// NewMockURLGateway creates a new mock instance.
func NewMockURLGateway(ctrl *gomock.Controller) *MockURLGateway <span class="cov0" title="0">{
        mock := &amp;MockURLGateway{ctrl: ctrl}
        mock.recorder = &amp;MockURLGatewayMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockURLGateway) EXPECT() *MockURLGatewayMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GenerateInviteURL mocks base method.
func (m *MockURLGateway) GenerateInviteURL(arg0 context.Context, arg1 uuid.UUID, arg2 string) (string, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GenerateInviteURL", arg0, arg1, arg2)
        ret0, _ := ret[0].(string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GenerateInviteURL indicates an expected call of GenerateInviteURL.
func (mr *MockURLGatewayMockRecorder) GenerateInviteURL(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GenerateInviteURL", reflect.TypeOf((*MockURLGateway)(nil).GenerateInviteURL), arg0, arg1, arg2)
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/hryt430/Yotei+/internal/common/domain (interfaces: UserValidator)

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        domain "github.com/hryt430/Yotei+/internal/common/domain"
)

// MockUserValidator is a mock of UserValidator interface.
type MockUserValidator struct {
        ctrl     *gomock.Controller
        recorder *MockUserValidatorMockRecorder
}

// MockUserValidatorMockRecorder is the mock recorder for MockUserValidator.
type MockUserValidatorMockRecorder struct {
        mock *MockUserValidator
}

// NewMockUserValidator creates a new mock instance.
func NewMockUserValidator(ctrl *gomock.Controller) *MockUserValidator <span class="cov0" title="0">{
        mock := &amp;MockUserValidator{ctrl: ctrl}
        mock.recorder = &amp;MockUserValidatorMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserValidator) EXPECT() *MockUserValidatorMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetUserInfo mocks base method.
func (m *MockUserValidator) GetUserInfo(arg0 context.Context, arg1 string) (*domain.UserInfo, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUserInfo", arg0, arg1)
        ret0, _ := ret[0].(*domain.UserInfo)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUserInfo indicates an expected call of GetUserInfo.
func (mr *MockUserValidatorMockRecorder) GetUserInfo(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserInfo", reflect.TypeOf((*MockUserValidator)(nil).GetUserInfo), arg0, arg1)
}</span>

// GetUsersInfoBatch mocks base method.
func (m *MockUserValidator) GetUsersInfoBatch(arg0 context.Context, arg1 []string) (map[string]*domain.UserInfo, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUsersInfoBatch", arg0, arg1)
        ret0, _ := ret[0].(map[string]*domain.UserInfo)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUsersInfoBatch indicates an expected call of GetUsersInfoBatch.
func (mr *MockUserValidatorMockRecorder) GetUsersInfoBatch(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUsersInfoBatch", reflect.TypeOf((*MockUserValidator)(nil).GetUsersInfoBatch), arg0, arg1)
}</span>

// UserExists mocks base method.
func (m *MockUserValidator) UserExists(arg0 context.Context, arg1 string) (bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UserExists", arg0, arg1)
        ret0, _ := ret[0].(bool)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UserExists indicates an expected call of UserExists.
func (mr *MockUserValidatorMockRecorder) UserExists(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UserExists", reflect.TypeOf((*MockUserValidator)(nil).UserExists), arg0, arg1)
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">package usecase

import (
        "context"
        "errors"
        "fmt"

        "github.com/google/uuid"
        commonDomain "github.com/hryt430/Yotei+/internal/common/domain"
        "github.com/hryt430/Yotei+/internal/modules/social/domain"
        "github.com/hryt430/Yotei+/pkg/logger"
)

// SocialServiceImpl はSocialServiceの実装
type SocialServiceImpl struct {
        friendshipRepo FriendshipRepository
        invitationRepo InvitationRepository
        userValidator  commonDomain.UserValidator
        eventPublisher SocialEventPublisher
        urlGateway     URLGateway
        logger         *logger.Logger
}

// SocialEventPublisher はソーシャルイベント発行のインターフェース
type SocialEventPublisher interface {
        PublishFriendRequestSent(ctx context.Context, friendship *domain.Friendship, message string) error
        PublishFriendRequestAccepted(ctx context.Context, friendship *domain.Friendship) error
        PublishFriendRequestDeclined(ctx context.Context, friendship *domain.Friendship) error
        PublishFriendRemoved(ctx context.Context, userID, friendID uuid.UUID) error
        PublishUserBlocked(ctx context.Context, userID, targetID uuid.UUID) error
        PublishInvitationCreated(ctx context.Context, invitation *domain.Invitation) error
        PublishInvitationAccepted(ctx context.Context, invitation *domain.Invitation) error
        PublishInvitationDeclined(ctx context.Context, invitation *domain.Invitation) error
}

// URLGateway はURL生成のインターフェース
type URLGateway interface {
        GenerateInviteURL(ctx context.Context, invitationID uuid.UUID, code string) (string, error)
}

// NewSocialServiceImpl は新しいSocialServiceImplを作成する
func NewSocialServiceImpl(
        friendshipRepo FriendshipRepository,
        invitationRepo InvitationRepository,
        userValidator commonDomain.UserValidator,
        eventPublisher SocialEventPublisher,
        urlGateway URLGateway,
        logger *logger.Logger,
) SocialService <span class="cov8" title="1">{
        return &amp;SocialServiceImpl{
                friendshipRepo: friendshipRepo,
                invitationRepo: invitationRepo,
                userValidator:  userValidator,
                eventPublisher: eventPublisher,
                urlGateway:     urlGateway,
                logger:         logger,
        }
}</span>

// === 友達関係管理 ===

// SendFriendRequest は友達申請を送信する
func (s *SocialServiceImpl) SendFriendRequest(ctx context.Context, requesterID, addresseeID uuid.UUID, message string) (*domain.Friendship, error) <span class="cov8" title="1">{
        // 自分自身への申請チェック
        if requesterID == addresseeID </span><span class="cov8" title="1">{
                return nil, errors.New("cannot send friend request to yourself")
        }</span>

        // ユーザー存在確認
        <span class="cov8" title="1">exists, err := s.userValidator.UserExists(ctx, addresseeID.String())
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to validate addressee: %w", err)
        }</span>
        <span class="cov8" title="1">if !exists </span><span class="cov8" title="1">{
                return nil, errors.New("addressee user not found")
        }</span>

        // 既存の友達関係をチェック
        <span class="cov8" title="1">existingFriendship, err := s.friendshipRepo.GetFriendship(ctx, requesterID, addresseeID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to check existing friendship: %w", err)
        }</span>

        <span class="cov8" title="1">if existingFriendship != nil </span><span class="cov8" title="1">{
                switch existingFriendship.Status </span>{
                case domain.FriendshipStatusAccepted:<span class="cov8" title="1">
                        return nil, errors.New("already friends")</span>
                case domain.FriendshipStatusPending:<span class="cov8" title="1">
                        return nil, errors.New("friend request already pending")</span>
                case domain.FriendshipStatusBlocked:<span class="cov8" title="1">
                        return nil, errors.New("user is blocked")</span>
                }
        }

        // 友達申請作成
        <span class="cov8" title="1">friendship := domain.NewFriendship(requesterID, addresseeID)

        if err := s.friendshipRepo.CreateFriendship(ctx, friendship); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to create friendship",
                        logger.Any("requesterID", requesterID),
                        logger.Any("addresseeID", addresseeID),
                        logger.Error(err))
                return nil, fmt.Errorf("failed to create friendship: %w", err)
        }</span>

        // イベント発行
        <span class="cov8" title="1">if err := s.eventPublisher.PublishFriendRequestSent(ctx, friendship, message); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to publish friend request sent event", logger.Error(err))
                // イベント発行失敗は非致命的
        }</span>

        <span class="cov8" title="1">s.logger.Info("Friend request sent successfully",
                logger.Any("requesterID", requesterID),
                logger.Any("addresseeID", addresseeID))

        return friendship, nil</span>
}

// AcceptFriendRequest は友達申請を承認する
func (s *SocialServiceImpl) AcceptFriendRequest(ctx context.Context, requesterID, addresseeID uuid.UUID) (*domain.Friendship, error) <span class="cov8" title="1">{
        friendship, err := s.friendshipRepo.GetFriendship(ctx, requesterID, addresseeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get friendship: %w", err)
        }</span>

        <span class="cov8" title="1">if friendship == nil </span><span class="cov8" title="1">{
                return nil, errors.New("friend request not found")
        }</span>

        <span class="cov8" title="1">if friendship.Status != domain.FriendshipStatusPending </span><span class="cov8" title="1">{
                return nil, errors.New("friend request is not pending")
        }</span>

        // addresseeIDが申請の受信者であることを確認
        <span class="cov8" title="1">if friendship.AddresseeID != addresseeID </span><span class="cov8" title="1">{
                return nil, errors.New("not authorized to accept this friend request")
        }</span>

        // 友達申請を承認
        <span class="cov8" title="1">friendship.Accept()

        if err := s.friendshipRepo.UpdateFriendship(ctx, friendship); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to update friendship",
                        logger.Any("friendshipID", friendship.ID),
                        logger.Error(err))
                return nil, fmt.Errorf("failed to update friendship: %w", err)
        }</span>

        // イベント発行
        <span class="cov8" title="1">if err := s.eventPublisher.PublishFriendRequestAccepted(ctx, friendship); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to publish friend request accepted event", logger.Error(err))
        }</span>

        <span class="cov8" title="1">s.logger.Info("Friend request accepted successfully",
                logger.Any("friendshipID", friendship.ID))

        return friendship, nil</span>
}

// DeclineFriendRequest は友達申請を拒否する
func (s *SocialServiceImpl) DeclineFriendRequest(ctx context.Context, requesterID, addresseeID uuid.UUID) error <span class="cov8" title="1">{
        friendship, err := s.friendshipRepo.GetFriendship(ctx, requesterID, addresseeID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get friendship: %w", err)
        }</span>

        <span class="cov8" title="1">if friendship == nil </span><span class="cov8" title="1">{
                return errors.New("friend request not found")
        }</span>

        <span class="cov8" title="1">if friendship.Status != domain.FriendshipStatusPending </span><span class="cov0" title="0">{
                return errors.New("friend request is not pending")
        }</span>

        // 友達申請を削除（拒否）
        <span class="cov8" title="1">if err := s.friendshipRepo.DeleteFriendship(ctx, requesterID, addresseeID); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to delete friendship",
                        logger.Any("requesterID", requesterID),
                        logger.Any("addresseeID", addresseeID),
                        logger.Error(err))
                return fmt.Errorf("failed to delete friendship: %w", err)
        }</span>

        // イベント発行
        <span class="cov8" title="1">if err := s.eventPublisher.PublishFriendRequestDeclined(ctx, friendship); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to publish friend request declined event", logger.Error(err))
        }</span>

        <span class="cov8" title="1">s.logger.Info("Friend request declined successfully",
                logger.Any("requesterID", requesterID),
                logger.Any("addresseeID", addresseeID))

        return nil</span>
}

// RemoveFriend は友達を削除する
func (s *SocialServiceImpl) RemoveFriend(ctx context.Context, userID, friendID uuid.UUID) error <span class="cov8" title="1">{
        // 友達関係が存在するかチェック
        areFriends, err := s.friendshipRepo.AreFriends(ctx, userID, friendID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check friendship: %w", err)
        }</span>

        <span class="cov8" title="1">if !areFriends </span><span class="cov8" title="1">{
                return errors.New("not friends")
        }</span>

        // 友達関係を削除
        <span class="cov8" title="1">if err := s.friendshipRepo.DeleteFriendship(ctx, userID, friendID); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to remove friend",
                        logger.Any("userID", userID),
                        logger.Any("friendID", friendID),
                        logger.Error(err))
                return fmt.Errorf("failed to remove friend: %w", err)
        }</span>

        // イベント発行
        <span class="cov8" title="1">if err := s.eventPublisher.PublishFriendRemoved(ctx, userID, friendID); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to publish friend removed event", logger.Error(err))
        }</span>

        <span class="cov8" title="1">s.logger.Info("Friend removed successfully",
                logger.Any("userID", userID),
                logger.Any("friendID", friendID))

        return nil</span>
}

// BlockUser はユーザーをブロックする
func (s *SocialServiceImpl) BlockUser(ctx context.Context, userID, targetID uuid.UUID) error <span class="cov8" title="1">{
        // 既存の関係をチェック
        existingFriendship, err := s.friendshipRepo.GetFriendship(ctx, userID, targetID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check existing relationship: %w", err)
        }</span>

        <span class="cov8" title="1">if existingFriendship != nil </span><span class="cov8" title="1">{
                // 既存の関係をブロック状態に更新
                existingFriendship.Block()
                if err := s.friendshipRepo.UpdateFriendship(ctx, existingFriendship); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update friendship to blocked: %w", err)
                }</span>
        } else<span class="cov8" title="1"> {
                // 新規ブロック関係を作成
                friendship := domain.NewFriendship(userID, targetID)
                friendship.Block()
                if err := s.friendshipRepo.CreateFriendship(ctx, friendship); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create blocked relationship: %w", err)
                }</span>
        }

        // イベント発行
        <span class="cov8" title="1">if err := s.eventPublisher.PublishUserBlocked(ctx, userID, targetID); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to publish user blocked event", logger.Error(err))
        }</span>

        <span class="cov8" title="1">s.logger.Info("User blocked successfully",
                logger.Any("userID", userID),
                logger.Any("targetID", targetID))

        return nil</span>
}

// UnblockUser はブロックを解除する
func (s *SocialServiceImpl) UnblockUser(ctx context.Context, userID, targetID uuid.UUID) error <span class="cov0" title="0">{
        // ブロック関係を削除
        if err := s.friendshipRepo.DeleteFriendship(ctx, userID, targetID); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to unblock user",
                        logger.Any("userID", userID),
                        logger.Any("targetID", targetID),
                        logger.Error(err))
                return fmt.Errorf("failed to unblock user: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("User unblocked successfully",
                logger.Any("userID", userID),
                logger.Any("targetID", targetID))

        return nil</span>
}

// === 友達一覧・検索 ===

// GetFriends は友達一覧を取得する
func (s *SocialServiceImpl) GetFriends(ctx context.Context, userID uuid.UUID, pagination commonDomain.Pagination) ([]*FriendWithUserInfo, error) <span class="cov8" title="1">{
        friendships, err := s.friendshipRepo.GetFriends(ctx, userID, pagination)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get friends: %w", err)
        }</span>

        <span class="cov8" title="1">if len(friendships) == 0 </span><span class="cov8" title="1">{
                return []*FriendWithUserInfo{}, nil
        }</span>

        // ユーザー情報を一括取得
        <span class="cov8" title="1">userIDs := make([]string, 0, len(friendships))
        for _, friendship := range friendships </span><span class="cov8" title="1">{
                if friendship.RequesterID == userID </span><span class="cov8" title="1">{
                        userIDs = append(userIDs, friendship.AddresseeID.String())
                }</span> else<span class="cov0" title="0"> {
                        userIDs = append(userIDs, friendship.RequesterID.String())
                }</span>
        }

        <span class="cov8" title="1">userInfoMap, err := s.userValidator.GetUsersInfoBatch(ctx, userIDs)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get user info batch", logger.Error(err))
                userInfoMap = make(map[string]*commonDomain.UserInfo)
        }</span>

        // 結果を組み立て
        <span class="cov8" title="1">result := make([]*FriendWithUserInfo, len(friendships))
        for i, friendship := range friendships </span><span class="cov8" title="1">{
                friendID := friendship.AddresseeID
                if friendship.RequesterID != userID </span><span class="cov0" title="0">{
                        friendID = friendship.RequesterID
                }</span>

                <span class="cov8" title="1">result[i] = &amp;FriendWithUserInfo{
                        Friendship: friendship,
                        UserInfo:   userInfoMap[friendID.String()],
                }</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

// GetPendingRequests は受信した友達申請を取得する
func (s *SocialServiceImpl) GetPendingRequests(ctx context.Context, userID uuid.UUID, pagination commonDomain.Pagination) ([]*FriendshipWithUserInfo, error) <span class="cov0" title="0">{
        friendships, err := s.friendshipRepo.GetPendingRequests(ctx, userID, pagination)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get pending requests: %w", err)
        }</span>

        <span class="cov0" title="0">if len(friendships) == 0 </span><span class="cov0" title="0">{
                return []*FriendshipWithUserInfo{}, nil
        }</span>

        // 申請者のユーザー情報を一括取得
        <span class="cov0" title="0">userIDs := make([]string, len(friendships))
        for i, friendship := range friendships </span><span class="cov0" title="0">{
                userIDs[i] = friendship.RequesterID.String()
        }</span>

        <span class="cov0" title="0">userInfoMap, err := s.userValidator.GetUsersInfoBatch(ctx, userIDs)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get user info batch", logger.Error(err))
                userInfoMap = make(map[string]*commonDomain.UserInfo)
        }</span>

        // 結果を組み立て
        <span class="cov0" title="0">result := make([]*FriendshipWithUserInfo, len(friendships))
        for i, friendship := range friendships </span><span class="cov0" title="0">{
                result[i] = &amp;FriendshipWithUserInfo{
                        Friendship: friendship,
                        UserInfo:   userInfoMap[friendship.RequesterID.String()],
                }
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// GetSentRequests は送信した友達申請を取得する
func (s *SocialServiceImpl) GetSentRequests(ctx context.Context, userID uuid.UUID, pagination commonDomain.Pagination) ([]*FriendshipWithUserInfo, error) <span class="cov0" title="0">{
        friendships, err := s.friendshipRepo.GetSentRequests(ctx, userID, pagination)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get sent requests: %w", err)
        }</span>

        <span class="cov0" title="0">if len(friendships) == 0 </span><span class="cov0" title="0">{
                return []*FriendshipWithUserInfo{}, nil
        }</span>

        // 申請先のユーザー情報を一括取得
        <span class="cov0" title="0">userIDs := make([]string, len(friendships))
        for i, friendship := range friendships </span><span class="cov0" title="0">{
                userIDs[i] = friendship.AddresseeID.String()
        }</span>

        <span class="cov0" title="0">userInfoMap, err := s.userValidator.GetUsersInfoBatch(ctx, userIDs)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get user info batch", logger.Error(err))
                userInfoMap = make(map[string]*commonDomain.UserInfo)
        }</span>

        // 結果を組み立て
        <span class="cov0" title="0">result := make([]*FriendshipWithUserInfo, len(friendships))
        for i, friendship := range friendships </span><span class="cov0" title="0">{
                result[i] = &amp;FriendshipWithUserInfo{
                        Friendship: friendship,
                        UserInfo:   userInfoMap[friendship.AddresseeID.String()],
                }
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// GetMutualFriends は共通の友達を取得する
func (s *SocialServiceImpl) GetMutualFriends(ctx context.Context, userID, targetID uuid.UUID) ([]*FriendWithUserInfo, error) <span class="cov0" title="0">{
        friendships, err := s.friendshipRepo.GetMutualFriends(ctx, userID, targetID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get mutual friends: %w", err)
        }</span>

        <span class="cov0" title="0">if len(friendships) == 0 </span><span class="cov0" title="0">{
                return []*FriendWithUserInfo{}, nil
        }</span>

        // 共通の友達のユーザー情報を一括取得
        <span class="cov0" title="0">userIDs := make([]string, 0, len(friendships))
        for _, friendship := range friendships </span><span class="cov0" title="0">{
                if friendship.RequesterID != userID &amp;&amp; friendship.RequesterID != targetID </span><span class="cov0" title="0">{
                        userIDs = append(userIDs, friendship.RequesterID.String())
                }</span>
                <span class="cov0" title="0">if friendship.AddresseeID != userID &amp;&amp; friendship.AddresseeID != targetID </span><span class="cov0" title="0">{
                        userIDs = append(userIDs, friendship.AddresseeID.String())
                }</span>
        }

        <span class="cov0" title="0">userInfoMap, err := s.userValidator.GetUsersInfoBatch(ctx, userIDs)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get user info batch", logger.Error(err))
                userInfoMap = make(map[string]*commonDomain.UserInfo)
        }</span>

        // 結果を組み立て
        <span class="cov0" title="0">result := make([]*FriendWithUserInfo, 0, len(friendships))
        for _, friendship := range friendships </span><span class="cov0" title="0">{
                var friendID uuid.UUID
                if friendship.RequesterID != userID &amp;&amp; friendship.RequesterID != targetID </span><span class="cov0" title="0">{
                        friendID = friendship.RequesterID
                }</span> else<span class="cov0" title="0"> if friendship.AddresseeID != userID &amp;&amp; friendship.AddresseeID != targetID </span><span class="cov0" title="0">{
                        friendID = friendship.AddresseeID
                }</span> else<span class="cov0" title="0"> {
                        continue</span>
                }

                <span class="cov0" title="0">result = append(result, &amp;FriendWithUserInfo{
                        Friendship: friendship,
                        UserInfo:   userInfoMap[friendID.String()],
                })</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

// === 招待管理 ===

// CreateInvitation は招待を作成する
func (s *SocialServiceImpl) CreateInvitation(ctx context.Context, input CreateInvitationInput) (*domain.Invitation, error) <span class="cov8" title="1">{
        // 招待作成
        invitation := domain.NewInvitation(input.Type, input.Method, input.InviterID, input.Message, input.ExpiresHours)

        // ターゲット設定
        if input.TargetID != nil </span><span class="cov8" title="1">{
                invitation.SetTarget(*input.TargetID)
        }</span>

        // 被招待者情報設定
        <span class="cov8" title="1">if input.InviteeEmail != nil </span><span class="cov8" title="1">{
                inviteeInfo := domain.InviteeInfo{
                        Email: *input.InviteeEmail,
                }
                invitation.SetInviteeInfo(inviteeInfo)
        }</span>

        // データベースに保存
        <span class="cov8" title="1">if err := s.invitationRepo.CreateInvitation(ctx, invitation); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to create invitation",
                        logger.Any("invitation", invitation),
                        logger.Error(err))
                return nil, fmt.Errorf("failed to create invitation: %w", err)
        }</span>

        // イベント発行
        <span class="cov8" title="1">if err := s.eventPublisher.PublishInvitationCreated(ctx, invitation); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to publish invitation created event", logger.Error(err))
        }</span>

        <span class="cov8" title="1">s.logger.Info("Invitation created successfully",
                logger.Any("invitationID", invitation.ID))

        return invitation, nil</span>
}

// GetInvitation は招待詳細を取得する
func (s *SocialServiceImpl) GetInvitation(ctx context.Context, invitationID uuid.UUID) (*domain.Invitation, error) <span class="cov0" title="0">{
        return s.invitationRepo.GetInvitationByID(ctx, invitationID)
}</span>

// GetInvitationByCode は招待コードから招待を取得する
func (s *SocialServiceImpl) GetInvitationByCode(ctx context.Context, code string) (*domain.Invitation, error) <span class="cov0" title="0">{
        return s.invitationRepo.GetInvitationByCode(ctx, code)
}</span>

// AcceptInvitation は招待を受諾する
func (s *SocialServiceImpl) AcceptInvitation(ctx context.Context, code string, userID uuid.UUID) (*InvitationResult, error) <span class="cov8" title="1">{
        invitation, err := s.invitationRepo.GetInvitationByCode(ctx, code)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get invitation: %w", err)
        }</span>

        <span class="cov8" title="1">if invitation == nil </span><span class="cov8" title="1">{
                return nil, errors.New("invitation not found")
        }</span>

        <span class="cov8" title="1">if !invitation.IsValid() </span><span class="cov8" title="1">{
                return nil, errors.New("invitation is not valid")
        }</span>

        // 招待を受諾
        <span class="cov8" title="1">if err := invitation.Accept(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to accept invitation: %w", err)
        }</span>

        <span class="cov8" title="1">invitation.SetInvitee(userID)

        if err := s.invitationRepo.UpdateInvitation(ctx, invitation); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update invitation: %w", err)
        }</span>

        // 招待タイプに応じた処理
        <span class="cov8" title="1">result := &amp;InvitationResult{
                Success: true,
                Message: "招待を受諾しました",
        }

        switch invitation.Type </span>{
        case domain.InvitationTypeFriend:<span class="cov8" title="1">
                // 友達関係を作成
                friendship, err := s.SendFriendRequest(ctx, invitation.InviterID, userID, "招待から")
                if err != nil </span><span class="cov0" title="0">{
                        // 既に友達の場合などは警告レベル
                        s.logger.Warn("Failed to create friendship from invitation", logger.Error(err))
                }</span> else<span class="cov8" title="1"> {
                        result.Friendship = friendship
                }</span>
        case domain.InvitationTypeGroup:<span class="cov0" title="0">
                // グループメンバー追加（グループモジュールとの連携が必要）
                result.Message = "グループ招待を受諾しました"</span>
        }

        // イベント発行
        <span class="cov8" title="1">if err := s.eventPublisher.PublishInvitationAccepted(ctx, invitation); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to publish invitation accepted event", logger.Error(err))
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

// DeclineInvitation は招待を拒否する
func (s *SocialServiceImpl) DeclineInvitation(ctx context.Context, invitationID, userID uuid.UUID) error <span class="cov0" title="0">{
        invitation, err := s.invitationRepo.GetInvitationByID(ctx, invitationID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get invitation: %w", err)
        }</span>

        <span class="cov0" title="0">if invitation == nil </span><span class="cov0" title="0">{
                return errors.New("invitation not found")
        }</span>

        // 権限チェック
        <span class="cov0" title="0">if invitation.InviteeID == nil || *invitation.InviteeID != userID </span><span class="cov0" title="0">{
                return errors.New("not authorized to decline this invitation")
        }</span>

        <span class="cov0" title="0">if err := invitation.Decline(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decline invitation: %w", err)
        }</span>

        <span class="cov0" title="0">if err := s.invitationRepo.UpdateInvitation(ctx, invitation); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update invitation: %w", err)
        }</span>

        // イベント発行
        <span class="cov0" title="0">if err := s.eventPublisher.PublishInvitationDeclined(ctx, invitation); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to publish invitation declined event", logger.Error(err))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CancelInvitation は招待をキャンセルする
func (s *SocialServiceImpl) CancelInvitation(ctx context.Context, invitationID, inviterID uuid.UUID) error <span class="cov0" title="0">{
        invitation, err := s.invitationRepo.GetInvitationByID(ctx, invitationID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get invitation: %w", err)
        }</span>

        <span class="cov0" title="0">if invitation == nil </span><span class="cov0" title="0">{
                return errors.New("invitation not found")
        }</span>

        // 権限チェック
        <span class="cov0" title="0">if invitation.InviterID != inviterID </span><span class="cov0" title="0">{
                return errors.New("not authorized to cancel this invitation")
        }</span>

        <span class="cov0" title="0">if err := invitation.Cancel(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to cancel invitation: %w", err)
        }</span>

        <span class="cov0" title="0">if err := s.invitationRepo.UpdateInvitation(ctx, invitation); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update invitation: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetSentInvitations は送信した招待一覧を取得する
func (s *SocialServiceImpl) GetSentInvitations(ctx context.Context, inviterID uuid.UUID, pagination commonDomain.Pagination) ([]*domain.Invitation, error) <span class="cov0" title="0">{
        return s.invitationRepo.GetSentInvitations(ctx, inviterID, pagination)
}</span>

// GetReceivedInvitations は受信した招待一覧を取得する
func (s *SocialServiceImpl) GetReceivedInvitations(ctx context.Context, inviteeID uuid.UUID, pagination commonDomain.Pagination) ([]*domain.Invitation, error) <span class="cov0" title="0">{
        return s.invitationRepo.GetReceivedInvitations(ctx, inviteeID, pagination)
}</span>

// GenerateInviteURL は招待URLを生成する
func (s *SocialServiceImpl) GenerateInviteURL(ctx context.Context, invitationID uuid.UUID) (string, error) <span class="cov8" title="1">{
        invitation, err := s.invitationRepo.GetInvitationByID(ctx, invitationID)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get invitation: %w", err)
        }</span>

        <span class="cov8" title="1">if invitation == nil </span><span class="cov8" title="1">{
                return "", errors.New("invitation not found")
        }</span>

        <span class="cov8" title="1">if invitation.Code == "" </span><span class="cov8" title="1">{
                return "", errors.New("invitation does not have a code")
        }</span>

        <span class="cov8" title="1">return s.urlGateway.GenerateInviteURL(ctx, invitationID, invitation.Code)</span>
}

// ValidateInviteCode は招待コードの妥当性を確認する
func (s *SocialServiceImpl) ValidateInviteCode(ctx context.Context, code string) (*domain.Invitation, error) <span class="cov0" title="0">{
        return s.invitationRepo.GetInvitationByCode(ctx, code)
}</span>

// GetRelationship はユーザー間の関係を取得する
func (s *SocialServiceImpl) GetRelationship(ctx context.Context, userID, targetID uuid.UUID) (*UserRelationship, error) <span class="cov8" title="1">{
        relationship := &amp;UserRelationship{}

        // 友達関係をチェック
        areFriends, err := s.friendshipRepo.AreFriends(ctx, userID, targetID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check friendship: %w", err)
        }</span>
        <span class="cov8" title="1">relationship.IsFriend = areFriends

        // ブロック関係をチェック
        isBlocked, err := s.friendshipRepo.IsBlocked(ctx, userID, targetID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check block status: %w", err)
        }</span>
        <span class="cov8" title="1">relationship.IsBlocked = isBlocked

        // 申請状況をチェック
        friendship, err := s.friendshipRepo.GetFriendship(ctx, userID, targetID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get friendship: %w", err)
        }</span>

        <span class="cov8" title="1">if friendship != nil &amp;&amp; friendship.Status == domain.FriendshipStatusPending </span><span class="cov8" title="1">{
                if friendship.RequesterID == userID </span><span class="cov0" title="0">{
                        relationship.RequestSent = true
                }</span> else<span class="cov8" title="1"> {
                        relationship.RequestReceived = true
                }</span>
        }

        <span class="cov8" title="1">return relationship, nil</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package domain

import (
        "time"
)

// DailyStats は日次のタスク統計を表す
type DailyStats struct {
        Date            time.Time `json:"date"`
        TotalTasks      int       `json:"total_tasks"`
        CompletedTasks  int       `json:"completed_tasks"`
        InProgressTasks int       `json:"in_progress_tasks"`
        TodoTasks       int       `json:"todo_tasks"`
        OverdueTasks    int       `json:"overdue_tasks"`
        CompletionRate  float64   `json:"completion_rate"` // 0-100の範囲
}

// WeeklyStats は週次のタスク統計を表す
type WeeklyStats struct {
        WeekStart      time.Time              `json:"week_start"`
        WeekEnd        time.Time              `json:"week_end"`
        TotalTasks     int                    `json:"total_tasks"`
        CompletedTasks int                    `json:"completed_tasks"`
        CompletionRate float64                `json:"completion_rate"`
        DailyStats     map[string]*DailyStats `json:"daily_stats"` // key: "Monday", "Tuesday", etc.
}

// ProgressColor は進捗率に応じた色を表す
type ProgressColor string

const (
        ColorDarkGreen ProgressColor = "#22c55e" // 100%完了：濃い緑
        ColorGreen     ProgressColor = "#84cc16" // 80-99%：緑
        ColorYellow    ProgressColor = "#eab308" // 60-79%：黄色
        ColorOrange    ProgressColor = "#f97316" // 40-59%：オレンジ
        ColorLightRed  ProgressColor = "#ef4444" // 20-39%：薄い赤
        ColorRed       ProgressColor = "#dc2626" // 1-19%：赤
        ColorGray      ProgressColor = "#9ca3af" // 0%：灰色
)

// DashboardStats はダッシュボード用の統計情報を表す
type DashboardStats struct {
        TodayStats        *DailyStats      `json:"today_stats"`
        WeeklyOverview    *WeeklyStats     `json:"weekly_overview"`
        UpcomingWeekTasks *WeeklyPreview   `json:"upcoming_week_tasks"`
        CategoryBreakdown map[Category]int `json:"category_breakdown"`
        PriorityBreakdown map[Priority]int `json:"priority_breakdown"`
        RecentCompletions []*Task          `json:"recent_completions"`
        OverdueTasksCount int              `json:"overdue_tasks_count"`
}

// WeeklyPreview は今後1週間のタスクプレビューを表す
type WeeklyPreview struct {
        WeekStart    time.Time                `json:"week_start"`
        WeekEnd      time.Time                `json:"week_end"`
        TotalTasks   int                      `json:"total_tasks"`
        DailyPreview map[string]*DailyPreview `json:"daily_preview"` // key: "Monday", "Tuesday", etc.
}

// DailyPreview は日次のタスクプレビューを表す
type DailyPreview struct {
        Date       time.Time `json:"date"`
        TaskCount  int       `json:"task_count"`
        HasOverdue bool      `json:"has_overdue"`
}

// ProgressLevel は進捗レベルを表す
type ProgressLevel struct {
        Percentage int           `json:"percentage"`
        Color      ProgressColor `json:"color"`
        Label      string        `json:"label"`
}

// GetProgressColor は進捗率に応じた色を取得する
func GetProgressColor(completionRate float64) ProgressColor <span class="cov8" title="1">{
        switch </span>{
        case completionRate &gt;= 100:<span class="cov8" title="1">
                return ColorDarkGreen</span>
        case completionRate &gt;= 80:<span class="cov8" title="1">
                return ColorGreen</span>
        case completionRate &gt;= 60:<span class="cov8" title="1">
                return ColorYellow</span>
        case completionRate &gt;= 40:<span class="cov8" title="1">
                return ColorOrange</span>
        case completionRate &gt;= 20:<span class="cov8" title="1">
                return ColorLightRed</span>
        case completionRate &gt;= 1:<span class="cov8" title="1">
                return ColorRed</span>
        default:<span class="cov8" title="1">
                return ColorGray</span>
        }
}

// GetProgressLevel は進捗率に応じたレベル情報を取得する
func GetProgressLevel(completionRate float64) ProgressLevel <span class="cov8" title="1">{
        color := GetProgressColor(completionRate)
        var label string

        switch </span>{
        case completionRate &gt;= 100:<span class="cov8" title="1">
                label = "完了"</span>
        case completionRate &gt;= 80:<span class="cov8" title="1">
                label = "優秀"</span>
        case completionRate &gt;= 60:<span class="cov8" title="1">
                label = "良好"</span>
        case completionRate &gt;= 40:<span class="cov8" title="1">
                label = "普通"</span>
        case completionRate &gt;= 20:<span class="cov8" title="1">
                label = "要改善"</span>
        case completionRate &gt;= 1:<span class="cov8" title="1">
                label = "低調"</span>
        default:<span class="cov8" title="1">
                label = "未着手"</span>
        }

        <span class="cov8" title="1">return ProgressLevel{
                Percentage: int(completionRate),
                Color:      color,
                Label:      label,
        }</span>
}

// CalculateCompletionRate は完了率を計算する
func CalculateCompletionRate(completed, total int) float64 <span class="cov8" title="1">{
        if total == 0 </span><span class="cov8" title="1">{
                return 0.0
        }</span>
        <span class="cov8" title="1">return (float64(completed) / float64(total)) * 100</span>
}

// GetWeekdayName は曜日名を取得する
func GetWeekdayName(weekday time.Weekday) string <span class="cov8" title="1">{
        weekdays := map[time.Weekday]string{
                time.Monday:    "Monday",
                time.Tuesday:   "Tuesday",
                time.Wednesday: "Wednesday",
                time.Thursday:  "Thursday",
                time.Friday:    "Friday",
                time.Saturday:  "Saturday",
                time.Sunday:    "Sunday",
        }
        return weekdays[weekday]
}</span>

// GetWeekdayNameJP は日本語の曜日名を取得する
func GetWeekdayNameJP(weekday time.Weekday) string <span class="cov8" title="1">{
        weekdays := map[time.Weekday]string{
                time.Monday:    "月",
                time.Tuesday:   "火",
                time.Wednesday: "水",
                time.Thursday:  "木",
                time.Friday:    "金",
                time.Saturday:  "土",
                time.Sunday:    "日",
        }
        return weekdays[weekday]
}</span>

// GetWeekStartEnd は指定された日付の週の開始日と終了日を取得する（月曜開始）
func GetWeekStartEnd(date time.Time) (time.Time, time.Time) <span class="cov8" title="1">{
        // 月曜日を週の開始とする
        weekday := date.Weekday()
        daysFromMonday := int(weekday) - int(time.Monday)
        if daysFromMonday &lt; 0 </span><span class="cov8" title="1">{
                daysFromMonday += 7
        }</span>

        <span class="cov8" title="1">weekStart := date.AddDate(0, 0, -daysFromMonday)
        weekEnd := weekStart.AddDate(0, 0, 6)

        // 時刻を0時0分0秒に設定
        weekStart = time.Date(weekStart.Year(), weekStart.Month(), weekStart.Day(), 0, 0, 0, 0, weekStart.Location())
        weekEnd = time.Date(weekEnd.Year(), weekEnd.Month(), weekEnd.Day(), 23, 59, 59, 999999999, weekEnd.Location())

        return weekStart, weekEnd</span>
}

// GetDayStartEnd は指定された日付の開始時刻と終了時刻を取得する
func GetDayStartEnd(date time.Time) (time.Time, time.Time) <span class="cov8" title="1">{
        dayStart := time.Date(date.Year(), date.Month(), date.Day(), 0, 0, 0, 0, date.Location())
        dayEnd := time.Date(date.Year(), date.Month(), date.Day(), 23, 59, 59, 999999999, date.Location())
        return dayStart, dayEnd
}</span>

// NewDailyStats は新しいDailyStatsを作成する
func NewDailyStats(date time.Time, tasks []*Task) *DailyStats <span class="cov8" title="1">{
        stats := &amp;DailyStats{
                Date:       date,
                TotalTasks: len(tasks),
        }

        for _, task := range tasks </span><span class="cov8" title="1">{
                switch task.Status </span>{
                case TaskStatusDone:<span class="cov8" title="1">
                        stats.CompletedTasks++</span>
                case TaskStatusInProgress:<span class="cov8" title="1">
                        stats.InProgressTasks++</span>
                case TaskStatusTodo:<span class="cov8" title="1">
                        stats.TodoTasks++</span>
                }

                <span class="cov8" title="1">if task.CheckIsOverdue() </span><span class="cov8" title="1">{
                        stats.OverdueTasks++
                }</span>
        }

        <span class="cov8" title="1">stats.CompletionRate = CalculateCompletionRate(stats.CompletedTasks, stats.TotalTasks)
        return stats</span>
}

// NewWeeklyStats は新しいWeeklyStatsを作成する
func NewWeeklyStats(weekStart, weekEnd time.Time, dailyStats map[string]*DailyStats) *WeeklyStats <span class="cov8" title="1">{
        stats := &amp;WeeklyStats{
                WeekStart:  weekStart,
                WeekEnd:    weekEnd,
                DailyStats: dailyStats,
        }

        for _, daily := range dailyStats </span><span class="cov8" title="1">{
                stats.TotalTasks += daily.TotalTasks
                stats.CompletedTasks += daily.CompletedTasks
        }</span>

        <span class="cov8" title="1">stats.CompletionRate = CalculateCompletionRate(stats.CompletedTasks, stats.TotalTasks)
        return stats</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package domain

import (
        "time"
)

// TaskStatus はタスクのステータスを表す型
type TaskStatus string

// タスクステータスの定数
const (
        TaskStatusTodo       TaskStatus = "TODO"
        TaskStatusInProgress TaskStatus = "IN_PROGRESS"
        TaskStatusDone       TaskStatus = "DONE"
)

// Priority はタスクの優先度を表す型
type Priority string

// タスク優先度の定数
const (
        PriorityLow    Priority = "LOW"
        PriorityMedium Priority = "MEDIUM"
        PriorityHigh   Priority = "HIGH"
)

// Category はタスクのカテゴリを表す型
type Category string

// タスクカテゴリの定数
const (
        CategoryWork     Category = "WORK"     // 仕事
        CategoryPersonal Category = "PERSONAL" // 個人
        CategoryStudy    Category = "STUDY"    // 学習
        CategoryHealth   Category = "HEALTH"   // 健康
        CategoryShopping Category = "SHOPPING" // 買い物
        CategoryOther    Category = "OTHER"    // その他
)

// Task はタスクのドメインモデルを表す
type Task struct {
        ID          string     `json:"id"`
        Title       string     `json:"title"`
        Description string     `json:"description"`
        Status      TaskStatus `json:"status"`
        Priority    Priority   `json:"priority"`
        Category    Category   `json:"category"`
        AssigneeID  *string    `json:"assignee_id,omitempty"`
        CreatedBy   string     `json:"created_by"`
        DueDate     *time.Time `json:"due_date,omitempty"`
        IsOverdue   bool       `json:"is_overdue"`
        CreatedAt   time.Time  `json:"created_at"`
        UpdatedAt   time.Time  `json:"updated_at"`
}

// ListFilter はタスク一覧取得時のフィルタを表す
type ListFilter struct {
        Status      *TaskStatus `json:"status,omitempty"`
        Priority    *Priority   `json:"priority,omitempty"`
        Category    *Category   `json:"category,omitempty"`
        AssigneeID  *string     `json:"assignee_id,omitempty"`
        CreatedBy   *string     `json:"created_by,omitempty"`
        DueDateFrom *time.Time  `json:"due_date_from,omitempty"`
        DueDateTo   *time.Time  `json:"due_date_to,omitempty"`
}

// Pagination はページング情報を表す
type Pagination struct {
        Page     int `json:"page"`
        PageSize int `json:"page_size"`
}

// SortOptions はソートオプションを表す
type SortOptions struct {
        Field     string `json:"field"`     // ソートするフィールド
        Direction string `json:"direction"` // ASC または DESC
}

// NewTask は新しいタスクを作成する（Category引数を追加）
func NewTask(title, description string, priority Priority, category Category, createdBy string) *Task <span class="cov8" title="1">{
        now := time.Now()
        task := &amp;Task{
                Title:       title,
                Description: description,
                Status:      TaskStatusTodo,
                Priority:    priority,
                Category:    category,
                CreatedBy:   createdBy,
                CreatedAt:   now,
                UpdatedAt:   now,
        }

        task.UpdateIsOverdue()

        return task
}</span>

// NewTaskWithDefaults はデフォルト値でタスクを作成する（下位互換性）
func NewTaskWithDefaults(title, description string, priority Priority, createdBy string) *Task <span class="cov0" title="0">{
        return NewTask(title, description, priority, CategoryOther, createdBy)
}</span>

// AssignTo はタスクを特定のユーザーに割り当てる
func (t *Task) AssignTo(userID string) <span class="cov8" title="1">{
        t.AssigneeID = &amp;userID
        t.UpdatedAt = time.Now()
        t.UpdateIsOverdue()
}</span>

// SetStatus はタスクのステータスを設定する
func (t *Task) SetStatus(status TaskStatus) <span class="cov8" title="1">{
        t.Status = status
        t.UpdatedAt = time.Now()
        t.UpdateIsOverdue()
}</span>

// SetDueDate はタスクの期限を設定する
func (t *Task) SetDueDate(date time.Time) <span class="cov8" title="1">{
        t.DueDate = &amp;date
        t.UpdatedAt = time.Now()
        t.UpdateIsOverdue()
}</span>

// SetCategory はタスクのカテゴリを設定する
func (t *Task) SetCategory(category Category) <span class="cov0" title="0">{
        t.Category = category
        t.UpdatedAt = time.Now()
        t.UpdateIsOverdue()
}</span>

// IsOverdue はタスクが期限切れかどうかを判定する（メソッド版も維持）
func (t *Task) CheckIsOverdue() bool <span class="cov8" title="1">{
        return t.DueDate != nil &amp;&amp; t.Status != TaskStatusDone &amp;&amp; time.Now().After(*t.DueDate)
}</span>

// UpdateIsOverdue はIsOverdueフィールドを最新の状態に更新する
func (t *Task) UpdateIsOverdue() <span class="cov8" title="1">{
        t.IsOverdue = t.CheckIsOverdue()
}</span>

// PrepareForResponse はレスポンス送信前にフィールドを最新状態に更新する
func (t *Task) PrepareForResponse() <span class="cov8" title="1">{
        t.UpdateIsOverdue()
}</span>

// GetCategoryDisplayName はカテゴリの表示名を取得する
func (c Category) GetDisplayName() string <span class="cov8" title="1">{
        switch c </span>{
        case CategoryWork:<span class="cov8" title="1">
                return "仕事"</span>
        case CategoryPersonal:<span class="cov8" title="1">
                return "個人"</span>
        case CategoryStudy:<span class="cov8" title="1">
                return "学習"</span>
        case CategoryHealth:<span class="cov8" title="1">
                return "健康"</span>
        case CategoryShopping:<span class="cov8" title="1">
                return "買い物"</span>
        case CategoryOther:<span class="cov8" title="1">
                return "その他"</span>
        default:<span class="cov8" title="1">
                return string(c)</span>
        }
}

// GetPriorityDisplayName は優先度の表示名を取得する
func (p Priority) GetDisplayName() string <span class="cov8" title="1">{
        switch p </span>{
        case PriorityHigh:<span class="cov8" title="1">
                return "高"</span>
        case PriorityMedium:<span class="cov8" title="1">
                return "中"</span>
        case PriorityLow:<span class="cov8" title="1">
                return "低"</span>
        default:<span class="cov8" title="1">
                return string(p)</span>
        }
}

// GetStatusDisplayName はステータスの表示名を取得する
func (s TaskStatus) GetDisplayName() string <span class="cov8" title="1">{
        switch s </span>{
        case TaskStatusTodo:<span class="cov8" title="1">
                return "未着手"</span>
        case TaskStatusInProgress:<span class="cov8" title="1">
                return "進行中"</span>
        case TaskStatusDone:<span class="cov8" title="1">
                return "完了"</span>
        default:<span class="cov8" title="1">
                return string(s)</span>
        }
}

// GetAllCategories は利用可能な全カテゴリを取得する
func GetAllCategories() []Category <span class="cov8" title="1">{
        return []Category{
                CategoryWork,
                CategoryPersonal,
                CategoryStudy,
                CategoryHealth,
                CategoryShopping,
                CategoryOther,
        }
}</span>

// GetAllPriorities は利用可能な全優先度を取得する
func GetAllPriorities() []Priority <span class="cov8" title="1">{
        return []Priority{
                PriorityHigh,
                PriorityMedium,
                PriorityLow,
        }
}</span>

// GetAllStatuses は利用可能な全ステータスを取得する
func GetAllStatuses() []TaskStatus <span class="cov8" title="1">{
        return []TaskStatus{
                TaskStatusTodo,
                TaskStatusInProgress,
                TaskStatusDone,
        }
}</span>

// TaskSliceHelper はタスクスライス用のヘルパーメソッド
type TaskSliceHelper []*Task

// UpdateAllIsOverdue はスライス内の全タスクのIsOverdueフィールドを更新
func (tasks TaskSliceHelper) UpdateAllIsOverdue() <span class="cov8" title="1">{
        for _, task := range tasks </span><span class="cov8" title="1">{
                task.UpdateIsOverdue()
        }</span>
}

// PrepareAllForResponse はスライス内の全タスクをレスポンス用に準備
func (tasks TaskSliceHelper) PrepareAllForResponse() <span class="cov8" title="1">{
        for _, task := range tasks </span><span class="cov8" title="1">{
                task.PrepareForResponse()
        }</span>
}

// タスクリストをレスポンス用に準備するヘルパー関数
func PrepareTasksForResponse(tasks []*Task) <span class="cov8" title="1">{
        helper := TaskSliceHelper(tasks)
        helper.PrepareAllForResponse()
}</span>

// 単一タスクをレスポンス用に準備するヘルパー関数
func PrepareTaskForResponse(task *Task) <span class="cov8" title="1">{
        if task != nil </span><span class="cov8" title="1">{
                task.PrepareForResponse()
        }</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package databaseInfra

import (
        "database/sql"
        "fmt"

        "github.com/hryt430/Yotei+/config"
        commonDB "github.com/hryt430/Yotei+/internal/common/infrastructure/database"
        "github.com/hryt430/Yotei+/internal/modules/task/interface/database"
)

type SqlHandler struct {
        Conn *sql.DB
}

func NewSqlHandler() SqlHandler <span class="cov0" title="0">{
        config, err := config.LoadConfig(".")
        if err != nil </span><span class="cov0" title="0">{
                panic(err.Error())</span>
        }

        // common/databaseからDBコネクションを取得
        <span class="cov0" title="0">conn, err := commonDB.NewMySQLConnection(config)
        if err != nil </span><span class="cov0" title="0">{
                panic(err.Error())</span>
        }

        <span class="cov0" title="0">sqlHandler := new(SqlHandler)
        sqlHandler.Conn = conn
        return *sqlHandler</span>
}

func (h *SqlHandler) Execute(statement string, args ...interface{}) (database.Result, error) <span class="cov0" title="0">{
        res, err := h.Conn.Exec(statement, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ステートメント実行失敗: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;SqlResult{res}, nil</span>
}

func (h *SqlHandler) Query(statement string, args ...interface{}) (database.Row, error) <span class="cov0" title="0">{
        rows, err := h.Conn.Query(statement, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("クエリ実行失敗: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;SqlRow{Rows: rows}, nil</span>
}

func (h *SqlHandler) Close() error <span class="cov0" title="0">{
        return h.Conn.Close()
}</span>

type SqlResult struct {
        Result sql.Result
}

func (r *SqlResult) LastInsertId() (int64, error) <span class="cov0" title="0">{
        return r.Result.LastInsertId()
}</span>

func (r *SqlResult) RowsAffected() (int64, error) <span class="cov0" title="0">{
        return r.Result.RowsAffected()
}</span>

type SqlRow struct {
        Rows *sql.Rows
}

func (r *SqlRow) Scan(dest ...interface{}) error <span class="cov0" title="0">{
        return r.Rows.Scan(dest...)
}</span>

func (r *SqlRow) Next() bool <span class="cov0" title="0">{
        return r.Rows.Next()
}</span>

func (r *SqlRow) Close() error <span class="cov0" title="0">{
        return r.Rows.Close()
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">package messaging

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "time"

        "github.com/hryt430/Yotei+/internal/modules/task/domain"
)

// EventType はイベントの種類を表す型
type EventType string

const (
        // イベントタイプの定義
        EventTaskCreated   EventType = "task.created"
        EventTaskUpdated   EventType = "task.updated"
        EventTaskDeleted   EventType = "task.deleted"
        EventTaskAssigned  EventType = "task.assigned"
        EventTaskCompleted EventType = "task.completed"
        EventTaskOverdue   EventType = "task.overdue"
)

// TaskEvent はタスク関連のイベントを表す構造体
type TaskEvent struct {
        Type      EventType   `json:"type"`
        TaskID    string      `json:"task_id"`
        Timestamp time.Time   `json:"timestamp"`
        Data      interface{} `json:"data,omitempty"`
}

// EventPublisher はイベントを発行するインターフェース
type EventPublisher interface {
        PublishTaskCreated(ctx context.Context, task *domain.Task) error
        PublishTaskUpdated(ctx context.Context, task *domain.Task) error
        PublishTaskDeleted(ctx context.Context, taskID string) error
        PublishTaskAssigned(ctx context.Context, task *domain.Task) error
        PublishTaskCompleted(ctx context.Context, task *domain.Task) error
        PublishTaskOverdue(ctx context.Context, task *domain.Task) error
}

// LogEventPublisher はログにイベントを出力するシンプルな実装
type LogEventPublisher struct{}

// NewLogEventPublisher は新しいLogEventPublisherを作成する
func NewLogEventPublisher() EventPublisher <span class="cov0" title="0">{
        return &amp;LogEventPublisher{}
}</span>

// PublishTaskCreated はタスク作成イベントを発行する
func (p *LogEventPublisher) PublishTaskCreated(ctx context.Context, task *domain.Task) error <span class="cov0" title="0">{
        return p.publishEvent(ctx, EventTaskCreated, task.ID, task)
}</span>

// PublishTaskUpdated はタスク更新イベントを発行する
func (p *LogEventPublisher) PublishTaskUpdated(ctx context.Context, task *domain.Task) error <span class="cov0" title="0">{
        return p.publishEvent(ctx, EventTaskUpdated, task.ID, task)
}</span>

// PublishTaskDeleted はタスク削除イベントを発行する
func (p *LogEventPublisher) PublishTaskDeleted(ctx context.Context, taskID string) error <span class="cov0" title="0">{
        return p.publishEvent(ctx, EventTaskDeleted, taskID, nil)
}</span>

// PublishTaskAssigned はタスク割り当てイベントを発行する
func (p *LogEventPublisher) PublishTaskAssigned(ctx context.Context, task *domain.Task) error <span class="cov0" title="0">{
        data := map[string]interface{}{
                "task_id":     task.ID,
                "assignee_id": *task.AssigneeID,
        }
        return p.publishEvent(ctx, EventTaskAssigned, task.ID, data)
}</span>

// PublishTaskCompleted はタスク完了イベントを発行する
func (p *LogEventPublisher) PublishTaskCompleted(ctx context.Context, task *domain.Task) error <span class="cov0" title="0">{
        return p.publishEvent(ctx, EventTaskCompleted, task.ID, task)
}</span>

// PublishTaskOverdue はタスク期限切れイベントを発行する
func (p *LogEventPublisher) PublishTaskOverdue(ctx context.Context, task *domain.Task) error <span class="cov0" title="0">{
        return p.publishEvent(ctx, EventTaskOverdue, task.ID, task)
}</span>

// publishEvent はイベントをシリアライズしてログに出力する
func (p *LogEventPublisher) publishEvent(ctx context.Context, eventType EventType, taskID string, data interface{}) error <span class="cov0" title="0">{
        event := TaskEvent{
                Type:      eventType,
                TaskID:    taskID,
                Timestamp: time.Now(),
                Data:      data,
        }

        eventJSON, err := json.Marshal(event)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal event: %w", err)
        }</span>

        // 実際のメッセージキューやイベントバスへの送信は将来的に実装
        // 現在はログに出力するだけ
        <span class="cov0" title="0">log.Printf("[EVENT] %s", string(eventJSON))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package messaging

import (
        "context"

        notificationInput "github.com/hryt430/Yotei+/internal/modules/notification/usecase/input"
)

// NotificationAdapter は循環参照を避けるためのアダプター
type NotificationAdapter struct {
        notificationUseCase notificationInput.NotificationUseCase
}

// NewNotificationAdapter は新しいNotificationAdapterを作成
func NewNotificationAdapter(notificationUseCase notificationInput.NotificationUseCase) *NotificationAdapter <span class="cov0" title="0">{
        return &amp;NotificationAdapter{
                notificationUseCase: notificationUseCase,
        }
}</span>

// CreateNotification は通知を作成する
func (a *NotificationAdapter) CreateNotification(ctx context.Context, input notificationInput.CreateNotificationInput) (NotificationDomain, error) <span class="cov0" title="0">{
        notification, err := a.notificationUseCase.CreateNotification(ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // NotificationDomainインターフェースを満たすラッパーを返す
        <span class="cov0" title="0">return &amp;NotificationWrapper{notification: notification}, nil</span>
}

// NotificationWrapper はNotificationDomainインターフェースを実装
type NotificationWrapper struct {
        notification interface {
                GetID() string
                GetUserID() string
                GetTitle() string
        }
}

func (w *NotificationWrapper) GetID() string <span class="cov0" title="0">{
        return w.notification.GetID()
}</span>

func (w *NotificationWrapper) GetUserID() string <span class="cov0" title="0">{
        return w.notification.GetUserID()
}</span>

func (w *NotificationWrapper) GetTitle() string <span class="cov0" title="0">{
        return w.notification.GetTitle()
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package messaging

import (
        "context"
        "fmt"
        "time"

        "github.com/hryt430/Yotei+/internal/modules/notification/usecase/input"
        "github.com/hryt430/Yotei+/internal/modules/task/domain"
        "github.com/hryt430/Yotei+/internal/modules/task/usecase"
        "github.com/hryt430/Yotei+/pkg/logger"
)

// TaskDueNotificationScheduler はタスク期限通知のスケジューラー
type TaskDueNotificationScheduler struct {
        taskService         usecase.TaskService
        notificationService NotificationService
        eventPublisher      *TaskEventPublisher
        logger              logger.Logger
        ticker              *time.Ticker
        stopCh              chan struct{}
        isRunning           bool
}

// NewTaskDueNotificationScheduler は新しいスケジューラーを作成
func NewTaskDueNotificationScheduler(
        taskService usecase.TaskService,
        notificationService NotificationService,
        eventPublisher *TaskEventPublisher,
        logger logger.Logger,
) *TaskDueNotificationScheduler <span class="cov0" title="0">{
        return &amp;TaskDueNotificationScheduler{
                taskService:         taskService,
                notificationService: notificationService,
                eventPublisher:      eventPublisher,
                logger:              logger,
                stopCh:              make(chan struct{}),
        }
}</span>

// Start はスケジューラーを開始（1時間ごとにチェック）
func (s *TaskDueNotificationScheduler) Start(ctx context.Context) <span class="cov0" title="0">{
        if s.isRunning </span><span class="cov0" title="0">{
                s.logger.Warn("Task due notification scheduler already running")
                return
        }</span>

        <span class="cov0" title="0">s.isRunning = true
        s.ticker = time.NewTicker(1 * time.Hour) // 1時間ごとにチェック

        s.logger.Info("Starting task due notification scheduler")

        // 初回実行
        go s.checkAndNotifyDueTasks(ctx)
        go s.checkAndNotifyOverdueTasks(ctx)

        go func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        s.ticker.Stop()
                        s.isRunning = false
                }</span>()

                <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-s.ticker.C:<span class="cov0" title="0">
                                s.checkAndNotifyDueTasks(ctx)
                                s.checkAndNotifyOverdueTasks(ctx)</span>
                        case &lt;-s.stopCh:<span class="cov0" title="0">
                                s.logger.Info("Task due notification scheduler stopped")
                                return</span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                s.logger.Info("Task due notification scheduler stopped due to context cancellation")
                                return</span>
                        }
                }
        }()
}

// checkAndNotifyDueTasks は12時間以内に期限を迎えるタスクをチェックして通知
func (s *TaskDueNotificationScheduler) checkAndNotifyDueTasks(ctx context.Context) <span class="cov0" title="0">{
        s.logger.Info("Checking tasks due within 12 hours")

        now := time.Now()
        twelveHoursLater := now.Add(12 * time.Hour)

        // 期限が12時間以内のタスクを取得
        tasks, err := s.getTasksDueWithin12Hours(ctx, now, twelveHoursLater)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get tasks due within 12 hours", logger.Error(err))
                return
        }</span>

        <span class="cov0" title="0">s.logger.Info("Found tasks due within 12 hours", logger.Any("count", len(tasks)))

        // 各タスクについて通知を作成
        for _, task := range tasks </span><span class="cov0" title="0">{
                if err := s.createDueNotification(ctx, task, now); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to create due notification",
                                logger.Any("taskID", task.ID),
                                logger.Error(err))
                        continue</span>
                }
        }
}

// checkAndNotifyOverdueTasks は期限切れタスクをチェックして通知
func (s *TaskDueNotificationScheduler) checkAndNotifyOverdueTasks(ctx context.Context) <span class="cov0" title="0">{
        s.logger.Info("Checking overdue tasks")

        // 期限切れタスクを取得
        tasks, err := s.taskService.GetOverdueTasks(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get overdue tasks", logger.Error(err))
                return
        }</span>

        <span class="cov0" title="0">s.logger.Info("Found overdue tasks", logger.Any("count", len(tasks)))

        // 各期限切れタスクについて通知を作成
        for _, task := range tasks </span><span class="cov0" title="0">{
                if task.AssigneeID != nil </span><span class="cov0" title="0">{
                        if err := s.eventPublisher.PublishTaskOverdue(ctx, task); err != nil </span><span class="cov0" title="0">{
                                s.logger.Error("Failed to publish task overdue event",
                                        logger.Any("taskID", task.ID),
                                        logger.Error(err))
                                continue</span>
                        }
                }
        }
}

// getTasksDueWithin12Hours は12時間以内に期限を迎えるタスクを取得
func (s *TaskDueNotificationScheduler) getTasksDueWithin12Hours(ctx context.Context, from, to time.Time) ([]*domain.Task, error) <span class="cov0" title="0">{
        // 期限でフィルタリング
        filter := domain.ListFilter{
                DueDateFrom: &amp;from,
                DueDateTo:   &amp;to,
        }

        pagination := domain.Pagination{
                Page:     1,
                PageSize: 1000,
        }

        sortOptions := domain.SortOptions{
                Field:     "due_date",
                Direction: "ASC",
        }

        // 完了していないタスクのみを対象
        tasks, _, err := s.taskService.ListTasks(ctx, filter, pagination, sortOptions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list tasks: %w", err)
        }</span>

        // 完了していない、かつ割り当てられているタスクのみフィルタリング
        <span class="cov0" title="0">var dueTasks []*domain.Task
        for _, task := range tasks </span><span class="cov0" title="0">{
                if task.Status != domain.TaskStatusDone &amp;&amp;
                        task.AssigneeID != nil &amp;&amp;
                        task.DueDate != nil &amp;&amp;
                        s.shouldNotifyForTask(task, from, to) </span><span class="cov0" title="0">{
                        dueTasks = append(dueTasks, task)
                }</span>
        }

        <span class="cov0" title="0">return dueTasks, nil</span>
}

// shouldNotifyForTask はタスクに対して通知すべきかを判断
func (s *TaskDueNotificationScheduler) shouldNotifyForTask(task *domain.Task, from, to time.Time) bool <span class="cov0" title="0">{
        if task.DueDate == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // 12時間以内に期限を迎える
        <span class="cov0" title="0">return task.DueDate.After(from) &amp;&amp; task.DueDate.Before(to)</span>
}

// createDueNotification は期限通知を作成
func (s *TaskDueNotificationScheduler) createDueNotification(ctx context.Context, task *domain.Task, now time.Time) error <span class="cov0" title="0">{
        if task.AssigneeID == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // 期限までの時間を計算
        <span class="cov0" title="0">timeUntilDue := task.DueDate.Sub(now)
        hoursUntilDue := int(timeUntilDue.Hours())

        title := fmt.Sprintf("⏰ タスク期限通知")
        message := fmt.Sprintf(
                "タスク「%s」の期限まであと%d時間です。\n\n期限: %s\n優先度: %s",
                task.Title,
                hoursUntilDue,
                task.DueDate.Format("2006-01-02 15:04"),
                task.Priority,
        )

        metadata := map[string]string{
                "task_id":           task.ID,
                "task_title":        task.Title,
                "due_date":          task.DueDate.Format(time.RFC3339),
                "hours_until":       fmt.Sprintf("%d", hoursUntilDue),
                "priority":          string(task.Priority),
                "notification_type": "task_due_soon",
                "action_url":        fmt.Sprintf("/tasks/%s", task.ID),
        }

        createInput := input.CreateNotificationInput{
                UserID:   *task.AssigneeID,
                Type:     "TASK_DUE_SOON",
                Title:    title,
                Message:  message,
                Metadata: metadata,
                Channels: []string{"app"},
        }

        notification, err := s.notificationService.CreateNotification(ctx, createInput)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create notification: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Created due notification",
                logger.Any("taskID", task.ID),
                logger.Any("notificationID", notification.GetID()),
                logger.Any("assigneeID", *task.AssigneeID))

        return nil</span>
}

// Stop はスケジューラーを停止
func (s *TaskDueNotificationScheduler) Stop() <span class="cov0" title="0">{
        if !s.isRunning </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">close(s.stopCh)
        s.logger.Info("Stopping task due notification scheduler")</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package messaging

import (
        "context"
        "fmt"
        "time"

        "github.com/hryt430/Yotei+/internal/modules/notification/usecase/input"
        "github.com/hryt430/Yotei+/internal/modules/task/domain"
        "github.com/hryt430/Yotei+/pkg/logger"
)

// NotificationService は通知サービスのインターフェース
type NotificationService interface {
        CreateNotification(ctx context.Context, input input.CreateNotificationInput) (NotificationDomain, error)
}

// NotificationDomain は通知ドメインのインターフェース（循環参照回避のため）
type NotificationDomain interface {
        GetID() string
        GetUserID() string
        GetTitle() string
}

// TaskEventPublisher は実際に通知を作成するEventPublisher
type TaskEventPublisher struct {
        notificationService NotificationService
        logger              logger.Logger
}

// NewTaskEventPublisher は新しいTaskEventPublisherを作成
func NewTaskEventPublisher(
        notificationService NotificationService,
        logger logger.Logger,
) *TaskEventPublisher <span class="cov0" title="0">{
        return &amp;TaskEventPublisher{
                notificationService: notificationService,
                logger:              logger,
        }
}</span>

// PublishTaskCreated はタスク作成イベントを発行する
func (p *TaskEventPublisher) PublishTaskCreated(ctx context.Context, task *domain.Task) error <span class="cov0" title="0">{
        p.logger.Info("Publishing task created event", logger.Any("taskID", task.ID))

        // タスク作成者には通知を送らない（自分で作成したため）
        // 将来的にはチーム通知などに拡張可能

        return nil
}</span>

// PublishTaskUpdated はタスク更新イベントを発行する
func (p *TaskEventPublisher) PublishTaskUpdated(ctx context.Context, task *domain.Task) error <span class="cov0" title="0">{
        p.logger.Info("Publishing task updated event", logger.Any("taskID", task.ID))

        // タスクが割り当てられている場合、担当者に更新通知を送信
        if task.AssigneeID != nil &amp;&amp; *task.AssigneeID != task.CreatedBy </span><span class="cov0" title="0">{
                return p.createTaskUpdateNotification(ctx, task)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// PublishTaskDeleted はタスク削除イベントを発行する
func (p *TaskEventPublisher) PublishTaskDeleted(ctx context.Context, taskID string) error <span class="cov0" title="0">{
        p.logger.Info("Publishing task deleted event", logger.Any("taskID", taskID))

        // タスク削除の通知は現在は実装しない
        // 必要に応じて将来実装

        return nil
}</span>

// PublishTaskAssigned はタスク割り当てイベントを発行する
func (p *TaskEventPublisher) PublishTaskAssigned(ctx context.Context, task *domain.Task) error <span class="cov0" title="0">{
        p.logger.Info("Publishing task assigned event", logger.Any("taskID", task.ID))

        if task.AssigneeID == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return p.createTaskAssignedNotification(ctx, task)</span>
}

// PublishTaskCompleted はタスク完了イベントを発行する
func (p *TaskEventPublisher) PublishTaskCompleted(ctx context.Context, task *domain.Task) error <span class="cov0" title="0">{
        p.logger.Info("Publishing task completed event", logger.Any("taskID", task.ID))

        // タスク作成者に完了通知を送信（担当者が異なる場合）
        if task.AssigneeID != nil &amp;&amp; *task.AssigneeID != task.CreatedBy </span><span class="cov0" title="0">{
                return p.createTaskCompletedNotification(ctx, task)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// PublishTaskOverdue はタスク期限切れイベントを発行する
func (p *TaskEventPublisher) PublishTaskOverdue(ctx context.Context, task *domain.Task) error <span class="cov0" title="0">{
        p.logger.Info("Publishing task overdue event", logger.Any("taskID", task.ID))

        if task.AssigneeID == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return p.createTaskOverdueNotification(ctx, task)</span>
}

// createTaskAssignedNotification はタスク割り当て通知を作成
func (p *TaskEventPublisher) createTaskAssignedNotification(ctx context.Context, task *domain.Task) error <span class="cov0" title="0">{
        title := fmt.Sprintf("新しいタスクが割り当てられました")
        message := fmt.Sprintf(
                "タスク「%s」があなたに割り当てられました。\n\n説明: %s\n優先度: %s",
                task.Title,
                task.Description,
                task.Priority,
        )

        if task.DueDate != nil </span><span class="cov0" title="0">{
                message += fmt.Sprintf("\n期限: %s", task.DueDate.Format("2006-01-02 15:04"))
        }</span>

        <span class="cov0" title="0">metadata := map[string]string{
                "task_id":           task.ID,
                "task_title":        task.Title,
                "priority":          string(task.Priority),
                "created_by":        task.CreatedBy,
                "notification_type": "task_assigned",
                "action_url":        fmt.Sprintf("/tasks/%s", task.ID),
        }

        if task.DueDate != nil </span><span class="cov0" title="0">{
                metadata["due_date"] = task.DueDate.Format(time.RFC3339)
        }</span>

        <span class="cov0" title="0">createInput := input.CreateNotificationInput{
                UserID:   *task.AssigneeID,
                Type:     "TASK_ASSIGNED",
                Title:    title,
                Message:  message,
                Metadata: metadata,
                Channels: []string{"app"}, // アプリ内通知
        }

        notification, err := p.notificationService.CreateNotification(ctx, createInput)
        if err != nil </span><span class="cov0" title="0">{
                p.logger.Error("Failed to create task assigned notification",
                        logger.Any("taskID", task.ID),
                        logger.Error(err))
                return fmt.Errorf("failed to create task assigned notification: %w", err)
        }</span>

        <span class="cov0" title="0">p.logger.Info("Task assigned notification created",
                logger.Any("taskID", task.ID),
                logger.Any("notificationID", notification.GetID()),
                logger.Any("assigneeID", *task.AssigneeID))

        return nil</span>
}

// createTaskCompletedNotification はタスク完了通知を作成
func (p *TaskEventPublisher) createTaskCompletedNotification(ctx context.Context, task *domain.Task) error <span class="cov0" title="0">{
        title := fmt.Sprintf("タスクが完了されました")
        message := fmt.Sprintf(
                "タスク「%s」が完了されました。\n\n担当者: %s",
                task.Title,
                *task.AssigneeID, // 実際のプロダクトではユーザー名を取得
        )

        metadata := map[string]string{
                "task_id":           task.ID,
                "task_title":        task.Title,
                "assignee_id":       *task.AssigneeID,
                "completed_at":      time.Now().Format(time.RFC3339),
                "notification_type": "task_completed",
                "action_url":        fmt.Sprintf("/tasks/%s", task.ID),
        }

        createInput := input.CreateNotificationInput{
                UserID:   task.CreatedBy,
                Type:     "TASK_COMPLETED",
                Title:    title,
                Message:  message,
                Metadata: metadata,
                Channels: []string{"app"},
        }

        notification, err := p.notificationService.CreateNotification(ctx, createInput)
        if err != nil </span><span class="cov0" title="0">{
                p.logger.Error("Failed to create task completed notification",
                        logger.Any("taskID", task.ID),
                        logger.Error(err))
                return fmt.Errorf("failed to create task completed notification: %w", err)
        }</span>

        <span class="cov0" title="0">p.logger.Info("Task completed notification created",
                logger.Any("taskID", task.ID),
                logger.Any("notificationID", notification.GetID()),
                logger.Any("createdBy", task.CreatedBy))

        return nil</span>
}

// createTaskUpdateNotification はタスク更新通知を作成
func (p *TaskEventPublisher) createTaskUpdateNotification(ctx context.Context, task *domain.Task) error <span class="cov0" title="0">{
        title := fmt.Sprintf("担当タスクが更新されました")
        message := fmt.Sprintf(
                "あなたが担当するタスク「%s」が更新されました。",
                task.Title,
        )

        metadata := map[string]string{
                "task_id":           task.ID,
                "task_title":        task.Title,
                "updated_by":        task.CreatedBy, // 簡略化、実際は更新者を追跡
                "updated_at":        time.Now().Format(time.RFC3339),
                "notification_type": "task_updated",
                "action_url":        fmt.Sprintf("/tasks/%s", task.ID),
        }

        createInput := input.CreateNotificationInput{
                UserID:   *task.AssigneeID,
                Type:     "TASK_ASSIGNED", // 更新通知も割り当て通知と同じタイプを使用
                Title:    title,
                Message:  message,
                Metadata: metadata,
                Channels: []string{"app"},
        }

        notification, err := p.notificationService.CreateNotification(ctx, createInput)
        if err != nil </span><span class="cov0" title="0">{
                p.logger.Error("Failed to create task update notification",
                        logger.Any("taskID", task.ID),
                        logger.Error(err))
                return fmt.Errorf("failed to create task update notification: %w", err)
        }</span>

        <span class="cov0" title="0">p.logger.Info("Task update notification created",
                logger.Any("taskID", task.ID),
                logger.Any("notificationID", notification.GetID()),
                logger.Any("assigneeID", *task.AssigneeID))

        return nil</span>
}

// createTaskOverdueNotification はタスク期限切れ通知を作成
func (p *TaskEventPublisher) createTaskOverdueNotification(ctx context.Context, task *domain.Task) error <span class="cov0" title="0">{
        title := fmt.Sprintf("⚠️ タスクが期限切れです")
        message := fmt.Sprintf(
                "タスク「%s」の期限が過ぎています。\n\n期限: %s\n優先度: %s",
                task.Title,
                task.DueDate.Format("2006-01-02 15:04"),
                task.Priority,
        )

        metadata := map[string]string{
                "task_id":           task.ID,
                "task_title":        task.Title,
                "due_date":          task.DueDate.Format(time.RFC3339),
                "priority":          string(task.Priority),
                "notification_type": "task_overdue",
                "action_url":        fmt.Sprintf("/tasks/%s", task.ID),
                "urgency":           "high",
        }

        createInput := input.CreateNotificationInput{
                UserID:   *task.AssigneeID,
                Type:     "TASK_DUE_SOON", // 期限切れも期限間近通知と同じタイプ
                Title:    title,
                Message:  message,
                Metadata: metadata,
                Channels: []string{"app"},
        }

        notification, err := p.notificationService.CreateNotification(ctx, createInput)
        if err != nil </span><span class="cov0" title="0">{
                p.logger.Error("Failed to create task overdue notification",
                        logger.Any("taskID", task.ID),
                        logger.Error(err))
                return fmt.Errorf("failed to create task overdue notification: %w", err)
        }</span>

        <span class="cov0" title="0">p.logger.Info("Task overdue notification created",
                logger.Any("taskID", task.ID),
                logger.Any("notificationID", notification.GetID()),
                logger.Any("assigneeID", *task.AssigneeID))

        return nil</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package controller

import (
        "net/http"
        "strconv"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/hryt430/Yotei+/internal/modules/task/domain"
        "github.com/hryt430/Yotei+/internal/modules/task/usecase"
)

// TaskStatsController はタスク統計のHTTPリクエストを処理するコントローラー
type TaskStatsController struct {
        statsService *usecase.TaskStatsService
}

// NewTaskStatsController は新しいTaskStatsControllerを作成する
func NewTaskStatsController(statsService *usecase.TaskStatsService) *TaskStatsController <span class="cov0" title="0">{
        return &amp;TaskStatsController{
                statsService: statsService,
        }
}</span>

// DashboardStatsData はダッシュボード統計のデータ構造
type DashboardStatsData struct {
        TodayStats        *DailyStatsData    `json:"today_stats"`
        WeeklyOverview    *WeeklyStatsData   `json:"weekly_overview"`
        UpcomingWeekTasks *WeeklyPreviewData `json:"upcoming_week_tasks"`
        CategoryBreakdown map[string]int     `json:"category_breakdown"`
        PriorityBreakdown map[string]int     `json:"priority_breakdown"`
        RecentCompletions []TaskSummary      `json:"recent_completions"`
        OverdueTasksCount int                `json:"overdue_tasks_count"`
} // @name DashboardStatsData

// DailyStatsData は日次統計のデータ構造
type DailyStatsData struct {
        Date            string  `json:"date" example:"2024-01-01"`
        TotalTasks      int     `json:"total_tasks" example:"10"`
        CompletedTasks  int     `json:"completed_tasks" example:"7"`
        InProgressTasks int     `json:"in_progress_tasks" example:"2"`
        TodoTasks       int     `json:"todo_tasks" example:"1"`
        OverdueTasks    int     `json:"overdue_tasks" example:"0"`
        CompletionRate  float64 `json:"completion_rate" example:"70.0"`
} // @name DailyStatsData

// WeeklyStatsData は週次統計のデータ構造
type WeeklyStatsData struct {
        WeekStart      string                     `json:"week_start" example:"2024-01-01"`
        WeekEnd        string                     `json:"week_end" example:"2024-01-07"`
        TotalTasks     int                        `json:"total_tasks" example:"50"`
        CompletedTasks int                        `json:"completed_tasks" example:"35"`
        CompletionRate float64                    `json:"completion_rate" example:"70.0"`
        DailyStats     map[string]*DailyStatsData `json:"daily_stats"`
} // @name WeeklyStatsData

// WeeklyPreviewData は今後1週間のタスクプレビュー
type WeeklyPreviewData struct {
        WeekStart    string                       `json:"week_start" example:"2024-01-01"`
        WeekEnd      string                       `json:"week_end" example:"2024-01-07"`
        TotalTasks   int                          `json:"total_tasks" example:"15"`
        DailyPreview map[string]*DailyPreviewData `json:"daily_preview"`
} // @name WeeklyPreviewData

// DailyPreviewData は日次のタスクプレビュー
type DailyPreviewData struct {
        Date       string `json:"date" example:"2024-01-01"`
        TaskCount  int    `json:"task_count" example:"3"`
        HasOverdue bool   `json:"has_overdue" example:"false"`
} // @name DailyPreviewData

// TaskSummary はタスクの要約情報
type TaskSummary struct {
        ID          string `json:"id" example:"123e4567-e89b-12d3-a456-426614174000"`
        Title       string `json:"title" example:"重要なタスク"`
        Status      string `json:"status" example:"DONE"`
        CompletedAt string `json:"completed_at" example:"2024-01-01T12:00:00Z"`
} // @name TaskSummary

// ProgressLevelData は進捗レベル情報
type ProgressLevelData struct {
        Percentage int    `json:"percentage" example:"85"`
        Color      string `json:"color" example:"#22c55e"`
        Label      string `json:"label" example:"良好"`
} // @name ProgressLevelData

// CategoryBreakdownData はカテゴリ別統計
type CategoryBreakdownData struct {
        Count       int    `json:"count" example:"15"`
        DisplayName string `json:"display_name" example:"仕事"`
        Color       string `json:"color" example:"#3b82f6"`
} // @name CategoryBreakdownData

// PriorityBreakdownData は優先度別統計
type PriorityBreakdownData struct {
        Count       int    `json:"count" example:"8"`
        DisplayName string `json:"display_name" example:"高"`
        Color       string `json:"color" example:"#dc2626"`
} // @name PriorityBreakdownData

// DashboardStatsResponse はダッシュボード統計のレスポンス
type DashboardStatsResponse struct {
        Success bool               `json:"success" example:"true"`
        Data    DashboardStatsData `json:"data"`
} // @name DashboardStatsResponse

// DailyStatsResponse は日次統計のレスポンス
type DailyStatsResponse struct {
        Success bool           `json:"success" example:"true"`
        Data    DailyStatsData `json:"data"`
} // @name DailyStatsResponse

// WeeklyStatsResponse は週次統計のレスポンス
type WeeklyStatsResponse struct {
        Success bool            `json:"success" example:"true"`
        Data    WeeklyStatsData `json:"data"`
} // @name WeeklyStatsResponse

// ProgressSummaryResponse は進捗サマリーのレスポンス
type ProgressSummaryResponse struct {
        Success bool             `json:"success" example:"true"`
        Data    []DailyStatsData `json:"data"`
} // @name ProgressSummaryResponse

// ProgressLevelResponse は進捗レベルのレスポンス
type ProgressLevelResponse struct {
        Success bool              `json:"success" example:"true"`
        Data    ProgressLevelData `json:"data"`
} // @name ProgressLevelResponse


// GetDashboardStats ダッシュボード統計取得
// @Summary      ダッシュボード統計取得
// @Description  ダッシュボード表示用の包括的な統計情報を取得します
// @Tags         stats
// @Accept       json
// @Produce      json
// @Security     BearerAuth
// @Success      200 {object} DashboardStatsResponse "ダッシュボード統計取得成功"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /tasks/stats/dashboard [get]
func (c *TaskStatsController) GetDashboardStats(ctx *gin.Context) <span class="cov0" title="0">{
        userID, err := getUserIDFromContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusUnauthorized, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: err.Error(),
        })
                return
        }</span>

        <span class="cov0" title="0">stats, err := c.statsService.GetDashboardStats(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: "Failed to get dashboard stats",
        })
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, DashboardStatsResponse{
                Success: true,
                Data:    *convertDashboardStats(stats),
        })</span>
}

// GetTodayStats 今日の統計取得
// @Summary      今日の統計取得
// @Description  本日のタスク統計情報を取得します
// @Tags         stats
// @Accept       json
// @Produce      json
// @Security     BearerAuth
// @Success      200 {object} DailyStatsResponse "今日の統計取得成功"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /tasks/stats/today [get]
func (c *TaskStatsController) GetTodayStats(ctx *gin.Context) <span class="cov0" title="0">{
        userID, err := getUserIDFromContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusUnauthorized, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: err.Error(),
        })
                return
        }</span>

        <span class="cov0" title="0">today := time.Now()
        stats, err := c.statsService.GetDailyStats(ctx, userID, today)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: "Failed to get today stats",
        })
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, DailyStatsResponse{
                Success: true,
                Data:    *convertDailyStats(stats),
        })</span>
}

// GetDailyStats 指定日の統計取得
// @Summary      指定日の統計取得
// @Description  指定された日付のタスク統計情報を取得します
// @Tags         stats
// @Accept       json
// @Produce      json
// @Param        date path string true "日付(YYYY-MM-DD形式)" example:"2024-01-01"
// @Security     BearerAuth
// @Success      200 {object} DailyStatsResponse "日次統計取得成功"
// @Failure      400 {object} ErrorResponse "日付形式が無効"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /tasks/stats/daily/{date} [get]
func (c *TaskStatsController) GetDailyStats(ctx *gin.Context) <span class="cov0" title="0">{
        userID, err := getUserIDFromContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusUnauthorized, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: err.Error(),
        })
                return
        }</span>

        // 日付パラメータの取得
        <span class="cov0" title="0">dateStr := ctx.Param("date")
        if dateStr == "" </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: "Date parameter is required",
        })
                return
        }</span>

        <span class="cov0" title="0">date, err := time.Parse("2006-01-02", dateStr)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: "Invalid date format. Use YYYY-MM-DD",
        })
                return
        }</span>

        <span class="cov0" title="0">stats, err := c.statsService.GetDailyStats(ctx, userID, date)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: "Failed to get daily stats",
        })
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, DailyStatsResponse{
                Success: true,
                Data:    *convertDailyStats(stats),
        })</span>
}

// GetWeeklyStats 週次統計取得
// @Summary      週次統計取得
// @Description  指定された週のタスク統計情報を取得します
// @Tags         stats
// @Accept       json
// @Produce      json
// @Param        date query string false "基準日付(YYYY-MM-DD形式)" example:"2024-01-01"
// @Security     BearerAuth
// @Success      200 {object} WeeklyStatsResponse "週次統計取得成功"
// @Failure      400 {object} ErrorResponse "日付形式が無効"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /tasks/stats/weekly [get]
func (c *TaskStatsController) GetWeeklyStats(ctx *gin.Context) <span class="cov0" title="0">{
        userID, err := getUserIDFromContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusUnauthorized, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: err.Error(),
        })
                return
        }</span>

        // 日付パラメータの取得（その週に含まれる任意の日付）
        <span class="cov0" title="0">dateStr := ctx.Query("date")
        var date time.Time
        if dateStr != "" </span><span class="cov0" title="0">{
                parsedDate, err := time.Parse("2006-01-02", dateStr)
                if err != nil </span><span class="cov0" title="0">{
                        ctx.JSON(http.StatusBadRequest, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: "Invalid date format. Use YYYY-MM-DD",
        })
                        return
                }</span>
                <span class="cov0" title="0">date = parsedDate</span>
        } else<span class="cov0" title="0"> {
                date = time.Now() // デフォルトは今週
        }</span>

        <span class="cov0" title="0">stats, err := c.statsService.GetWeeklyStats(ctx, userID, date)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: "Failed to get weekly stats",
        })
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, WeeklyStatsResponse{
                Success: true,
                Data:    *convertWeeklyStats(stats),
        })</span>
}

// GetProgressSummary 進捗サマリー取得
// @Summary      進捗サマリー取得
// @Description  指定された日数分の進捗サマリーを取得します
// @Tags         stats
// @Accept       json
// @Produce      json
// @Param        days query int false "対象日数" default(7) minimum(1) maximum(365)
// @Security     BearerAuth
// @Success      200 {object} ProgressSummaryResponse "進捗サマリー取得成功"
// @Failure      400 {object} ErrorResponse "パラメータが無効"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /tasks/stats/progress-summary [get]
func (c *TaskStatsController) GetProgressSummary(ctx *gin.Context) <span class="cov0" title="0">{
        userID, err := getUserIDFromContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusUnauthorized, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: err.Error(),
        })
                return
        }</span>

        // 日数パラメータの取得
        <span class="cov0" title="0">daysStr := ctx.DefaultQuery("days", "7")
        days, err := strconv.Atoi(daysStr)
        if err != nil || days &lt; 1 || days &gt; 365 </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: "Invalid days parameter. Must be between 1 and 365",
        })
                return
        }</span>

        <span class="cov0" title="0">summary, err := c.statsService.GetProgressSummary(ctx, userID, days)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: "Failed to get progress summary",
        })
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, ProgressSummaryResponse{
                Success: true,
                Data:    convertDailyStatsList(summary),
        })</span>
}

// GetProgressLevel 進捗レベル取得
// @Summary      進捗レベル取得
// @Description  完了率に基づく進捗レベル情報を取得します
// @Tags         stats
// @Accept       json
// @Produce      json
// @Param        rate query number true "完了率(0-100)" example:"85.5"
// @Security     BearerAuth
// @Success      200 {object} ProgressLevelResponse "進捗レベル取得成功"
// @Failure      400 {object} ErrorResponse "完了率パラメータが無効"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /tasks/stats/progress-level [get]
func (c *TaskStatsController) GetProgressLevel(ctx *gin.Context) <span class="cov0" title="0">{
        // 完了率パラメータの取得
        rateStr := ctx.Query("rate")
        if rateStr == "" </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: "Completion rate parameter is required",
        })
                return
        }</span>

        <span class="cov0" title="0">rate, err := strconv.ParseFloat(rateStr, 64)
        if err != nil || rate &lt; 0 || rate &gt; 100 </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: "Invalid completion rate. Must be between 0 and 100",
        })
                return
        }</span>

        <span class="cov0" title="0">level := domain.GetProgressLevel(rate)

        ctx.JSON(http.StatusOK, ProgressLevelResponse{
                Success: true,
                Data: ProgressLevelData{
                        Percentage: level.Percentage,
                        Color:      string(level.Color),
                        Label:      level.Label,
                },
        })</span>
}

// GetCategoryBreakdown カテゴリ別統計取得
// @Summary      カテゴリ別統計取得
// @Description  タスクのカテゴリ別内訳統計を取得します
// @Tags         stats
// @Accept       json
// @Produce      json
// @Security     BearerAuth
// @Success      200 {object} object{success=bool,data=object{WORK=CategoryBreakdownData,PERSONAL=CategoryBreakdownData}} "カテゴリ別統計取得成功"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /tasks/stats/category-breakdown [get]
func (c *TaskStatsController) GetCategoryBreakdown(ctx *gin.Context) <span class="cov0" title="0">{
        userID, err := getUserIDFromContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusUnauthorized, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: err.Error(),
        })
                return
        }</span>

        <span class="cov0" title="0">breakdown, err := c.statsService.GetCategoryBreakdown(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: "Failed to get category breakdown",
        })
                return
        }</span>

        // カテゴリ名の日本語変換
        <span class="cov0" title="0">result := make(map[string]interface{})
        for category, count := range breakdown </span><span class="cov0" title="0">{
                result[string(category)] = gin.H{
                        "count":        count,
                        "display_name": category.GetDisplayName(),
                        "color":        getCategoryColor(category),
                }
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    result,
        })</span>
}

// GetPriorityBreakdown 優先度別統計取得
// @Summary      優先度別統計取得
// @Description  タスクの優先度別内訳統計を取得します
// @Tags         stats
// @Accept       json
// @Produce      json
// @Security     BearerAuth
// @Success      200 {object} object{success=bool,data=object{HIGH=PriorityBreakdownData,MEDIUM=PriorityBreakdownData,LOW=PriorityBreakdownData}} "優先度別統計取得成功"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /tasks/stats/priority-breakdown [get]
func (c *TaskStatsController) GetPriorityBreakdown(ctx *gin.Context) <span class="cov0" title="0">{
        userID, err := getUserIDFromContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusUnauthorized, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: err.Error(),
        })
                return
        }</span>

        <span class="cov0" title="0">breakdown, err := c.statsService.GetPriorityBreakdown(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: "Failed to get priority breakdown",
        })
                return
        }</span>

        // 優先度名の日本語変換
        <span class="cov0" title="0">result := make(map[string]interface{})
        for priority, count := range breakdown </span><span class="cov0" title="0">{
                result[string(priority)] = gin.H{
                        "count":        count,
                        "display_name": priority.GetDisplayName(),
                        "color":        getPriorityColor(priority),
                }
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    result,
        })</span>
}

// GetMonthlyStats 月次統計取得
// @Summary      月次統計取得
// @Description  指定された月のタスク統計情報を取得します
// @Tags         stats
// @Accept       json
// @Produce      json
// @Param        year query int false "年" default(2024) minimum(2000) maximum(3000)
// @Param        month query int false "月" default(1) minimum(1) maximum(12)
// @Security     BearerAuth
// @Success      200 {object} WeeklyStatsResponse "月次統計取得成功"
// @Failure      400 {object} ErrorResponse "パラメータが無効"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /tasks/stats/monthly [get]
func (c *TaskStatsController) GetMonthlyStats(ctx *gin.Context) <span class="cov0" title="0">{
        userID, err := getUserIDFromContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusUnauthorized, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: err.Error(),
        })
                return
        }</span>

        // 年月パラメータの取得
        <span class="cov0" title="0">yearStr := ctx.DefaultQuery("year", strconv.Itoa(time.Now().Year()))
        monthStr := ctx.DefaultQuery("month", strconv.Itoa(int(time.Now().Month())))

        year, err := strconv.Atoi(yearStr)
        if err != nil || year &lt; 2000 || year &gt; 3000 </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: "Invalid year parameter",
        })
                return
        }</span>

        <span class="cov0" title="0">monthInt, err := strconv.Atoi(monthStr)
        if err != nil || monthInt &lt; 1 || monthInt &gt; 12 </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: "Invalid month parameter",
        })
                return
        }</span>

        <span class="cov0" title="0">month := time.Month(monthInt)

        stats, err := c.statsService.GetMonthlyStats(ctx, userID, year, month)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: "Failed to get monthly stats",
        })
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, WeeklyStatsResponse{
                Success: true,
                Data:    *convertWeeklyStats(stats),
        })</span>
}

// ヘルパー関数群
func convertDashboardStats(stats *domain.DashboardStats) *DashboardStatsData <span class="cov0" title="0">{
        return &amp;DashboardStatsData{
                TodayStats:        convertDailyStats(stats.TodayStats),
                WeeklyOverview:    convertWeeklyStats(stats.WeeklyOverview),
                UpcomingWeekTasks: convertWeeklyPreview(stats.UpcomingWeekTasks),
                OverdueTasksCount: stats.OverdueTasksCount,
        }
}</span>

func convertDailyStats(stats *domain.DailyStats) *DailyStatsData <span class="cov0" title="0">{
        return &amp;DailyStatsData{
                Date:            stats.Date.Format("2006-01-02"),
                TotalTasks:      stats.TotalTasks,
                CompletedTasks:  stats.CompletedTasks,
                InProgressTasks: stats.InProgressTasks,
                TodoTasks:       stats.TodoTasks,
                OverdueTasks:    stats.OverdueTasks,
                CompletionRate:  stats.CompletionRate,
        }
}</span>

func convertWeeklyStats(stats *domain.WeeklyStats) *WeeklyStatsData <span class="cov0" title="0">{
        dailyStats := make(map[string]*DailyStatsData)
        for key, daily := range stats.DailyStats </span><span class="cov0" title="0">{
                dailyStats[key] = convertDailyStats(daily)
        }</span>

        <span class="cov0" title="0">return &amp;WeeklyStatsData{
                WeekStart:      stats.WeekStart.Format("2006-01-02"),
                WeekEnd:        stats.WeekEnd.Format("2006-01-02"),
                TotalTasks:     stats.TotalTasks,
                CompletedTasks: stats.CompletedTasks,
                CompletionRate: stats.CompletionRate,
                DailyStats:     dailyStats,
        }</span>
}

func convertWeeklyPreview(preview *domain.WeeklyPreview) *WeeklyPreviewData <span class="cov0" title="0">{
        dailyPreview := make(map[string]*DailyPreviewData)
        for key, daily := range preview.DailyPreview </span><span class="cov0" title="0">{
                dailyPreview[key] = &amp;DailyPreviewData{
                        Date:       daily.Date.Format("2006-01-02"),
                        TaskCount:  daily.TaskCount,
                        HasOverdue: daily.HasOverdue,
                }
        }</span>

        <span class="cov0" title="0">return &amp;WeeklyPreviewData{
                WeekStart:    preview.WeekStart.Format("2006-01-02"),
                WeekEnd:      preview.WeekEnd.Format("2006-01-02"),
                TotalTasks:   preview.TotalTasks,
                DailyPreview: dailyPreview,
        }</span>
}

func convertDailyStatsList(statsList []*domain.DailyStats) []DailyStatsData <span class="cov0" title="0">{
        result := make([]DailyStatsData, len(statsList))
        for i, stats := range statsList </span><span class="cov0" title="0">{
                result[i] = *convertDailyStats(stats)
        }</span>
        <span class="cov0" title="0">return result</span>
}

// getCategoryColor はカテゴリの色を取得する
func getCategoryColor(category domain.Category) string <span class="cov0" title="0">{
        colors := map[domain.Category]string{
                domain.CategoryWork:     "#3b82f6", // 青
                domain.CategoryPersonal: "#10b981", // 緑
                domain.CategoryStudy:    "#8b5cf6", // 紫
                domain.CategoryHealth:   "#f59e0b", // 黄
                domain.CategoryShopping: "#ef4444", // 赤
                domain.CategoryOther:    "#6b7280", // グレー
        }
        if color, exists := colors[category]; exists </span><span class="cov0" title="0">{
                return color
        }</span>
        <span class="cov0" title="0">return "#6b7280"</span> // デフォルトはグレー
}

// getPriorityColor は優先度の色を取得する
func getPriorityColor(priority domain.Priority) string <span class="cov0" title="0">{
        colors := map[domain.Priority]string{
                domain.PriorityHigh:   "#dc2626", // 赤
                domain.PriorityMedium: "#eab308", // 黄色
                domain.PriorityLow:    "#22c55e", // 緑
        }
        if color, exists := colors[priority]; exists </span><span class="cov0" title="0">{
                return color
        }</span>
        <span class="cov0" title="0">return "#6b7280"</span> // デフォルトはグレー
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package controller

import (
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "strconv"
        "strings"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/hryt430/Yotei+/internal/modules/task/domain"
        "github.com/hryt430/Yotei+/internal/modules/task/usecase"
)

// TaskController はタスク関連のHTTPリクエストを処理するコントローラー
type TaskController struct {
        taskService usecase.TaskService
}

// NewTaskController は新しいTaskControllerを作成する
func NewTaskController(taskService usecase.TaskService) *TaskController <span class="cov0" title="0">{
        return &amp;TaskController{
                taskService: taskService,
        }
}</span>

// TaskRequest はタスク作成/更新リクエスト
type TaskRequest struct {
        Title       string        `json:"title" binding:"omitempty,min=1" example:"重要なタスク"`
        Description string        `json:"description" example:"タスクの詳細説明"`
        Status      string        `json:"status" binding:"omitempty,oneof=TODO IN_PROGRESS DONE" example:"TODO"`
        Priority    string        `json:"priority" binding:"omitempty,oneof=LOW MEDIUM HIGH" example:"HIGH"`
        Category    string        `json:"category" binding:"omitempty,oneof=WORK PERSONAL STUDY HEALTH SHOPPING OTHER" example:"WORK"`
        AssigneeID  *string       `json:"assignee_id" example:"123e4567-e89b-12d3-a456-426614174000"`
        DueDate     *time.Time `json:"due_date" format:"date-time" example:"2024-12-31T23:59:59Z"`
} // @name TaskRequest

// TaskResponse はタスクレスポンス
type TaskResponse struct {
        ID          string     `json:"id" example:"123e4567-e89b-12d3-a456-426614174000"`
        Title       string     `json:"title" example:"重要なタスク"`
        Description string     `json:"description" example:"タスクの詳細説明"`
        Status      string     `json:"status" example:"TODO"`
        Priority    string     `json:"priority" example:"HIGH"`
        Category    string     `json:"category" example:"WORK"`
        AssigneeID  *string    `json:"assignee_id,omitempty" example:"123e4567-e89b-12d3-a456-426614174000"`
        CreatedBy   string     `json:"created_by" example:"123e4567-e89b-12d3-a456-426614174000"`
        DueDate     *time.Time `json:"due_date,omitempty" example:"2024-12-31T23:59:59Z"`
        IsOverdue   bool       `json:"is_overdue" example:"false"`
        CreatedAt   time.Time  `json:"created_at" example:"2024-01-01T00:00:00Z"`
        UpdatedAt   time.Time  `json:"updated_at" example:"2024-01-01T00:00:00Z"`
} // @name TaskResponse

// TaskCreateResponse はタスク作成レスポンス
type TaskCreateResponse struct {
        Success bool         `json:"success" example:"true"`
        Message string       `json:"message" example:"Task created successfully"`
        Data    TaskResponse `json:"data"`
} // @name TaskCreateResponse

// TaskUpdateResponse はタスク更新レスポンス
type TaskUpdateResponse struct {
        Success bool         `json:"success" example:"true"`
        Message string       `json:"message" example:"Task updated successfully"`
        Data    TaskResponse `json:"data"`
} // @name TaskUpdateResponse

// TaskGetResponse はタスク取得レスポンス
type TaskGetResponse struct {
        Success bool         `json:"success" example:"true"`
        Data    TaskResponse `json:"data"`
} // @name TaskGetResponse

// TaskListResponse はタスク一覧レスポンス
type TaskListResponse struct {
        Success bool `json:"success" example:"true"`
        Data    struct {
                Tasks      []TaskResponse `json:"tasks"`
                TotalCount int            `json:"total_count" example:"50"`
                Page       int            `json:"page" example:"1"`
                PageSize   int            `json:"page_size" example:"10"`
        } `json:"data"`
} // @name TaskListResponse

// TaskDeleteResponse はタスク削除レスポンス
type TaskDeleteResponse struct {
        Success bool   `json:"success" example:"true"`
        Message string `json:"message" example:"Task deleted successfully"`
} // @name TaskDeleteResponse

// AssignTaskRequest はタスク割り当てリクエスト
type AssignTaskRequest struct {
        AssigneeID string `json:"assignee_id" binding:"required" example:"123e4567-e89b-12d3-a456-426614174000"`
} // @name AssignTaskRequest

// ErrorResponse はエラーレスポンス構造体
type ErrorResponse struct {
        Success bool   `json:"success" example:"false"`
        Error   string `json:"error" example:"INVALID_REQUEST"`
        Message string `json:"message" example:"リクエストが無効です"`
} // @name ErrorResponse

// ChangeStatusRequest はステータス変更リクエスト
type ChangeStatusRequest struct {
        Status string `json:"status" binding:"required,oneof=TODO IN_PROGRESS DONE" example:"IN_PROGRESS"`
} // @name ChangeStatusRequest

// FlexibleTime は複数の日付フォーマットに対応するカスタム型
type FlexibleTime struct {
        time.Time
}

// UnmarshalJSON は JSON からの柔軟な日付パース
func (ft *FlexibleTime) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        str := strings.Trim(string(data), "\"")
        if str == "null" || str == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        // 対応フォーマット一覧
        <span class="cov0" title="0">formats := []string{
                time.RFC3339,          // "2024-12-01T15:30:00Z"
                "2006-01-02T15:04:05", // "2024-12-01T15:30:00"
                "2006-01-02 15:04:05", // "2024-12-01 15:30:00"
                "2006-01-02",          // "2024-12-01"
        }

        for _, format := range formats </span><span class="cov0" title="0">{
                if t, err := time.Parse(format, str); err == nil </span><span class="cov0" title="0">{
                        ft.Time = t
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("cannot parse '%s' as valid date format", str)</span>
}

// MarshalJSON は JSON への出力
func (ft FlexibleTime) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(ft.Time.Format(time.RFC3339))
}</span>

// CreateTask タスク作成
// @Summary      タスク作成
// @Description  新しいタスクを作成します
// @Tags         tasks
// @Accept       json
// @Produce      json
// @Param        request body TaskRequest true "タスク作成情報"
// @Security     BearerAuth
// @Success      201 {object} TaskCreateResponse "タスク作成成功"
// @Failure      400 {object} ErrorResponse "リクエストが無効"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /tasks [post]
func (c *TaskController) CreateTask(ctx *gin.Context) <span class="cov0" title="0">{
        var req TaskRequest
        if err := ctx.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: err.Error(),
        })
                return
        }</span>

        // リクエストの検証
        <span class="cov0" title="0">if req.Title == "" </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: "Title is required",
        })
                return
        }</span>

        // ユーザーID取得
        <span class="cov0" title="0">userID, err := getUserIDFromContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusUnauthorized, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: err.Error(),
        })
                return
        }</span>

        // 優先度のデフォルト設定
        <span class="cov0" title="0">priority := domain.PriorityMedium
        if req.Priority != "" </span><span class="cov0" title="0">{
                priority = domain.Priority(req.Priority)
        }</span>

        // タスク作成
        <span class="cov0" title="0">task, err := c.taskService.CreateTaskWithDefaults(
                ctx,
                req.Title,
                req.Description,
                priority,
                userID,
        )
        if err != nil </span><span class="cov0" title="0">{
                handleServiceError(ctx, err)
                return
        }</span>

        <span class="cov0" title="0">if req.DueDate != nil &amp;&amp; !req.DueDate.IsZero() </span><span class="cov0" title="0">{
                dueDate := *req.DueDate
                _, err = c.taskService.UpdateTask(
                        ctx,
                        task.ID,
                        nil, nil, nil, nil, // title, description, status, priority は nil
                        &amp;dueDate,
                )
                if err != nil </span><span class="cov0" title="0">{
                        handleServiceError(ctx, err)
                        return
                }</span>
                // レスポンス用にタスクの期限日を更新
                <span class="cov0" title="0">task.DueDate = &amp;dueDate</span>
        }

        <span class="cov0" title="0">ctx.JSON(http.StatusCreated, gin.H{
                "success": true,
                "message": "Task created successfully",
                "data":    taskToResponse(task),
        })</span>
}

// GetTask タスク取得
// @Summary      タスク取得
// @Description  指定されたIDのタスクを取得します
// @Tags         tasks
// @Accept       json
// @Produce      json
// @Param        id path string true "タスクID" example:"123e4567-e89b-12d3-a456-426614174000"
// @Security     BearerAuth
// @Success      200 {object} TaskGetResponse "タスク取得成功"
// @Failure      400 {object} ErrorResponse "リクエストが無効"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      404 {object} ErrorResponse "タスクが見つからない"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /tasks/{id} [get]
func (c *TaskController) GetTask(ctx *gin.Context) <span class="cov0" title="0">{
        taskID := ctx.Param("id")

        task, err := c.taskService.GetTask(ctx, taskID)
        if err != nil </span><span class="cov0" title="0">{
                handleServiceError(ctx, err)
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    taskToResponse(task),
        })</span>
}

// UpdateTask タスク更新
// @Summary      タスク更新
// @Description  指定されたIDのタスクを更新します
// @Tags         tasks
// @Accept       json
// @Produce      json
// @Param        id path string true "タスクID" example:"123e4567-e89b-12d3-a456-426614174000"
// @Param        request body TaskRequest true "タスク更新情報"
// @Security     BearerAuth
// @Success      200 {object} TaskUpdateResponse "タスク更新成功"
// @Failure      400 {object} ErrorResponse "リクエストが無効"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      404 {object} ErrorResponse "タスクが見つからない"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /tasks/{id} [put]
func (c *TaskController) UpdateTask(ctx *gin.Context) <span class="cov0" title="0">{
        taskID := ctx.Param("id")

        var req TaskRequest
        if err := ctx.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: err.Error(),
        })
                return
        }</span>

        // 更新対象のフィールドを設定
        <span class="cov0" title="0">var title, description *string
        var status *domain.TaskStatus
        var priority *domain.Priority
        var dueDate *time.Time

        if req.Title != "" </span><span class="cov0" title="0">{
                title = &amp;req.Title
        }</span>
        <span class="cov0" title="0">if req.Description != "" </span><span class="cov0" title="0">{
                description = &amp;req.Description
        }</span>
        <span class="cov0" title="0">if req.Status != "" </span><span class="cov0" title="0">{
                s := domain.TaskStatus(req.Status)
                status = &amp;s
        }</span>
        <span class="cov0" title="0">if req.Priority != "" </span><span class="cov0" title="0">{
                p := domain.Priority(req.Priority)
                priority = &amp;p
        }</span>

        <span class="cov0" title="0">if req.DueDate != nil &amp;&amp; !req.DueDate.IsZero() </span><span class="cov0" title="0">{
                dueDate = req.DueDate
        }</span>

        <span class="cov0" title="0">task, err := c.taskService.UpdateTask(
                ctx,
                taskID,
                title,
                description,
                status,
                priority,
                dueDate,
        )
        if err != nil </span><span class="cov0" title="0">{
                handleServiceError(ctx, err)
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Task updated successfully",
                "data":    taskToResponse(task),
        })</span>
}

// DeleteTask タスク削除
// @Summary      タスク削除
// @Description  指定されたIDのタスクを削除します
// @Tags         tasks
// @Accept       json
// @Produce      json
// @Param        id path string true "タスクID" example:"123e4567-e89b-12d3-a456-426614174000"
// @Security     BearerAuth
// @Success      200 {object} TaskDeleteResponse "タスク削除成功"
// @Failure      400 {object} ErrorResponse "リクエストが無効"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      404 {object} ErrorResponse "タスクが見つからない"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /tasks/{id} [delete]
func (c *TaskController) DeleteTask(ctx *gin.Context) <span class="cov0" title="0">{
        taskID := ctx.Param("id")

        err := c.taskService.DeleteTask(ctx, taskID)
        if err != nil </span><span class="cov0" title="0">{
                handleServiceError(ctx, err)
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Task deleted successfully",
        })</span>
}

// ListTasks タスク一覧取得
// @Summary      タスク一覧取得
// @Description  フィルタリング、ページング、ソート機能付きでタスク一覧を取得します
// @Tags         tasks
// @Accept       json
// @Produce      json
// @Param        status query string false "ステータスフィルタ" Enums(TODO,IN_PROGRESS,DONE)
// @Param        priority query string false "優先度フィルタ" Enums(LOW,MEDIUM,HIGH)
// @Param        category query string false "カテゴリフィルタ" Enums(WORK,PERSONAL,STUDY,HEALTH,SHOPPING,OTHER)
// @Param        assignee_id query string false "担当者IDフィルタ" example:"123e4567-e89b-12d3-a456-426614174000"
// @Param        created_by query string false "作成者IDフィルタ" example:"123e4567-e89b-12d3-a456-426614174000"
// @Param        due_date_from query string false "期限日FROM" example:"2024-01-01"
// @Param        due_date_to query string false "期限日TO" example:"2024-12-31"
// @Param        page query int false "ページ番号" default(1) minimum(1)
// @Param        page_size query int false "ページサイズ" default(10) minimum(1) maximum(100)
// @Param        sort_field query string false "ソートフィールド" Enums(created_at,updated_at,title,priority,status,due_date) default(created_at)
// @Param        sort_direction query string false "ソート方向" Enums(ASC,DESC) default(DESC)
// @Security     BearerAuth
// @Success      200 {object} TaskListResponse "タスク一覧取得成功"
// @Failure      400 {object} ErrorResponse "リクエストが無効"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /tasks [get]
func (c *TaskController) ListTasks(ctx *gin.Context) <span class="cov0" title="0">{
        // フィルタリング条件の設定
        filter := parseListFilter(ctx)

        // ページネーション設定
        pagination := parsePagination(ctx)

        // ソート設定
        sortOptions := parseSortOptions(ctx)

        // タスク一覧取得
        tasks, total, err := c.taskService.ListTasks(ctx, filter, pagination, sortOptions)
        if err != nil </span><span class="cov0" title="0">{
                handleServiceError(ctx, err)
                return
        }</span>

        // レスポンス作成
        <span class="cov0" title="0">taskResponses := tasksToResponse(tasks)

        ctx.JSON(http.StatusOK, gin.H{
                "success": true,
                "data": gin.H{
                        "tasks":       taskResponses,
                        "total_count": total,
                        "page":        pagination.Page,
                        "page_size":   pagination.PageSize,
                },
        })</span>
}

// AssignTask タスク割り当て
// @Summary      タスク割り当て
// @Description  指定されたタスクをユーザーに割り当てます
// @Tags         tasks
// @Accept       json
// @Produce      json
// @Param        id path string true "タスクID" example:"123e4567-e89b-12d3-a456-426614174000"
// @Param        request body AssignTaskRequest true "割り当て情報"
// @Security     BearerAuth
// @Success      200 {object} TaskUpdateResponse "タスク割り当て成功"
// @Failure      400 {object} ErrorResponse "リクエストが無効"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      404 {object} ErrorResponse "タスクまたはユーザーが見つからない"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /tasks/{id}/assign [put]
func (c *TaskController) AssignTask(ctx *gin.Context) <span class="cov0" title="0">{
        taskID := ctx.Param("id")

        var req AssignTaskRequest
        if err := ctx.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: err.Error(),
        })
                return
        }</span>

        <span class="cov0" title="0">task, err := c.taskService.AssignTask(ctx, taskID, req.AssigneeID)
        if err != nil </span><span class="cov0" title="0">{
                handleServiceError(ctx, err)
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Task assigned successfully",
                "data":    taskToResponse(task),
        })</span>
}

// ChangeTaskStatus タスクステータス変更
// @Summary      タスクステータス変更
// @Description  指定されたタスクのステータスを変更します
// @Tags         tasks
// @Accept       json
// @Produce      json
// @Param        id path string true "タスクID" example:"123e4567-e89b-12d3-a456-426614174000"
// @Param        request body ChangeStatusRequest true "ステータス変更情報"
// @Security     BearerAuth
// @Success      200 {object} TaskUpdateResponse "ステータス変更成功"
// @Failure      400 {object} ErrorResponse "リクエストが無効"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      404 {object} ErrorResponse "タスクが見つからない"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /tasks/{id}/status [put]
func (c *TaskController) ChangeTaskStatus(ctx *gin.Context) <span class="cov0" title="0">{
        taskID := ctx.Param("id")

        var req ChangeStatusRequest
        if err := ctx.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: err.Error(),
        })
                return
        }</span>

        <span class="cov0" title="0">status := domain.TaskStatus(req.Status)
        task, err := c.taskService.ChangeTaskStatus(ctx, taskID, status)
        if err != nil </span><span class="cov0" title="0">{
                handleServiceError(ctx, err)
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Task status changed successfully",
                "data":    taskToResponse(task),
        })</span>
}

// GetOverdueTasks 期限切れタスク取得
// @Summary      期限切れタスク取得
// @Description  期限が過ぎているタスクの一覧を取得します
// @Tags         tasks
// @Accept       json
// @Produce      json
// @Security     BearerAuth
// @Success      200 {object} TaskListResponse "期限切れタスク取得成功"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /tasks/overdue [get]
func (c *TaskController) GetOverdueTasks(ctx *gin.Context) <span class="cov0" title="0">{
        tasks, err := c.taskService.GetOverdueTasks(ctx)
        if err != nil </span><span class="cov0" title="0">{
                handleServiceError(ctx, err)
                return
        }</span>

        <span class="cov0" title="0">taskResponses := tasksToResponse(tasks)

        ctx.JSON(http.StatusOK, gin.H{
                "success": true,
                "data": gin.H{
                        "tasks": taskResponses,
                        "count": len(taskResponses),
                },
        })</span>
}

// GetMyTasks 自分のタスク取得
// @Summary      自分のタスク取得
// @Description  現在認証されているユーザーに割り当てられたタスクを取得します
// @Tags         tasks
// @Accept       json
// @Produce      json
// @Security     BearerAuth
// @Success      200 {object} TaskListResponse "自分のタスク取得成功"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /tasks/my [get]
func (c *TaskController) GetMyTasks(ctx *gin.Context) <span class="cov0" title="0">{
        userID, err := getUserIDFromContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusUnauthorized, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: err.Error(),
        })
                return
        }</span>

        <span class="cov0" title="0">tasks, err := c.taskService.GetTasksByAssignee(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                handleServiceError(ctx, err)
                return
        }</span>

        <span class="cov0" title="0">taskResponses := tasksToResponse(tasks)

        ctx.JSON(http.StatusOK, gin.H{
                "success": true,
                "data": gin.H{
                        "tasks": taskResponses,
                        "count": len(taskResponses),
                },
        })</span>
}

// GetUserTasks 特定ユーザーのタスク取得
// @Summary      特定ユーザーのタスク取得
// @Description  指定されたユーザーに割り当てられたタスクを取得します
// @Tags         tasks
// @Accept       json
// @Produce      json
// @Param        user_id path string true "ユーザーID" example:"123e4567-e89b-12d3-a456-426614174000"
// @Security     BearerAuth
// @Success      200 {object} TaskListResponse "ユーザータスク取得成功"
// @Failure      400 {object} ErrorResponse "リクエストが無効"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      404 {object} ErrorResponse "ユーザーが見つからない"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /tasks/user/{user_id} [get]
func (c *TaskController) GetUserTasks(ctx *gin.Context) <span class="cov0" title="0">{
        userID := ctx.Param("user_id")

        tasks, err := c.taskService.GetTasksByAssignee(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                handleServiceError(ctx, err)
                return
        }</span>

        <span class="cov0" title="0">taskResponses := tasksToResponse(tasks)

        ctx.JSON(http.StatusOK, gin.H{
                "success": true,
                "data": gin.H{
                        "tasks": taskResponses,
                        "count": len(taskResponses),
                },
        })</span>
}

// SearchTasks タスク検索
// @Summary      タスク検索
// @Description  キーワードでタスクを検索します（タイトルと説明が対象）
// @Tags         tasks
// @Accept       json
// @Produce      json
// @Param        q query string true "検索クエリ" example:"重要"
// @Param        limit query int false "結果の最大数" default(20) minimum(1) maximum(100)
// @Security     BearerAuth
// @Success      200 {object} TaskListResponse "タスク検索成功"
// @Failure      400 {object} ErrorResponse "検索クエリが必要"
// @Failure      401 {object} ErrorResponse "認証が必要"
// @Failure      500 {object} ErrorResponse "内部サーバーエラー"
// @Router       /tasks/search [get]
func (c *TaskController) SearchTasks(ctx *gin.Context) <span class="cov0" title="0">{
        query := ctx.Query("q")
        if query == "" </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: "Search query is required",
        })
                return
        }</span>

        <span class="cov0" title="0">limit := 20
        if limitStr := ctx.Query("limit"); limitStr != "" </span><span class="cov0" title="0">{
                if limitNum, err := strconv.Atoi(limitStr); err == nil &amp;&amp; limitNum &gt; 0 &amp;&amp; limitNum &lt;= 100 </span><span class="cov0" title="0">{
                        limit = limitNum
                }</span>
        }

        // サービス層の SearchTasks メソッドを呼び出し
        <span class="cov0" title="0">tasks, err := c.taskService.SearchTasks(ctx, query, limit)
        if err != nil </span><span class="cov0" title="0">{
                handleServiceError(ctx, err)
                return
        }</span>

        <span class="cov0" title="0">taskResponses := tasksToResponse(tasks)

        ctx.JSON(http.StatusOK, gin.H{
                "success": true,
                "data": gin.H{
                        "tasks": taskResponses,
                        "count": len(taskResponses),
                },
        })</span>
}

// 以下、既存のヘルパー関数たち...

// taskToResponse はドメインモデルからレスポンスモデルに変換する
func taskToResponse(task *domain.Task) TaskResponse <span class="cov0" title="0">{
        return TaskResponse{
                ID:          task.ID,
                Title:       task.Title,
                Description: task.Description,
                Status:      string(task.Status),
                Priority:    string(task.Priority),
                Category:    string(task.Category),
                AssigneeID:  task.AssigneeID,
                CreatedBy:   task.CreatedBy,
                DueDate:     task.DueDate,
                CreatedAt:   task.CreatedAt,
                UpdatedAt:   task.UpdatedAt,
                IsOverdue:   task.CheckIsOverdue(),
        }
}</span>

// tasksToResponse はタスクリストをレスポンス形式に変換する
func tasksToResponse(tasks []*domain.Task) []TaskResponse <span class="cov0" title="0">{
        var taskResponses []TaskResponse
        for _, task := range tasks </span><span class="cov0" title="0">{
                taskResponses = append(taskResponses, taskToResponse(task))
        }</span>
        <span class="cov0" title="0">return taskResponses</span>
}

// getUserIDFromContext は認証済みユーザーIDをコンテキストから取得する
func getUserIDFromContext(ctx *gin.Context) (string, error) <span class="cov0" title="0">{
        userID, exists := ctx.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                return "", errors.New("authentication required")
        }</span>
        <span class="cov0" title="0">return userID.(string), nil</span>
}

// parseListFilter はクエリパラメータからフィルタを解析する
func parseListFilter(ctx *gin.Context) domain.ListFilter <span class="cov0" title="0">{
        var filter domain.ListFilter

        if status := ctx.Query("status"); status != "" </span><span class="cov0" title="0">{
                s := domain.TaskStatus(status)
                filter.Status = &amp;s
        }</span>

        <span class="cov0" title="0">if priority := ctx.Query("priority"); priority != "" </span><span class="cov0" title="0">{
                p := domain.Priority(priority)
                filter.Priority = &amp;p
        }</span>

        <span class="cov0" title="0">if category := ctx.Query("category"); category != "" </span><span class="cov0" title="0">{
                c := domain.Category(category)
                filter.Category = &amp;c
        }</span>

        <span class="cov0" title="0">if assigneeID := ctx.Query("assignee_id"); assigneeID != "" </span><span class="cov0" title="0">{
                filter.AssigneeID = &amp;assigneeID
        }</span>

        <span class="cov0" title="0">if createdBy := ctx.Query("created_by"); createdBy != "" </span><span class="cov0" title="0">{
                filter.CreatedBy = &amp;createdBy
        }</span>

        <span class="cov0" title="0">if dueDateFromStr := ctx.Query("due_date_from"); dueDateFromStr != "" </span><span class="cov0" title="0">{
                ft := &amp;FlexibleTime{}
                if err := ft.UnmarshalJSON([]byte(`"` + dueDateFromStr + `"`)); err == nil </span><span class="cov0" title="0">{
                        filter.DueDateFrom = &amp;ft.Time
                }</span>
        }

        <span class="cov0" title="0">if dueDateToStr := ctx.Query("due_date_to"); dueDateToStr != "" </span><span class="cov0" title="0">{
                ft := &amp;FlexibleTime{}
                if err := ft.UnmarshalJSON([]byte(`"` + dueDateToStr + `"`)); err == nil </span><span class="cov0" title="0">{
                        filter.DueDateTo = &amp;ft.Time
                }</span>
        }

        <span class="cov0" title="0">return filter</span>
}

// parsePagination はクエリパラメータからページネーション情報を解析する
func parsePagination(ctx *gin.Context) domain.Pagination <span class="cov0" title="0">{
        page := 1
        pageSize := 10

        if p := ctx.Query("page"); p != "" </span><span class="cov0" title="0">{
                if pageNum, err := strconv.Atoi(p); err == nil &amp;&amp; pageNum &gt; 0 </span><span class="cov0" title="0">{
                        page = pageNum
                }</span>
        }

        <span class="cov0" title="0">if ps := ctx.Query("page_size"); ps != "" </span><span class="cov0" title="0">{
                if pageSizeNum, err := strconv.Atoi(ps); err == nil &amp;&amp; pageSizeNum &gt; 0 &amp;&amp; pageSizeNum &lt;= 100 </span><span class="cov0" title="0">{
                        pageSize = pageSizeNum
                }</span>
        }

        <span class="cov0" title="0">return domain.Pagination{
                Page:     page,
                PageSize: pageSize,
        }</span>
}

// parseSortOptions はクエリパラメータからソートオプションを解析する
func parseSortOptions(ctx *gin.Context) domain.SortOptions <span class="cov0" title="0">{
        sortField := "created_at"
        sortDirection := "DESC"

        if sf := ctx.Query("sort_field"); sf != "" </span><span class="cov0" title="0">{
                // ソートフィールドのバリデーション
                allowedFields := map[string]bool{
                        "created_at": true,
                        "updated_at": true,
                        "title":      true,
                        "priority":   true,
                        "status":     true,
                        "due_date":   true,
                }
                if allowedFields[sf] </span><span class="cov0" title="0">{
                        sortField = sf
                }</span>
        }

        <span class="cov0" title="0">if sd := ctx.Query("sort_direction"); sd == "ASC" || sd == "DESC" </span><span class="cov0" title="0">{
                sortDirection = sd
        }</span>

        <span class="cov0" title="0">return domain.SortOptions{
                Field:     sortField,
                Direction: sortDirection,
        }</span>
}

// handleServiceError はサービスレイヤーからのエラーを処理する
func handleServiceError(ctx *gin.Context, err error) <span class="cov0" title="0">{
        switch </span>{
        case errors.Is(err, usecase.ErrTaskNotFound):<span class="cov0" title="0">
                ctx.JSON(http.StatusNotFound, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: "Task not found",
        })</span>
        case errors.Is(err, usecase.ErrInvalidParameter):<span class="cov0" title="0">
                ctx.JSON(http.StatusBadRequest, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: "Invalid parameters",
        })</span>
        default:<span class="cov0" title="0">
                ctx.JSON(http.StatusInternalServerError, ErrorResponse{
                Success: false,
                Error:   "REQUEST_ERROR",
                Message: "Internal server error",
        })</span>
        }
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package database

import (
        "context"
        "fmt"
        "time"

        "github.com/hryt430/Yotei+/internal/modules/task/domain"
        "github.com/hryt430/Yotei+/internal/modules/task/usecase"
        "github.com/hryt430/Yotei+/pkg/logger"
)

// TaskStatsRepository はタスク統計情報のデータベースリポジトリ実装
type TaskStatsRepository struct {
        SqlHandler
        logger logger.Logger
}

// NewTaskStatsRepository は新しいTaskStatsRepositoryを作成する
func NewTaskStatsRepository(sqlHandler SqlHandler, logger logger.Logger) usecase.StatsRepository <span class="cov0" title="0">{
        return &amp;TaskStatsRepository{
                SqlHandler: sqlHandler,
                logger:     logger,
        }
}</span>

// GetTasksByDateRange は指定された日付範囲のタスクを取得する
func (r *TaskStatsRepository) GetTasksByDateRange(ctx context.Context, userID string, start, end time.Time) ([]*domain.Task, error) <span class="cov0" title="0">{
        if userID == "" </span><span class="cov0" title="0">{
                return nil, usecase.ErrInvalidParameter
        }</span>

        <span class="cov0" title="0">query := `
                SELECT id, title, description, status, priority, category, assignee_id, created_by, due_date, created_at, updated_at
                FROM ` + "`Yotei-Plus`" + `.tasks
                WHERE (assignee_id = ? OR created_by = ?)
                  AND (
                    (created_at BETWEEN ? AND ?) OR
                    (due_date BETWEEN ? AND ?) OR
                    (updated_at BETWEEN ? AND ?)
                  )
                ORDER BY created_at DESC
        `

        rows, err := r.Query(query, userID, userID, start, end, start, end, start, end)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to get tasks by date range",
                        logger.Any("userID", userID),
                        logger.Any("start", start),
                        logger.Any("end", end),
                        logger.Error(err))
                return nil, fmt.Errorf("failed to query tasks by date range: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if closeErr := rows.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to close rows", logger.Error(closeErr))
                }</span>
        }()

        <span class="cov0" title="0">var tasks []*domain.Task
        for rows.Next() </span><span class="cov0" title="0">{
                task, err := r.scanTaskFromRow(rows)
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to scan task row in date range query", logger.Error(err))
                        return nil, fmt.Errorf("failed to scan task: %w", err)
                }</span>
                <span class="cov0" title="0">tasks = append(tasks, task)</span>
        }

        <span class="cov0" title="0">r.logger.Debug("Tasks retrieved by date range",
                logger.Any("userID", userID),
                logger.Any("count", len(tasks)),
                logger.Any("start", start),
                logger.Any("end", end))

        return tasks, nil</span>
}

// GetTasksByDueDate は指定された期限日のタスクを取得する
func (r *TaskStatsRepository) GetTasksByDueDate(ctx context.Context, userID string, dueDate time.Time) ([]*domain.Task, error) <span class="cov0" title="0">{
        if userID == "" </span><span class="cov0" title="0">{
                return nil, usecase.ErrInvalidParameter
        }</span>

        // 指定日の00:00:00から23:59:59までのタスクを取得
        <span class="cov0" title="0">dayStart := time.Date(dueDate.Year(), dueDate.Month(), dueDate.Day(), 0, 0, 0, 0, dueDate.Location())
        dayEnd := time.Date(dueDate.Year(), dueDate.Month(), dueDate.Day(), 23, 59, 59, 999999999, dueDate.Location())

        query := `
                SELECT id, title, description, status, priority, category, assignee_id, created_by, due_date, created_at, updated_at
                FROM ` + "`Yotei-Plus`" + `.tasks
                WHERE (assignee_id = ? OR created_by = ?)
                  AND due_date BETWEEN ? AND ?
                ORDER BY due_date ASC, priority DESC
        `

        rows, err := r.Query(query, userID, userID, dayStart, dayEnd)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to get tasks by due date",
                        logger.Any("userID", userID),
                        logger.Any("dueDate", dueDate),
                        logger.Error(err))
                return nil, fmt.Errorf("failed to query tasks by due date: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if closeErr := rows.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to close rows", logger.Error(closeErr))
                }</span>
        }()

        <span class="cov0" title="0">var tasks []*domain.Task
        for rows.Next() </span><span class="cov0" title="0">{
                task, err := r.scanTaskFromRow(rows)
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to scan task row in due date query", logger.Error(err))
                        return nil, fmt.Errorf("failed to scan task: %w", err)
                }</span>
                <span class="cov0" title="0">tasks = append(tasks, task)</span>
        }

        <span class="cov0" title="0">r.logger.Debug("Tasks retrieved by due date",
                logger.Any("userID", userID),
                logger.Any("count", len(tasks)),
                logger.Any("dueDate", dueDate))

        return tasks, nil</span>
}

// GetRecentCompletedTasks は最近完了したタスクを取得する
func (r *TaskStatsRepository) GetRecentCompletedTasks(ctx context.Context, userID string, limit int) ([]*domain.Task, error) <span class="cov0" title="0">{
        if userID == "" </span><span class="cov0" title="0">{
                return nil, usecase.ErrInvalidParameter
        }</span>

        <span class="cov0" title="0">if limit &lt;= 0 || limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 10
        }</span>

        <span class="cov0" title="0">query := `
                SELECT id, title, description, status, priority, category, assignee_id, created_by, due_date, created_at, updated_at
                FROM ` + "`Yotei-Plus`" + `.tasks
                WHERE (assignee_id = ? OR created_by = ?)
                  AND status = ?
                ORDER BY updated_at DESC
                LIMIT ?
        `

        rows, err := r.Query(query, userID, userID, string(domain.TaskStatusDone), limit)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to get recent completed tasks",
                        logger.Any("userID", userID),
                        logger.Any("limit", limit),
                        logger.Error(err))
                return nil, fmt.Errorf("failed to query recent completed tasks: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if closeErr := rows.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to close rows", logger.Error(closeErr))
                }</span>
        }()

        <span class="cov0" title="0">var tasks []*domain.Task
        for rows.Next() </span><span class="cov0" title="0">{
                task, err := r.scanTaskFromRow(rows)
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to scan task row in recent completed query", logger.Error(err))
                        return nil, fmt.Errorf("failed to scan task: %w", err)
                }</span>
                <span class="cov0" title="0">tasks = append(tasks, task)</span>
        }

        <span class="cov0" title="0">r.logger.Debug("Recent completed tasks retrieved",
                logger.Any("userID", userID),
                logger.Any("count", len(tasks)))

        return tasks, nil</span>
}

// GetOverdueTasksCount は期限切れタスク数を取得する
func (r *TaskStatsRepository) GetOverdueTasksCount(ctx context.Context, userID string) (int, error) <span class="cov0" title="0">{
        if userID == "" </span><span class="cov0" title="0">{
                return 0, usecase.ErrInvalidParameter
        }</span>

        <span class="cov0" title="0">now := time.Now()

        query := `
                SELECT COUNT(*)
                FROM ` + "`Yotei-Plus`" + `.tasks
                WHERE (assignee_id = ? OR created_by = ?)
                  AND due_date &lt; ?
                  AND status != ?
        `

        row, err := r.Query(query, userID, userID, now, string(domain.TaskStatusDone))
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to get overdue tasks count",
                        logger.Any("userID", userID),
                        logger.Error(err))
                return 0, fmt.Errorf("failed to query overdue tasks count: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if closeErr := row.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to close row", logger.Error(closeErr))
                }</span>
        }()

        <span class="cov0" title="0">var count int
        if row.Next() </span><span class="cov0" title="0">{
                if err := row.Scan(&amp;count); err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to scan overdue count", logger.Error(err))
                        return 0, fmt.Errorf("failed to scan overdue count: %w", err)
                }</span>
        }

        <span class="cov0" title="0">r.logger.Debug("Overdue tasks count retrieved",
                logger.Any("userID", userID),
                logger.Any("count", count))

        return count, nil</span>
}

// GetTasksCountByStatus はステータス別のタスク数を取得する
func (r *TaskStatsRepository) GetTasksCountByStatus(ctx context.Context, userID string, start, end time.Time) (map[domain.TaskStatus]int, error) <span class="cov0" title="0">{
        if userID == "" </span><span class="cov0" title="0">{
                return nil, usecase.ErrInvalidParameter
        }</span>

        <span class="cov0" title="0">query := `
                SELECT status, COUNT(*) as count
                FROM ` + "`Yotei-Plus`" + `.tasks
                WHERE (assignee_id = ? OR created_by = ?)
                  AND created_at BETWEEN ? AND ?
                GROUP BY status
        `

        rows, err := r.Query(query, userID, userID, start, end)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to get tasks count by status",
                        logger.Any("userID", userID),
                        logger.Error(err))
                return nil, fmt.Errorf("failed to query tasks count by status: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if closeErr := rows.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to close rows", logger.Error(closeErr))
                }</span>
        }()

        <span class="cov0" title="0">counts := make(map[domain.TaskStatus]int)
        for rows.Next() </span><span class="cov0" title="0">{
                var status string
                var count int

                if err := rows.Scan(&amp;status, &amp;count); err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to scan status count", logger.Error(err))
                        return nil, fmt.Errorf("failed to scan status count: %w", err)
                }</span>

                <span class="cov0" title="0">counts[domain.TaskStatus(status)] = count</span>
        }

        <span class="cov0" title="0">return counts, nil</span>
}

// GetTasksCountByCategory はカテゴリ別のタスク数を取得する
func (r *TaskStatsRepository) GetTasksCountByCategory(ctx context.Context, userID string, start, end time.Time) (map[domain.Category]int, error) <span class="cov0" title="0">{
        if userID == "" </span><span class="cov0" title="0">{
                return nil, usecase.ErrInvalidParameter
        }</span>

        <span class="cov0" title="0">query := `
                SELECT category, COUNT(*) as count
                FROM ` + "`Yotei-Plus`" + `.tasks
                WHERE (assignee_id = ? OR created_by = ?)
                  AND created_at BETWEEN ? AND ?
                GROUP BY category
        `

        rows, err := r.Query(query, userID, userID, start, end)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to get tasks count by category",
                        logger.Any("userID", userID),
                        logger.Error(err))
                return nil, fmt.Errorf("failed to query tasks count by category: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if closeErr := rows.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to close rows", logger.Error(closeErr))
                }</span>
        }()

        <span class="cov0" title="0">counts := make(map[domain.Category]int)
        for rows.Next() </span><span class="cov0" title="0">{
                var category string
                var count int

                if err := rows.Scan(&amp;category, &amp;count); err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to scan category count", logger.Error(err))
                        return nil, fmt.Errorf("failed to scan category count: %w", err)
                }</span>

                <span class="cov0" title="0">counts[domain.Category(category)] = count</span>
        }

        <span class="cov0" title="0">return counts, nil</span>
}

// GetTasksCountByPriority は優先度別のタスク数を取得する
func (r *TaskStatsRepository) GetTasksCountByPriority(ctx context.Context, userID string) (map[domain.Priority]int, error) <span class="cov0" title="0">{
        if userID == "" </span><span class="cov0" title="0">{
                return nil, usecase.ErrInvalidParameter
        }</span>

        <span class="cov0" title="0">query := `
                SELECT priority, COUNT(*) as count
                FROM ` + "`Yotei-Plus`" + `.tasks
                WHERE (assignee_id = ? OR created_by = ?)
                  AND status != ?
                GROUP BY priority
        `

        rows, err := r.Query(query, userID, userID, string(domain.TaskStatusDone))
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to get tasks count by priority",
                        logger.Any("userID", userID),
                        logger.Error(err))
                return nil, fmt.Errorf("failed to query tasks count by priority: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if closeErr := rows.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to close rows", logger.Error(closeErr))
                }</span>
        }()

        <span class="cov0" title="0">counts := make(map[domain.Priority]int)
        for rows.Next() </span><span class="cov0" title="0">{
                var priority string
                var count int

                if err := rows.Scan(&amp;priority, &amp;count); err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to scan priority count", logger.Error(err))
                        return nil, fmt.Errorf("failed to scan priority count: %w", err)
                }</span>

                <span class="cov0" title="0">counts[domain.Priority(priority)] = count</span>
        }

        <span class="cov0" title="0">return counts, nil</span>
}

// scanTaskFromRow は共通のタスクスキャン処理（TaskRepositoryと重複するが統計用に独立させる）
func (r *TaskStatsRepository) scanTaskFromRow(row Row) (*domain.Task, error) <span class="cov0" title="0">{
        var task domain.Task
        var assigneeID, dueDate, category *string

        err := row.Scan(
                &amp;task.ID,
                &amp;task.Title,
                &amp;task.Description,
                &amp;task.Status,
                &amp;task.Priority,
                &amp;category,
                &amp;assigneeID,
                &amp;task.CreatedBy,
                &amp;dueDate,
                &amp;task.CreatedAt,
                &amp;task.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to scan task row: %w", err)
        }</span>

        // NULL値の安全な処理
        <span class="cov0" title="0">if assigneeID != nil </span><span class="cov0" title="0">{
                task.AssigneeID = assigneeID
        }</span>
        <span class="cov0" title="0">if dueDate != nil </span><span class="cov0" title="0">{
                if parsedDate, err := time.Parse("2006-01-02 15:04:05", *dueDate); err == nil </span><span class="cov0" title="0">{
                        task.DueDate = &amp;parsedDate
                }</span>
        }
        <span class="cov0" title="0">if category != nil </span><span class="cov0" title="0">{
                task.Category = domain.Category(*category)
        }</span> else<span class="cov0" title="0"> {
                task.Category = domain.CategoryOther // デフォルト値
        }</span>

        <span class="cov0" title="0">return &amp;task, nil</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package database

import (
        "context"
        "database/sql"
        "fmt"
        "strings"
        "time"

        "github.com/hryt430/Yotei+/internal/modules/task/domain"
        "github.com/hryt430/Yotei+/internal/modules/task/interface/dto"
        "github.com/hryt430/Yotei+/internal/modules/task/usecase"
        "github.com/hryt430/Yotei+/pkg/logger"
)

// TaskRepository はタスクのデータベースリポジトリ実装（改良版）
type TaskRepository struct {
        SqlHandler
        logger logger.Logger
}

// NewTaskRepository は新しいTaskRepositoryを作成する
func NewTaskRepository(sqlHandler SqlHandler, logger logger.Logger) usecase.TaskRepository <span class="cov0" title="0">{
        return &amp;TaskRepository{
                SqlHandler: sqlHandler,
                logger:     logger,
        }
}</span>

// SQLインジェクション対策：許可されたソートフィールドの定義
var allowedSortFields = map[string]string{
        "created_at": "created_at",
        "updated_at": "updated_at",
        "title":      "title",
        "priority":   "priority",
        "status":     "status",
        "due_date":   "due_date",
}

// SQLインジェクション対策：許可されたフィルタフィールドの定義
var allowedFilterFields = map[string]bool{
        "status":      true,
        "priority":    true,
        "assignee_id": true,
        "created_by":  true,
        "due_date":    true,
}

// CreateTask はタスクを作成する
func (r *TaskRepository) CreateTask(ctx context.Context, task *domain.Task) error <span class="cov0" title="0">{
        query := `
                INSERT INTO ` + "`Yotei-Plus`" + `.tasks (
                        id, title, description, status, priority, assignee_id, created_by, due_date, created_at, updated_at
                ) VALUES (
                        ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
                )
        `

        model := dto.FromDomain(task)
        _, err := r.Execute(query,
                model.ID,
                model.Title,
                model.Description,
                model.Status,
                model.Priority,
                model.AssigneeID,
                model.CreatedBy,
                model.DueDate,
                model.CreatedAt,
                model.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to create task", logger.Any("taskID", task.ID), logger.Error(err))
                return fmt.Errorf("failed to create task: %w", err)
        }</span>

        <span class="cov0" title="0">r.logger.Debug("Task created successfully", logger.Any("taskID", task.ID))
        return nil</span>
}

// GetTaskByID はIDによりタスクを取得する（コネクション管理改善）
func (r *TaskRepository) GetTaskByID(ctx context.Context, id string) (*domain.Task, error) <span class="cov0" title="0">{
        if id == "" </span><span class="cov0" title="0">{
                return nil, usecase.ErrInvalidParameter
        }</span>

        <span class="cov0" title="0">query := `
                SELECT id, title, description, status, priority, assignee_id, created_by, due_date, created_at, updated_at 
                FROM ` + "`Yotei-Plus`" + `.tasks 
                WHERE id = ?
                LIMIT 1
        `

        row, err := r.Query(query, id)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to query task by ID", logger.Any("id", id), logger.Error(err))
                return nil, fmt.Errorf("failed to query task: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if closeErr := row.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to close row", logger.Error(closeErr))
                }</span>
        }()

        <span class="cov0" title="0">if !row.Next() </span><span class="cov0" title="0">{
                return nil, usecase.ErrTaskNotFound
        }</span>

        <span class="cov0" title="0">task, err := r.scanTaskFromRow(row)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to scan task", logger.Any("id", id), logger.Error(err))
                return nil, fmt.Errorf("failed to scan task: %w", err)
        }</span>

        <span class="cov0" title="0">return task, nil</span>
}

// ListTasks はタスク一覧を取得する（SQLインジェクション対策、パフォーマンス改善）
func (r *TaskRepository) ListTasks(
        ctx context.Context,
        filter domain.ListFilter,
        pagination domain.Pagination,
        sort domain.SortOptions,
) ([]*domain.Task, int, error) <span class="cov0" title="0">{
        // 入力値の検証とサニタイズ
        if err := r.validateListParams(filter, pagination, sort); err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // WHERE句とパラメータの構築（SQLインジェクション対策）
        <span class="cov0" title="0">whereClause, args := r.buildWhereClause(filter)

        // カウント取得（パフォーマンス改善：インデックス使用）
        total, err := r.getTaskCount(ctx, whereClause, args)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">if total == 0 </span><span class="cov0" title="0">{
                return []*domain.Task{}, 0, nil
        }</span>

        // ソートフィールドとディレクションの検証
        <span class="cov0" title="0">sortField := r.validateSortField(sort.Field)
        sortDirection := r.validateSortDirection(sort.Direction)

        // メインクエリ（パフォーマンス改善：必要なカラムのみ選択）
        query := fmt.Sprintf(`
                SELECT id, title, description, status, priority, assignee_id, created_by, due_date, created_at, updated_at
                FROM `+"`Yotei-Plus`"+`.tasks
                %s
                ORDER BY %s %s
                LIMIT ? OFFSET ?
        `, whereClause, sortField, sortDirection)

        // ページネーション用のパラメータを追加
        offset := (pagination.Page - 1) * pagination.PageSize
        args = append(args, pagination.PageSize, offset)

        rows, err := r.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to list tasks", logger.Error(err))
                return nil, 0, fmt.Errorf("failed to list tasks: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if closeErr := rows.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to close rows", logger.Error(closeErr))
                }</span>
        }()

        <span class="cov0" title="0">var tasks []*domain.Task
        for rows.Next() </span><span class="cov0" title="0">{
                task, err := r.scanTaskFromRow(rows)
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to scan task row", logger.Error(err))
                        return nil, 0, fmt.Errorf("failed to scan task: %w", err)
                }</span>
                <span class="cov0" title="0">tasks = append(tasks, task)</span>
        }

        <span class="cov0" title="0">r.logger.Debug("Tasks listed successfully",
                logger.Any("count", len(tasks)),
                logger.Any("total", total))

        return tasks, total, nil</span>
}

// SearchTasks はタスクを検索する（SQLインジェクション対策、パフォーマンス改善）
func (r *TaskRepository) SearchTasks(ctx context.Context, query string, limit int) ([]*domain.Task, error) <span class="cov0" title="0">{
        // 入力値のサニタイズ
        query = strings.TrimSpace(query)
        if query == "" </span><span class="cov0" title="0">{
                return []*domain.Task{}, nil
        }</span>

        // リミットの検証
        <span class="cov0" title="0">if limit &lt;= 0 || limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 20
        }</span>

        // FULLTEXT検索またはLIKE検索（パフォーマンス改善）
        // 本来はFULLTEXTのインデックスを使用するのが理想
        <span class="cov0" title="0">sqlQuery := `
                SELECT id, title, description, status, priority, assignee_id, created_by, due_date, created_at, updated_at
                FROM ` + "`Yotei-Plus`" + `.tasks
                WHERE (title LIKE ? OR description LIKE ?)
                ORDER BY 
                        CASE 
                                WHEN title LIKE ? THEN 1 
                                WHEN description LIKE ? THEN 2 
                                ELSE 3 
                        END,
                        created_at DESC
                LIMIT ?
        `

        // ワイルドカードパターンの構築（SQLインジェクション対策）
        pattern := "%" + r.escapeLikePattern(query) + "%"
        exactPattern := r.escapeLikePattern(query) + "%"

        rows, err := r.Query(sqlQuery, pattern, pattern, exactPattern, exactPattern, limit)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to search tasks", logger.Any("query", query), logger.Error(err))
                return nil, fmt.Errorf("failed to search tasks: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if closeErr := rows.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to close rows", logger.Error(closeErr))
                }</span>
        }()

        <span class="cov0" title="0">var tasks []*domain.Task
        for rows.Next() </span><span class="cov0" title="0">{
                task, err := r.scanTaskFromRow(rows)
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to scan task in search", logger.Error(err))
                        return nil, fmt.Errorf("failed to scan task: %w", err)
                }</span>
                <span class="cov0" title="0">tasks = append(tasks, task)</span>
        }

        <span class="cov0" title="0">r.logger.Debug("Task search completed",
                logger.Any("query", query),
                logger.Any("resultCount", len(tasks)))

        return tasks, nil</span>
}

// GetOverdueTasks は期限切れのタスクを取得（大量データ対策）
func (r *TaskRepository) GetOverdueTasks(ctx context.Context) ([]*domain.Task, error) <span class="cov0" title="0">{
        // 大量データ対策：期限を制限（例：過去30日以内）
        thirtyDaysAgo := time.Now().AddDate(0, 0, -30)
        now := time.Now()
        doneStatus := string(domain.TaskStatusDone)

        query := `
                SELECT id, title, description, status, priority, assignee_id, created_by, due_date, created_at, updated_at
                FROM ` + "`Yotei-Plus`" + `.tasks
                WHERE due_date &lt; ? 
                  AND due_date &gt;= ?
                  AND status != ?
                ORDER BY due_date ASC
                LIMIT 1000
        `

        rows, err := r.Query(query, now, thirtyDaysAgo, doneStatus)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to get overdue tasks", logger.Error(err))
                return nil, fmt.Errorf("failed to get overdue tasks: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if closeErr := rows.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to close rows", logger.Error(closeErr))
                }</span>
        }()

        <span class="cov0" title="0">var tasks []*domain.Task
        for rows.Next() </span><span class="cov0" title="0">{
                task, err := r.scanTaskFromRow(rows)
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to scan overdue task", logger.Error(err))
                        return nil, fmt.Errorf("failed to scan task: %w", err)
                }</span>
                <span class="cov0" title="0">tasks = append(tasks, task)</span>
        }

        <span class="cov0" title="0">r.logger.Debug("Overdue tasks retrieved", logger.Any("count", len(tasks)))
        return tasks, nil</span>
}

// GetTasksByAssignee は特定のユーザーに割り当てられたタスクを取得（パフォーマンス改善）
func (r *TaskRepository) GetTasksByAssignee(ctx context.Context, userID string) ([]*domain.Task, error) <span class="cov0" title="0">{
        if userID == "" </span><span class="cov0" title="0">{
                return nil, usecase.ErrInvalidParameter
        }</span>

        // パフォーマンス改善：インデックス利用、大量データ対策
        <span class="cov0" title="0">query := `
                SELECT id, title, description, status, priority, assignee_id, created_by, due_date, created_at, updated_at
                FROM ` + "`Yotei-Plus`" + `.tasks
                WHERE assignee_id = ?
                ORDER BY 
                        CASE status 
                                WHEN 'TODO' THEN 1 
                                WHEN 'IN_PROGRESS' THEN 2 
                                WHEN 'DONE' THEN 3 
                                ELSE 4 
                        END,
                        due_date ASC NULLS LAST,
                        created_at DESC
                LIMIT 500
        `

        rows, err := r.Query(query, userID)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to get tasks by assignee", logger.Any("userID", userID), logger.Error(err))
                return nil, fmt.Errorf("failed to get tasks by assignee: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if closeErr := rows.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to close rows", logger.Error(closeErr))
                }</span>
        }()

        <span class="cov0" title="0">var tasks []*domain.Task
        for rows.Next() </span><span class="cov0" title="0">{
                task, err := r.scanTaskFromRow(rows)
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to scan assignee task", logger.Error(err))
                        return nil, fmt.Errorf("failed to scan task: %w", err)
                }</span>
                <span class="cov0" title="0">tasks = append(tasks, task)</span>
        }

        <span class="cov0" title="0">r.logger.Debug("Tasks by assignee retrieved",
                logger.Any("userID", userID),
                logger.Any("count", len(tasks)))

        return tasks, nil</span>
}

// UpdateTask はタスクを更新する（コネクション管理改善）
func (r *TaskRepository) UpdateTask(ctx context.Context, task *domain.Task) error <span class="cov0" title="0">{
        query := `
                UPDATE ` + "`Yotei-Plus`" + `.tasks SET
                        title = ?,
                        description = ?,
                        status = ?,
                        priority = ?,
                        assignee_id = ?,
                        due_date = ?,
                        updated_at = ?
                WHERE id = ?
        `

        model := dto.FromDomain(task)
        result, err := r.Execute(query,
                model.Title,
                model.Description,
                model.Status,
                model.Priority,
                model.AssigneeID,
                model.DueDate,
                model.UpdatedAt,
                model.ID,
        )
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to update task", logger.Any("taskID", task.ID), logger.Error(err))
                return fmt.Errorf("failed to update task: %w", err)
        }</span>

        <span class="cov0" title="0">affected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to get rows affected", logger.Error(err))
                return fmt.Errorf("failed to get affected rows: %w", err)
        }</span>

        <span class="cov0" title="0">if affected == 0 </span><span class="cov0" title="0">{
                return usecase.ErrTaskNotFound
        }</span>

        <span class="cov0" title="0">r.logger.Debug("Task updated successfully", logger.Any("taskID", task.ID))
        return nil</span>
}

// DeleteTask はタスクを削除する（物理削除）
func (r *TaskRepository) DeleteTask(ctx context.Context, id string) error <span class="cov0" title="0">{
        if id == "" </span><span class="cov0" title="0">{
                return usecase.ErrInvalidParameter
        }</span>

        <span class="cov0" title="0">query := `DELETE FROM ` + "`Yotei-Plus`" + `.tasks WHERE id = ?`

        result, err := r.Execute(query, id)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to delete task", logger.Any("taskID", id), logger.Error(err))
                return fmt.Errorf("failed to delete task: %w", err)
        }</span>

        <span class="cov0" title="0">affected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to get rows affected", logger.Error(err))
                return fmt.Errorf("failed to get affected rows: %w", err)
        }</span>

        <span class="cov0" title="0">if affected == 0 </span><span class="cov0" title="0">{
                return usecase.ErrTaskNotFound
        }</span>

        <span class="cov0" title="0">r.logger.Debug("Task deleted successfully", logger.Any("taskID", id))
        return nil</span>
}

// バリデーションと補助メソッド

func (r *TaskRepository) validateListParams(filter domain.ListFilter, pagination domain.Pagination, sort domain.SortOptions) error <span class="cov0" title="0">{
        // ページネーションの検証
        if pagination.Page &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid page number: %d", pagination.Page)
        }</span>
        <span class="cov0" title="0">if pagination.PageSize &lt;= 0 || pagination.PageSize &gt; 100 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid page size: %d (must be 1-100)", pagination.PageSize)
        }</span>

        // ソートフィールドの検証
        <span class="cov0" title="0">if sort.Field != "" &amp;&amp; allowedSortFields[sort.Field] == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid sort field: %s", sort.Field)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *TaskRepository) buildWhereClause(filter domain.ListFilter) (string, []interface{}) <span class="cov0" title="0">{
        var conds []string
        var args []interface{}

        if filter.Status != nil </span><span class="cov0" title="0">{
                conds = append(conds, "status = ?")
                args = append(args, string(*filter.Status))
        }</span>
        <span class="cov0" title="0">if filter.Priority != nil </span><span class="cov0" title="0">{
                conds = append(conds, "priority = ?")
                args = append(args, string(*filter.Priority))
        }</span>
        <span class="cov0" title="0">if filter.AssigneeID != nil </span><span class="cov0" title="0">{
                conds = append(conds, "assignee_id = ?")
                args = append(args, *filter.AssigneeID)
        }</span>
        <span class="cov0" title="0">if filter.CreatedBy != nil </span><span class="cov0" title="0">{
                conds = append(conds, "created_by = ?")
                args = append(args, *filter.CreatedBy)
        }</span>
        <span class="cov0" title="0">if filter.DueDateFrom != nil </span><span class="cov0" title="0">{
                conds = append(conds, "due_date &gt;= ?")
                args = append(args, *filter.DueDateFrom)
        }</span>
        <span class="cov0" title="0">if filter.DueDateTo != nil </span><span class="cov0" title="0">{
                conds = append(conds, "due_date &lt;= ?")
                args = append(args, *filter.DueDateTo)
        }</span>

        <span class="cov0" title="0">whereClause := ""
        if len(conds) &gt; 0 </span><span class="cov0" title="0">{
                whereClause = "WHERE " + strings.Join(conds, " AND ")
        }</span>

        <span class="cov0" title="0">return whereClause, args</span>
}

func (r *TaskRepository) validateSortField(field string) string <span class="cov0" title="0">{
        if validField, exists := allowedSortFields[field]; exists </span><span class="cov0" title="0">{
                return validField
        }</span>
        <span class="cov0" title="0">return "created_at"</span> // デフォルト
}

func (r *TaskRepository) validateSortDirection(direction string) string <span class="cov0" title="0">{
        if direction == "ASC" || direction == "DESC" </span><span class="cov0" title="0">{
                return direction
        }</span>
        <span class="cov0" title="0">return "DESC"</span> // デフォルト
}

// escapeLikePattern はLIKE演算子のワイルドカードをエスケープ（SQLインジェクション対策）
func (r *TaskRepository) escapeLikePattern(pattern string) string <span class="cov0" title="0">{
        // MySQL/MariaDBの場合のエスケープ
        pattern = strings.ReplaceAll(pattern, "\\", "\\\\")
        pattern = strings.ReplaceAll(pattern, "%", "\\%")
        pattern = strings.ReplaceAll(pattern, "_", "\\_")
        return pattern
}</span>

// scanTaskFromRow はRowからTaskをスキャンする共通処理（改善版）
func (r *TaskRepository) scanTaskFromRow(row Row) (*domain.Task, error) <span class="cov0" title="0">{
        var m dto.TaskModel
        var assigneeID sql.NullString
        var dueDate sql.NullTime

        err := row.Scan(
                &amp;m.ID,
                &amp;m.Title,
                &amp;m.Description,
                &amp;m.Status,
                &amp;m.Priority,
                &amp;assigneeID,
                &amp;m.CreatedBy,
                &amp;dueDate,
                &amp;m.CreatedAt,
                &amp;m.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to scan row: %w", err)
        }</span>

        // NULL値の安全な処理
        <span class="cov0" title="0">if assigneeID.Valid </span><span class="cov0" title="0">{
                id := assigneeID.String
                m.AssigneeID = &amp;id
        }</span>
        <span class="cov0" title="0">if dueDate.Valid </span><span class="cov0" title="0">{
                d := dueDate.Time
                m.DueDate = &amp;d
        }</span>

        <span class="cov0" title="0">return m.ToDomain(), nil</span>
}

// getTaskCount はタスクの総数を取得する（パフォーマンス改善）
func (r *TaskRepository) getTaskCount(ctx context.Context, whereClause string, args []interface{}) (int, error) <span class="cov0" title="0">{
        countQuery := fmt.Sprintf("SELECT COUNT(*) FROM "+"`Yotei-Plus`"+".tasks %s", whereClause)

        row, err := r.Query(countQuery, args...)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to count tasks", logger.Error(err))
                return 0, fmt.Errorf("failed to count tasks: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if closeErr := row.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to close count row", logger.Error(closeErr))
                }</span>
        }()

        <span class="cov0" title="0">var count int
        if row.Next() </span><span class="cov0" title="0">{
                if err := row.Scan(&amp;count); err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to scan count", logger.Error(err))
                        return 0, fmt.Errorf("failed to scan count: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return count, nil</span>
}

// GetTasksForNotification は通知用のタスク取得（効率的なクエリ）
func (r *TaskRepository) GetTasksForNotification(ctx context.Context, from, to time.Time) ([]*domain.Task, error) <span class="cov0" title="0">{
        // 期限が近いアサイン済みタスクのみを効率的に取得
        query := `
                SELECT id, title, description, status, priority, assignee_id, created_by, due_date, created_at, updated_at
                FROM ` + "`Yotei-Plus`" + `.tasks
                WHERE due_date BETWEEN ? AND ?
                  AND assignee_id IS NOT NULL
                  AND status IN ('TODO', 'IN_PROGRESS')
                ORDER BY due_date ASC
                LIMIT 1000
        `

        rows, err := r.Query(query, from, to)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to get tasks for notification", logger.Error(err))
                return nil, fmt.Errorf("failed to get tasks for notification: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if closeErr := rows.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to close rows", logger.Error(closeErr))
                }</span>
        }()

        <span class="cov0" title="0">var tasks []*domain.Task
        for rows.Next() </span><span class="cov0" title="0">{
                task, err := r.scanTaskFromRow(rows)
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to scan notification task", logger.Error(err))
                        return nil, fmt.Errorf("failed to scan task: %w", err)
                }</span>
                <span class="cov0" title="0">tasks = append(tasks, task)</span>
        }

        <span class="cov0" title="0">r.logger.Debug("Tasks for notification retrieved", logger.Any("count", len(tasks)))
        return tasks, nil</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package dto

import (
        "time"

        "github.com/hryt430/Yotei+/internal/modules/task/domain"
)

// TaskModel はPostgreSQLのタスクテーブルにマッピングするための構造体
type TaskModel struct {
        ID          string     `db:"id"`
        Title       string     `db:"title"`
        Description string     `db:"description"`
        Status      string     `db:"status"`
        Priority    string     `db:"priority"`
        AssigneeID  *string    `db:"assignee_id"`
        CreatedBy   string     `db:"created_by"`
        DueDate     *time.Time `db:"due_date"`
        CreatedAt   time.Time  `db:"created_at"`
        UpdatedAt   time.Time  `db:"updated_at"`
}

// ToDomain はモデルをドメインエンティティに変換する
func (m *TaskModel) ToDomain() *domain.Task <span class="cov0" title="0">{
        return &amp;domain.Task{
                ID:          m.ID,
                Title:       m.Title,
                Description: m.Description,
                Status:      domain.TaskStatus(m.Status),
                Priority:    domain.Priority(m.Priority),
                AssigneeID:  m.AssigneeID,
                CreatedBy:   m.CreatedBy,
                DueDate:     m.DueDate,
                CreatedAt:   m.CreatedAt,
                UpdatedAt:   m.UpdatedAt,
        }
}</span>

// FromDomain はドメインエンティティからモデルを作成する
func FromDomain(task *domain.Task) *TaskModel <span class="cov0" title="0">{
        return &amp;TaskModel{
                ID:          task.ID,
                Title:       task.Title,
                Description: task.Description,
                Status:      string(task.Status),
                Priority:    string(task.Priority),
                AssigneeID:  task.AssigneeID,
                CreatedBy:   task.CreatedBy,
                DueDate:     task.DueDate,
                CreatedAt:   task.CreatedAt,
                UpdatedAt:   task.UpdatedAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file65" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: stats_service.go

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"
        time "time"

        gomock "github.com/golang/mock/gomock"
        domain "github.com/hryt430/Yotei+/internal/modules/task/domain"
)

// MockStatsRepository is a mock of StatsRepository interface.
type MockStatsRepository struct {
        ctrl     *gomock.Controller
        recorder *MockStatsRepositoryMockRecorder
}

// MockStatsRepositoryMockRecorder is the mock recorder for MockStatsRepository.
type MockStatsRepositoryMockRecorder struct {
        mock *MockStatsRepository
}

// NewMockStatsRepository creates a new mock instance.
func NewMockStatsRepository(ctrl *gomock.Controller) *MockStatsRepository <span class="cov0" title="0">{
        mock := &amp;MockStatsRepository{ctrl: ctrl}
        mock.recorder = &amp;MockStatsRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStatsRepository) EXPECT() *MockStatsRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetOverdueTasksCount mocks base method.
func (m *MockStatsRepository) GetOverdueTasksCount(ctx context.Context, userID string) (int, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetOverdueTasksCount", ctx, userID)
        ret0, _ := ret[0].(int)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetOverdueTasksCount indicates an expected call of GetOverdueTasksCount.
func (mr *MockStatsRepositoryMockRecorder) GetOverdueTasksCount(ctx, userID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetOverdueTasksCount", reflect.TypeOf((*MockStatsRepository)(nil).GetOverdueTasksCount), ctx, userID)
}</span>

// GetRecentCompletedTasks mocks base method.
func (m *MockStatsRepository) GetRecentCompletedTasks(ctx context.Context, userID string, limit int) ([]*domain.Task, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetRecentCompletedTasks", ctx, userID, limit)
        ret0, _ := ret[0].([]*domain.Task)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetRecentCompletedTasks indicates an expected call of GetRecentCompletedTasks.
func (mr *MockStatsRepositoryMockRecorder) GetRecentCompletedTasks(ctx, userID, limit interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRecentCompletedTasks", reflect.TypeOf((*MockStatsRepository)(nil).GetRecentCompletedTasks), ctx, userID, limit)
}</span>

// GetTasksByDateRange mocks base method.
func (m *MockStatsRepository) GetTasksByDateRange(ctx context.Context, userID string, start, end time.Time) ([]*domain.Task, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetTasksByDateRange", ctx, userID, start, end)
        ret0, _ := ret[0].([]*domain.Task)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetTasksByDateRange indicates an expected call of GetTasksByDateRange.
func (mr *MockStatsRepositoryMockRecorder) GetTasksByDateRange(ctx, userID, start, end interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTasksByDateRange", reflect.TypeOf((*MockStatsRepository)(nil).GetTasksByDateRange), ctx, userID, start, end)
}</span>

// GetTasksByDueDate mocks base method.
func (m *MockStatsRepository) GetTasksByDueDate(ctx context.Context, userID string, dueDate time.Time) ([]*domain.Task, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetTasksByDueDate", ctx, userID, dueDate)
        ret0, _ := ret[0].([]*domain.Task)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetTasksByDueDate indicates an expected call of GetTasksByDueDate.
func (mr *MockStatsRepositoryMockRecorder) GetTasksByDueDate(ctx, userID, dueDate interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTasksByDueDate", reflect.TypeOf((*MockStatsRepository)(nil).GetTasksByDueDate), ctx, userID, dueDate)
}</pre>
		
		<pre class="file" id="file66" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: repository.go

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        domain "github.com/hryt430/Yotei+/internal/modules/task/domain"
)

// MockTaskRepository is a mock of TaskRepository interface.
type MockTaskRepository struct {
        ctrl     *gomock.Controller
        recorder *MockTaskRepositoryMockRecorder
}

// MockTaskRepositoryMockRecorder is the mock recorder for MockTaskRepository.
type MockTaskRepositoryMockRecorder struct {
        mock *MockTaskRepository
}

// NewMockTaskRepository creates a new mock instance.
func NewMockTaskRepository(ctrl *gomock.Controller) *MockTaskRepository <span class="cov0" title="0">{
        mock := &amp;MockTaskRepository{ctrl: ctrl}
        mock.recorder = &amp;MockTaskRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTaskRepository) EXPECT() *MockTaskRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateTask mocks base method.
func (m *MockTaskRepository) CreateTask(ctx context.Context, task *domain.Task) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateTask", ctx, task)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CreateTask indicates an expected call of CreateTask.
func (mr *MockTaskRepositoryMockRecorder) CreateTask(ctx, task interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateTask", reflect.TypeOf((*MockTaskRepository)(nil).CreateTask), ctx, task)
}</span>

// DeleteTask mocks base method.
func (m *MockTaskRepository) DeleteTask(ctx context.Context, id string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteTask", ctx, id)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteTask indicates an expected call of DeleteTask.
func (mr *MockTaskRepositoryMockRecorder) DeleteTask(ctx, id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteTask", reflect.TypeOf((*MockTaskRepository)(nil).DeleteTask), ctx, id)
}</span>

// GetOverdueTasks mocks base method.
func (m *MockTaskRepository) GetOverdueTasks(ctx context.Context) ([]*domain.Task, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetOverdueTasks", ctx)
        ret0, _ := ret[0].([]*domain.Task)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetOverdueTasks indicates an expected call of GetOverdueTasks.
func (mr *MockTaskRepositoryMockRecorder) GetOverdueTasks(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetOverdueTasks", reflect.TypeOf((*MockTaskRepository)(nil).GetOverdueTasks), ctx)
}</span>

// GetTaskByID mocks base method.
func (m *MockTaskRepository) GetTaskByID(ctx context.Context, id string) (*domain.Task, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetTaskByID", ctx, id)
        ret0, _ := ret[0].(*domain.Task)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetTaskByID indicates an expected call of GetTaskByID.
func (mr *MockTaskRepositoryMockRecorder) GetTaskByID(ctx, id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTaskByID", reflect.TypeOf((*MockTaskRepository)(nil).GetTaskByID), ctx, id)
}</span>

// GetTasksByAssignee mocks base method.
func (m *MockTaskRepository) GetTasksByAssignee(ctx context.Context, userID string) ([]*domain.Task, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetTasksByAssignee", ctx, userID)
        ret0, _ := ret[0].([]*domain.Task)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetTasksByAssignee indicates an expected call of GetTasksByAssignee.
func (mr *MockTaskRepositoryMockRecorder) GetTasksByAssignee(ctx, userID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTasksByAssignee", reflect.TypeOf((*MockTaskRepository)(nil).GetTasksByAssignee), ctx, userID)
}</span>

// ListTasks mocks base method.
func (m *MockTaskRepository) ListTasks(ctx context.Context, filter domain.ListFilter, pagination domain.Pagination, sortOptions domain.SortOptions) ([]*domain.Task, int, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListTasks", ctx, filter, pagination, sortOptions)
        ret0, _ := ret[0].([]*domain.Task)
        ret1, _ := ret[1].(int)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// ListTasks indicates an expected call of ListTasks.
func (mr *MockTaskRepositoryMockRecorder) ListTasks(ctx, filter, pagination, sortOptions interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListTasks", reflect.TypeOf((*MockTaskRepository)(nil).ListTasks), ctx, filter, pagination, sortOptions)
}</span>

// SearchTasks mocks base method.
func (m *MockTaskRepository) SearchTasks(ctx context.Context, query string, limit int) ([]*domain.Task, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SearchTasks", ctx, query, limit)
        ret0, _ := ret[0].([]*domain.Task)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// SearchTasks indicates an expected call of SearchTasks.
func (mr *MockTaskRepositoryMockRecorder) SearchTasks(ctx, query, limit interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SearchTasks", reflect.TypeOf((*MockTaskRepository)(nil).SearchTasks), ctx, query, limit)
}</span>

// UpdateTask mocks base method.
func (m *MockTaskRepository) UpdateTask(ctx context.Context, task *domain.Task) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateTask", ctx, task)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateTask indicates an expected call of UpdateTask.
func (mr *MockTaskRepositoryMockRecorder) UpdateTask(ctx, task interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateTask", reflect.TypeOf((*MockTaskRepository)(nil).UpdateTask), ctx, task)
}</pre>
		
		<pre class="file" id="file67" style="display: none">package usecase

import (
        "context"
        "errors"
        "fmt"
        "strings"
        "time"

        "github.com/google/uuid"
        commonDomain "github.com/hryt430/Yotei+/internal/common/domain"
        "github.com/hryt430/Yotei+/internal/modules/task/domain"
        "github.com/hryt430/Yotei+/pkg/logger"
)

type UserValidator = commonDomain.UserValidator

// EventPublisher はイベント発行のインターフェース
type EventPublisher interface {
        PublishTaskCreated(ctx context.Context, task *domain.Task) error
        PublishTaskUpdated(ctx context.Context, task *domain.Task) error
        PublishTaskDeleted(ctx context.Context, taskID string) error
        PublishTaskAssigned(ctx context.Context, task *domain.Task) error
        PublishTaskCompleted(ctx context.Context, task *domain.Task) error
}

// === 構造体定義 ===

// / UserInfo はユーザーの基本情報（共通定義を使用）
type UserInfo = commonDomain.UserInfo

// TaskWithUserInfo はタスクとユーザー情報を含む構造体（N+1問題解決用）
type TaskWithUserInfo struct {
        Task         *domain.Task `json:"task"`
        CreatorInfo  *UserInfo    `json:"creator_info,omitempty"`
        AssigneeInfo *UserInfo    `json:"assignee_info,omitempty"`
}

// TaskService は改良されたタスクサービス
type TaskService struct {
        TaskRepository TaskRepository
        UserValidator  UserValidator
        EventPublisher EventPublisher
        Logger         logger.Logger

        // 非同期イベント設定
        AsyncEventTimeout time.Duration
        MaxRetries        int
}

// NewTaskService はTaskServiceのコンストラクタ
func NewTaskService(
        taskRepo TaskRepository,
        userValidator UserValidator,
        eventPublisher EventPublisher,
        logger logger.Logger,
) *TaskService <span class="cov8" title="1">{
        return &amp;TaskService{
                TaskRepository:    taskRepo,
                UserValidator:     userValidator,
                EventPublisher:    eventPublisher,
                Logger:            logger,
                AsyncEventTimeout: 30 * time.Second,
                MaxRetries:        3,
        }
}</span>

// === エラー定義 ===

var (
        ErrTaskNotFound        = errors.New("task not found")
        ErrInvalidParameter    = errors.New("invalid parameter")
        ErrUserNotFound        = errors.New("user not found")
        ErrDuplicateAssignment = errors.New("task already assigned to this user")
)

// === メインサービスメソッド ===

// CreateTask はタスクを作成する（統一インターフェース使用）
func (s *TaskService) CreateTask(
        ctx context.Context,
        title,
        description string,
        priority domain.Priority,
        category domain.Category,
        createdBy string,
) (*domain.Task, error) <span class="cov8" title="1">{
        // 入力バリデーション
        if err := s.validateCreateTaskInput(title, description, createdBy); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // 作成者の存在確認（統一インターフェース使用）
        <span class="cov8" title="1">exists, err := s.UserValidator.UserExists(ctx, createdBy)
        if err != nil </span><span class="cov8" title="1">{
                s.Logger.Error("Failed to validate user existence",
                        logger.Any("userID", createdBy), logger.Error(err))
                return nil, fmt.Errorf("failed to validate user: %w", err)
        }</span>
        <span class="cov8" title="1">if !exists </span><span class="cov8" title="1">{
                return nil, ErrUserNotFound
        }</span>

        // タスク作成
        <span class="cov8" title="1">task := domain.NewTask(title, description, priority, category, createdBy)
        task.ID = uuid.New().String()

        err = s.TaskRepository.CreateTask(ctx, task)
        if err != nil </span><span class="cov8" title="1">{
                s.Logger.Error("Failed to create task",
                        logger.Any("taskID", task.ID), logger.Error(err))
                return nil, fmt.Errorf("failed to create task: %w", err)
        }</span>

        // イベント発行（非同期）
        <span class="cov8" title="1">s.publishEventAsync(ctx, "task_created", func() error </span><span class="cov8" title="1">{
                return s.EventPublisher.PublishTaskCreated(ctx, task)
        }</span>)

        <span class="cov8" title="1">s.Logger.Info("Task created successfully",
                logger.Any("taskID", task.ID), logger.Any("createdBy", createdBy))

        return task, nil</span>
}

// CreateTaskWithDefaults はデフォルトカテゴリでタスクを作成する（下位互換性）
func (s *TaskService) CreateTaskWithDefaults(
        ctx context.Context,
        title,
        description string,
        priority domain.Priority,
        createdBy string,
) (*domain.Task, error) <span class="cov0" title="0">{
        return s.CreateTask(ctx, title, description, priority, domain.CategoryOther, createdBy)
}</span>

// GetTask はIDに基づいてタスクを取得する
func (s *TaskService) GetTask(ctx context.Context, id string) (*domain.Task, error) <span class="cov8" title="1">{
        if id == "" </span><span class="cov8" title="1">{
                return nil, ErrInvalidParameter
        }</span>
        <span class="cov8" title="1">return s.TaskRepository.GetTaskByID(ctx, id)</span>
}

// GetTaskWithUserInfo はタスクとユーザー情報を一緒に取得（統一インターフェース使用）
func (s *TaskService) GetTaskWithUserInfo(ctx context.Context, id string) (*TaskWithUserInfo, error) <span class="cov0" title="0">{
        if id == "" </span><span class="cov0" title="0">{
                return nil, ErrInvalidParameter
        }</span>

        <span class="cov0" title="0">task, err := s.TaskRepository.GetTaskByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">result := &amp;TaskWithUserInfo{
                Task: task,
        }

        // ユーザー情報を一括取得（N+1問題解決）
        userIDs := []string{task.CreatedBy}
        if task.AssigneeID != nil </span><span class="cov0" title="0">{
                userIDs = append(userIDs, *task.AssigneeID)
        }</span>

        <span class="cov0" title="0">userInfoMap, err := s.UserValidator.GetUsersInfoBatch(ctx, userIDs)
        if err != nil </span><span class="cov0" title="0">{
                s.Logger.Error("Failed to get user info batch", logger.Error(err))
                // エラーでもタスク情報は返す（ユーザー情報は空）
        }</span> else<span class="cov0" title="0"> {
                result.CreatorInfo = userInfoMap[task.CreatedBy]
                if task.AssigneeID != nil </span><span class="cov0" title="0">{
                        result.AssigneeInfo = userInfoMap[*task.AssigneeID]
                }</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

// ListTasks はタスク一覧を取得する
func (s *TaskService) ListTasks(
        ctx context.Context,
        filter domain.ListFilter,
        pagination domain.Pagination,
        sortOptions domain.SortOptions,
) ([]*domain.Task, int, error) <span class="cov0" title="0">{
        // デフォルト値の設定
        if pagination.Page &lt;= 0 </span><span class="cov0" title="0">{
                pagination.Page = 1
        }</span>
        <span class="cov0" title="0">if pagination.PageSize &lt;= 0 </span><span class="cov0" title="0">{
                pagination.PageSize = 10
        }</span>
        <span class="cov0" title="0">if pagination.PageSize &gt; 100 </span><span class="cov0" title="0">{
                pagination.PageSize = 100 // 大量データ防止
        }</span>

        // ソートオプションのデフォルト値
        <span class="cov0" title="0">if sortOptions.Field == "" </span><span class="cov0" title="0">{
                sortOptions.Field = "created_at"
        }</span>
        <span class="cov0" title="0">if sortOptions.Direction == "" </span><span class="cov0" title="0">{
                sortOptions.Direction = "DESC"
        }</span>

        <span class="cov0" title="0">return s.TaskRepository.ListTasks(ctx, filter, pagination, sortOptions)</span>
}

// ListTasksWithUserInfo はタスク一覧とユーザー情報を一緒に取得（N+1問題解決）
func (s *TaskService) ListTasksWithUserInfo(
        ctx context.Context,
        filter domain.ListFilter,
        pagination domain.Pagination,
        sortOptions domain.SortOptions,
) ([]*TaskWithUserInfo, int, error) <span class="cov0" title="0">{
        // タスク一覧を取得
        tasks, total, err := s.ListTasks(ctx, filter, pagination, sortOptions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">if len(tasks) == 0 </span><span class="cov0" title="0">{
                return []*TaskWithUserInfo{}, total, nil
        }</span>

        // ユーザーIDを収集（重複除去でN+1問題解決）
        <span class="cov0" title="0">userIDSet := make(map[string]bool)
        for _, task := range tasks </span><span class="cov0" title="0">{
                userIDSet[task.CreatedBy] = true
                if task.AssigneeID != nil </span><span class="cov0" title="0">{
                        userIDSet[*task.AssigneeID] = true
                }</span>
        }

        <span class="cov0" title="0">userIDs := make([]string, 0, len(userIDSet))
        for userID := range userIDSet </span><span class="cov0" title="0">{
                userIDs = append(userIDs, userID)
        }</span>

        // ユーザー情報を一括取得（修正：UserInfoで統一）
        <span class="cov0" title="0">userInfoMap := make(map[string]*UserInfo)
        if len(userIDs) &gt; 0 </span><span class="cov0" title="0">{
                if batchInfo, err := s.UserValidator.GetUsersInfoBatch(ctx, userIDs); err == nil </span><span class="cov0" title="0">{
                        userInfoMap = batchInfo
                }</span> else<span class="cov0" title="0"> {
                        s.Logger.Error("Failed to get user info batch", logger.Error(err))
                        // エラーログは出力するが、処理は継続（グレースフルな劣化）
                }</span>
        }

        // 結果を組み立て
        <span class="cov0" title="0">result := make([]*TaskWithUserInfo, len(tasks))
        for i, task := range tasks </span><span class="cov0" title="0">{
                result[i] = &amp;TaskWithUserInfo{
                        Task:        task,
                        CreatorInfo: userInfoMap[task.CreatedBy],
                }
                if task.AssigneeID != nil </span><span class="cov0" title="0">{
                        result[i].AssigneeInfo = userInfoMap[*task.AssigneeID]
                }</span>
        }

        <span class="cov0" title="0">return result, total, nil</span>
}

// UpdateTask はタスクを更新する（イベント発行）
func (s *TaskService) UpdateTask(
        ctx context.Context,
        id string,
        title, description *string,
        status *domain.TaskStatus,
        priority *domain.Priority,
        dueDate *time.Time,
) (*domain.Task, error) <span class="cov0" title="0">{
        if id == "" </span><span class="cov0" title="0">{
                return nil, ErrInvalidParameter
        }</span>

        // 更新内容のバリデーション
        <span class="cov0" title="0">if err := s.validateUpdateTaskInput(title, description); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">task, err := s.TaskRepository.GetTaskByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 変更追跡
        <span class="cov0" title="0">hasChanges := false
        oldStatus := task.Status

        // 各フィールドの更新（指定されている場合のみ）
        if title != nil &amp;&amp; *title != task.Title </span><span class="cov0" title="0">{
                task.Title = *title
                hasChanges = true
        }</span>
        <span class="cov0" title="0">if description != nil &amp;&amp; *description != task.Description </span><span class="cov0" title="0">{
                task.Description = *description
                hasChanges = true
        }</span>
        <span class="cov0" title="0">if status != nil &amp;&amp; *status != task.Status </span><span class="cov0" title="0">{
                task.Status = *status
                hasChanges = true
        }</span>
        <span class="cov0" title="0">if priority != nil &amp;&amp; *priority != task.Priority </span><span class="cov0" title="0">{
                task.Priority = *priority
                hasChanges = true
        }</span>
        <span class="cov0" title="0">if dueDate != nil </span><span class="cov0" title="0">{
                if task.DueDate == nil || !dueDate.Equal(*task.DueDate) </span><span class="cov0" title="0">{
                        task.DueDate = dueDate
                        hasChanges = true
                }</span>
        }

        // 変更がない場合は早期リターン
        <span class="cov0" title="0">if !hasChanges </span><span class="cov0" title="0">{
                return task, nil
        }</span>

        <span class="cov0" title="0">task.UpdatedAt = time.Now()

        err = s.TaskRepository.UpdateTask(ctx, task)
        if err != nil </span><span class="cov0" title="0">{
                s.Logger.Error("Failed to update task",
                        logger.Any("taskID", id), logger.Error(err))
                return nil, fmt.Errorf("failed to update task: %w", err)
        }</span>

        // イベント発行（非同期）
        <span class="cov0" title="0">s.publishEventAsync(ctx, "task_updated", func() error </span><span class="cov0" title="0">{
                return s.EventPublisher.PublishTaskUpdated(ctx, task)
        }</span>)

        // 完了状態になった場合の追加イベント
        <span class="cov0" title="0">if oldStatus != domain.TaskStatusDone &amp;&amp; task.Status == domain.TaskStatusDone </span><span class="cov0" title="0">{
                s.publishEventAsync(ctx, "task_completed", func() error </span><span class="cov0" title="0">{
                        return s.EventPublisher.PublishTaskCompleted(ctx, task)
                }</span>)
        }

        <span class="cov0" title="0">s.Logger.Info("Task updated successfully", logger.Any("taskID", id))
        return task, nil</span>
}

// DeleteTask はタスクを削除する（イベント発行）
func (s *TaskService) DeleteTask(ctx context.Context, id string) error <span class="cov8" title="1">{
        if id == "" </span><span class="cov8" title="1">{
                return ErrInvalidParameter
        }</span>

        // 存在確認
        <span class="cov8" title="1">_, err := s.TaskRepository.GetTaskByID(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">err = s.TaskRepository.DeleteTask(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                s.Logger.Error("Failed to delete task",
                        logger.Any("taskID", id), logger.Error(err))
                return fmt.Errorf("failed to delete task: %w", err)
        }</span>

        // イベント発行（非同期）
        <span class="cov8" title="1">s.publishEventAsync(ctx, "task_deleted", func() error </span><span class="cov8" title="1">{
                return s.EventPublisher.PublishTaskDeleted(ctx, id)
        }</span>)

        <span class="cov8" title="1">s.Logger.Info("Task deleted successfully", logger.Any("taskID", id))
        return nil</span>
}

// / AssignTask はタスクを指定されたユーザーに割り当てる（統一インターフェース使用）
func (s *TaskService) AssignTask(ctx context.Context, taskID string, assigneeID string) (*domain.Task, error) <span class="cov8" title="1">{
        if taskID == "" || assigneeID == "" </span><span class="cov8" title="1">{
                return nil, ErrInvalidParameter
        }</span>

        // アサイン先ユーザーの存在確認（統一インターフェース使用）
        <span class="cov8" title="1">exists, err := s.UserValidator.UserExists(ctx, assigneeID)
        if err != nil </span><span class="cov0" title="0">{
                s.Logger.Error("Failed to validate assignee existence",
                        logger.Any("assigneeID", assigneeID), logger.Error(err))
                return nil, fmt.Errorf("failed to validate assignee: %w", err)
        }</span>
        <span class="cov8" title="1">if !exists </span><span class="cov8" title="1">{
                return nil, ErrUserNotFound
        }</span>

        <span class="cov8" title="1">task, err := s.TaskRepository.GetTaskByID(ctx, taskID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // 既に同じユーザーにアサインされているかチェック
        <span class="cov8" title="1">if task.AssigneeID != nil &amp;&amp; *task.AssigneeID == assigneeID </span><span class="cov8" title="1">{
                return nil, ErrDuplicateAssignment
        }</span>

        <span class="cov8" title="1">task.AssignTo(assigneeID)

        err = s.TaskRepository.UpdateTask(ctx, task)
        if err != nil </span><span class="cov0" title="0">{
                s.Logger.Error("Failed to update task assignment",
                        logger.Any("taskID", taskID), logger.Error(err))
                return nil, fmt.Errorf("failed to update task assignment: %w", err)
        }</span>

        // イベント発行（非同期）
        <span class="cov8" title="1">s.publishEventAsync(ctx, "task_assigned", func() error </span><span class="cov8" title="1">{
                return s.EventPublisher.PublishTaskAssigned(ctx, task)
        }</span>)

        <span class="cov8" title="1">s.Logger.Info("Task assigned successfully",
                logger.Any("taskID", taskID), logger.Any("assigneeID", assigneeID))

        return task, nil</span>
}

// ChangeTaskStatus はタスクのステータスを変更する（イベント発行）
func (s *TaskService) ChangeTaskStatus(ctx context.Context, taskID string, status domain.TaskStatus) (*domain.Task, error) <span class="cov8" title="1">{
        if taskID == "" </span><span class="cov0" title="0">{
                return nil, ErrInvalidParameter
        }</span>

        <span class="cov8" title="1">task, err := s.TaskRepository.GetTaskByID(ctx, taskID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">oldStatus := task.Status
        task.SetStatus(status)

        err = s.TaskRepository.UpdateTask(ctx, task)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // イベント発行（非同期）
        <span class="cov8" title="1">s.publishEventAsync(ctx, "task_updated", func() error </span><span class="cov8" title="1">{
                return s.EventPublisher.PublishTaskUpdated(ctx, task)
        }</span>)

        // 完了状態になった場合の追加イベント
        <span class="cov8" title="1">if oldStatus != domain.TaskStatusDone &amp;&amp; status == domain.TaskStatusDone </span><span class="cov8" title="1">{
                s.publishEventAsync(ctx, "task_completed", func() error </span><span class="cov8" title="1">{
                        return s.EventPublisher.PublishTaskCompleted(ctx, task)
                }</span>)
        }

        <span class="cov8" title="1">return task, nil</span>
}

// === その他のメソッド ===

// GetOverdueTasks は期限切れのタスクを取得する
func (s *TaskService) GetOverdueTasks(ctx context.Context) ([]*domain.Task, error) <span class="cov0" title="0">{
        return s.TaskRepository.GetOverdueTasks(ctx)
}</span>

// GetTasksByAssignee は特定のユーザーに割り当てられたタスクを取得する
func (s *TaskService) GetTasksByAssignee(ctx context.Context, userID string) ([]*domain.Task, error) <span class="cov0" title="0">{
        if userID == "" </span><span class="cov0" title="0">{
                return nil, ErrInvalidParameter
        }</span>
        <span class="cov0" title="0">return s.TaskRepository.GetTasksByAssignee(ctx, userID)</span>
}

// SearchTasks はタスクを検索する
func (s *TaskService) SearchTasks(ctx context.Context, query string, limit int) ([]*domain.Task, error) <span class="cov0" title="0">{
        if query == "" </span><span class="cov0" title="0">{
                return nil, ErrInvalidParameter
        }</span>
        <span class="cov0" title="0">if limit &lt;= 0 || limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 20
        }</span>
        <span class="cov0" title="0">return s.TaskRepository.SearchTasks(ctx, query, limit)</span>
}

// === 非同期イベント発行メソッド ===

// publishEventAsync はイベントを非同期で発行する
func (s *TaskService) publishEventAsync(ctx context.Context, eventType string, publishFunc func() error) <span class="cov8" title="1">{
        go func() </span><span class="cov8" title="1">{
                // タイムアウト付きコンテキスト
                _, cancel := context.WithTimeout(ctx, s.AsyncEventTimeout)
                defer cancel()

                var lastErr error
                for attempt := 1; attempt &lt;= s.MaxRetries; attempt++ </span><span class="cov8" title="1">{
                        if err := publishFunc(); err != nil </span><span class="cov0" title="0">{
                                lastErr = err
                                s.Logger.Warn("Event publish failed, retrying...",
                                        logger.Any("eventType", eventType),
                                        logger.Any("attempt", attempt),
                                        logger.Error(err))

                                // 指数バックオフで再試行
                                time.Sleep(time.Duration(attempt) * time.Second)
                                continue</span>
                        }

                        // 成功
                        <span class="cov8" title="1">s.Logger.Debug("Event published successfully",
                                logger.Any("eventType", eventType),
                                logger.Any("attempt", attempt))
                        return</span>
                }

                // 全ての試行が失敗
                <span class="cov0" title="0">s.Logger.Error("Event publish failed after all retries",
                        logger.Any("eventType", eventType),
                        logger.Any("maxRetries", s.MaxRetries),
                        logger.Error(lastErr))</span>
        }()
}

// === バリデーション関数 ===

func (s *TaskService) validateCreateTaskInput(title, description, createdBy string) error <span class="cov8" title="1">{
        if strings.TrimSpace(title) == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: title is required", ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">if len(title) &gt; 255 </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: title too long (max 255 characters)", ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">if len(description) &gt; 2000 </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: description too long (max 2000 characters)", ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(createdBy) == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: createdBy is required", ErrInvalidParameter)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *TaskService) validateUpdateTaskInput(title, description *string) error <span class="cov0" title="0">{
        if title != nil </span><span class="cov0" title="0">{
                if strings.TrimSpace(*title) == "" </span><span class="cov0" title="0">{
                        return ErrInvalidParameter
                }</span>
                <span class="cov0" title="0">if len(*title) &gt; 255 </span><span class="cov0" title="0">{
                        return errors.New("title too long (max 255 characters)")
                }</span>
        }
        <span class="cov0" title="0">if description != nil &amp;&amp; len(*description) &gt; 5000 </span><span class="cov0" title="0">{
                return errors.New("description too long (max 5000 characters)")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package usecase

import (
        "context"
        "fmt"
        "time"

        "github.com/hryt430/Yotei+/internal/modules/task/domain"
        "github.com/hryt430/Yotei+/pkg/logger"
)

// StatsRepository は統計情報取得のためのリポジトリインターフェース
type StatsRepository interface {
        // GetTasksByDateRange は指定された日付範囲のタスクを取得する
        GetTasksByDateRange(ctx context.Context, userID string, start, end time.Time) ([]*domain.Task, error)

        // GetTasksByDueDate は指定された期限日のタスクを取得する
        GetTasksByDueDate(ctx context.Context, userID string, dueDate time.Time) ([]*domain.Task, error)

        // GetRecentCompletedTasks は最近完了したタスクを取得する
        GetRecentCompletedTasks(ctx context.Context, userID string, limit int) ([]*domain.Task, error)

        // GetOverdueTasksCount は期限切れタスク数を取得する
        GetOverdueTasksCount(ctx context.Context, userID string) (int, error)
}

// TaskStatsService はタスク統計情報を提供するサービス
type TaskStatsService struct {
        taskRepo  TaskRepository
        statsRepo StatsRepository
        logger    *logger.Logger
}

// NewTaskStatsService は新しいTaskStatsServiceを作成する
func NewTaskStatsService(
        taskRepo TaskRepository,
        statsRepo StatsRepository,
        logger *logger.Logger,
) *TaskStatsService <span class="cov8" title="1">{
        return &amp;TaskStatsService{
                taskRepo:  taskRepo,
                statsRepo: statsRepo,
                logger:    logger,
        }
}</span>

// GetDashboardStats はダッシュボード用の統計情報を取得する
func (s *TaskStatsService) GetDashboardStats(ctx context.Context, userID string) (*domain.DashboardStats, error) <span class="cov8" title="1">{
        now := time.Now()

        // 今日の統計
        todayStats, err := s.GetDailyStats(ctx, userID, now)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error("Failed to get today stats", logger.Any("userID", userID), logger.Error(err))
                return nil, fmt.Errorf("failed to get today stats: %w", err)
        }</span>

        // 今週の統計
        <span class="cov8" title="1">weeklyOverview, err := s.GetWeeklyStats(ctx, userID, now)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get weekly stats", logger.Any("userID", userID), logger.Error(err))
                return nil, fmt.Errorf("failed to get weekly stats: %w", err)
        }</span>

        // 来週のプレビュー
        <span class="cov8" title="1">nextWeek := now.AddDate(0, 0, 7)
        upcomingWeekTasks, err := s.GetWeeklyPreview(ctx, userID, nextWeek)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get upcoming week tasks", logger.Any("userID", userID), logger.Error(err))
                return nil, fmt.Errorf("failed to get upcoming week tasks: %w", err)
        }</span>

        // カテゴリ別統計
        <span class="cov8" title="1">categoryBreakdown, err := s.GetCategoryBreakdown(ctx, userID)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error("Failed to get category breakdown", logger.Any("userID", userID), logger.Error(err))
                categoryBreakdown = make(map[domain.Category]int) // エラー時は空のマップ
        }</span>

        // 優先度別統計
        <span class="cov8" title="1">priorityBreakdown, err := s.GetPriorityBreakdown(ctx, userID)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error("Failed to get priority breakdown", logger.Any("userID", userID), logger.Error(err))
                priorityBreakdown = make(map[domain.Priority]int) // エラー時は空のマップ
        }</span>

        // 最近の完了タスク
        <span class="cov8" title="1">recentCompletions, err := s.statsRepo.GetRecentCompletedTasks(ctx, userID, 5)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error("Failed to get recent completions", logger.Any("userID", userID), logger.Error(err))
                recentCompletions = []*domain.Task{} // エラー時は空のスライス
        }</span>

        // 期限切れタスク数
        <span class="cov8" title="1">overdueCount, err := s.statsRepo.GetOverdueTasksCount(ctx, userID)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error("Failed to get overdue count", logger.Any("userID", userID), logger.Error(err))
                overdueCount = 0 // エラー時は0
        }</span>

        <span class="cov8" title="1">return &amp;domain.DashboardStats{
                TodayStats:        todayStats,
                WeeklyOverview:    weeklyOverview,
                UpcomingWeekTasks: upcomingWeekTasks,
                CategoryBreakdown: categoryBreakdown,
                PriorityBreakdown: priorityBreakdown,
                RecentCompletions: recentCompletions,
                OverdueTasksCount: overdueCount,
        }, nil</span>
}

// GetDailyStats は指定日の統計情報を取得する
func (s *TaskStatsService) GetDailyStats(ctx context.Context, userID string, date time.Time) (*domain.DailyStats, error) <span class="cov8" title="1">{
        dayStart, dayEnd := domain.GetDayStartEnd(date)

        // その日が期限のタスクを取得
        tasks, err := s.statsRepo.GetTasksByDueDate(ctx, userID, date)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get tasks by due date: %w", err)
        }</span>

        // その日に作成されたタスクも含める
        <span class="cov8" title="1">createdTasks, err := s.statsRepo.GetTasksByDateRange(ctx, userID, dayStart, dayEnd)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get tasks by date range: %w", err)
        }</span>

        // 重複を除去してマージ
        <span class="cov8" title="1">taskMap := make(map[string]*domain.Task)
        for _, task := range tasks </span><span class="cov8" title="1">{
                taskMap[task.ID] = task
        }</span>
        <span class="cov8" title="1">for _, task := range createdTasks </span><span class="cov8" title="1">{
                taskMap[task.ID] = task
        }</span>

        <span class="cov8" title="1">allTasks := make([]*domain.Task, 0, len(taskMap))
        for _, task := range taskMap </span><span class="cov8" title="1">{
                allTasks = append(allTasks, task)
        }</span>

        <span class="cov8" title="1">return domain.NewDailyStats(date, allTasks), nil</span>
}

// GetWeeklyStats は指定週の統計情報を取得する
func (s *TaskStatsService) GetWeeklyStats(ctx context.Context, userID string, date time.Time) (*domain.WeeklyStats, error) <span class="cov8" title="1">{
        weekStart, weekEnd := domain.GetWeekStartEnd(date)

        dailyStats := make(map[string]*domain.DailyStats)

        // 各曜日の統計を取得
        for d := weekStart; !d.After(weekEnd); d = d.AddDate(0, 0, 1) </span><span class="cov8" title="1">{
                dayStats, err := s.GetDailyStats(ctx, userID, d)
                if err != nil </span><span class="cov8" title="1">{
                        s.logger.Error("Failed to get daily stats",
                                logger.Any("userID", userID),
                                logger.Any("date", d),
                                logger.Error(err))
                        // エラーでも継続（空の統計で代替）
                        dayStats = domain.NewDailyStats(d, []*domain.Task{})
                }</span>

                <span class="cov8" title="1">weekdayName := domain.GetWeekdayName(d.Weekday())
                dailyStats[weekdayName] = dayStats</span>
        }

        <span class="cov8" title="1">return domain.NewWeeklyStats(weekStart, weekEnd, dailyStats), nil</span>
}

// GetWeeklyPreview は指定週のプレビュー情報を取得する
func (s *TaskStatsService) GetWeeklyPreview(ctx context.Context, userID string, date time.Time) (*domain.WeeklyPreview, error) <span class="cov8" title="1">{
        weekStart, weekEnd := domain.GetWeekStartEnd(date)

        preview := &amp;domain.WeeklyPreview{
                WeekStart:    weekStart,
                WeekEnd:      weekEnd,
                DailyPreview: make(map[string]*domain.DailyPreview),
        }

        // 各曜日のプレビューを取得
        for d := weekStart; !d.After(weekEnd); d = d.AddDate(0, 0, 1) </span><span class="cov8" title="1">{
                tasks, err := s.statsRepo.GetTasksByDueDate(ctx, userID, d)
                if err != nil </span><span class="cov8" title="1">{
                        s.logger.Error("Failed to get tasks for preview",
                                logger.Any("userID", userID),
                                logger.Any("date", d),
                                logger.Error(err))
                        tasks = []*domain.Task{} // エラー時は空のスライス
                }</span>

                <span class="cov8" title="1">hasOverdue := false
                for _, task := range tasks </span><span class="cov8" title="1">{
                        if task.CheckIsOverdue() </span><span class="cov0" title="0">{
                                hasOverdue = true
                                break</span>
                        }
                }

                <span class="cov8" title="1">weekdayName := domain.GetWeekdayName(d.Weekday())
                preview.DailyPreview[weekdayName] = &amp;domain.DailyPreview{
                        Date:       d,
                        TaskCount:  len(tasks),
                        HasOverdue: hasOverdue,
                }

                preview.TotalTasks += len(tasks)</span>
        }

        <span class="cov8" title="1">return preview, nil</span>
}

// GetCategoryBreakdown はカテゴリ別のタスク分布を取得する
func (s *TaskStatsService) GetCategoryBreakdown(ctx context.Context, userID string) (map[domain.Category]int, error) <span class="cov8" title="1">{
        // 過去30日間のタスクを対象とする
        endDate := time.Now()
        startDate := endDate.AddDate(0, 0, -30)

        tasks, err := s.statsRepo.GetTasksByDateRange(ctx, userID, startDate, endDate)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get tasks for category breakdown: %w", err)
        }</span>

        <span class="cov8" title="1">breakdown := make(map[domain.Category]int)
        for _, task := range tasks </span><span class="cov8" title="1">{
                breakdown[task.Category]++
        }</span>

        <span class="cov8" title="1">return breakdown, nil</span>
}

// GetPriorityBreakdown は優先度別のタスク分布を取得する
func (s *TaskStatsService) GetPriorityBreakdown(ctx context.Context, userID string) (map[domain.Priority]int, error) <span class="cov8" title="1">{
        // アクティブなタスク（完了していないタスク）を対象とする
        filter := domain.ListFilter{
                AssigneeID: &amp;userID,
        }

        pagination := domain.Pagination{
                Page:     1,
                PageSize: 1000, // 十分に大きな値
        }

        sortOptions := domain.SortOptions{
                Field:     "created_at",
                Direction: "DESC",
        }

        tasks, _, err := s.taskRepo.ListTasks(ctx, filter, pagination, sortOptions)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get tasks for priority breakdown: %w", err)
        }</span>

        <span class="cov8" title="1">breakdown := make(map[domain.Priority]int)
        for _, task := range tasks </span><span class="cov8" title="1">{
                if task.Status != domain.TaskStatusDone </span><span class="cov8" title="1">{
                        breakdown[task.Priority]++
                }</span>
        }

        <span class="cov8" title="1">return breakdown, nil</span>
}

// GetProgressSummary は進捗サマリーを取得する
func (s *TaskStatsService) GetProgressSummary(ctx context.Context, userID string, days int) ([]*domain.DailyStats, error) <span class="cov8" title="1">{
        summary := make([]*domain.DailyStats, 0, days)

        today := time.Now()
        for i := days - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                date := today.AddDate(0, 0, -i)
                dailyStats, err := s.GetDailyStats(ctx, userID, date)
                if err != nil </span><span class="cov8" title="1">{
                        s.logger.Error("Failed to get daily stats for summary",
                                logger.Any("userID", userID),
                                logger.Any("date", date),
                                logger.Error(err))
                        // エラーでも継続（空の統計で代替）
                        dailyStats = domain.NewDailyStats(date, []*domain.Task{})
                }</span>
                <span class="cov8" title="1">summary = append(summary, dailyStats)</span>
        }

        <span class="cov8" title="1">return summary, nil</span>
}

// GetMonthlyStats は月次統計を取得する
func (s *TaskStatsService) GetMonthlyStats(ctx context.Context, userID string, year int, month time.Month) (*domain.WeeklyStats, error) <span class="cov8" title="1">{
        // 月の開始日と終了日を取得
        monthStart := time.Date(year, month, 1, 0, 0, 0, 0, time.UTC)
        monthEnd := monthStart.AddDate(0, 1, -1)
        monthEnd = time.Date(monthEnd.Year(), monthEnd.Month(), monthEnd.Day(), 23, 59, 59, 999999999, time.UTC)

        // 月間のタスクを取得
        tasks, err := s.statsRepo.GetTasksByDateRange(ctx, userID, monthStart, monthEnd)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get monthly tasks: %w", err)
        }</span>

        // 月間の統計を週単位で分割
        <span class="cov8" title="1">dailyStats := make(map[string]*domain.DailyStats)

        // 各日の統計を計算
        for d := monthStart; !d.After(monthEnd); d = d.AddDate(0, 0, 1) </span><span class="cov8" title="1">{
                dayTasks := make([]*domain.Task, 0)
                for _, task := range tasks </span><span class="cov8" title="1">{
                        // その日が期限日または作成日のタスクを抽出
                        if (task.DueDate != nil &amp;&amp; task.DueDate.Format("2006-01-02") == d.Format("2006-01-02")) ||
                                task.CreatedAt.Format("2006-01-02") == d.Format("2006-01-02") </span><span class="cov8" title="1">{
                                dayTasks = append(dayTasks, task)
                        }</span>
                }

                <span class="cov8" title="1">dayKey := d.Format("2006-01-02")
                dailyStats[dayKey] = domain.NewDailyStats(d, dayTasks)</span>
        }

        <span class="cov8" title="1">return domain.NewWeeklyStats(monthStart, monthEnd, dailyStats), nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
